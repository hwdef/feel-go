// Code generated from LiteParser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser // LiteParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 95, 1950,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 3, 2, 6, 2, 332, 10, 2, 13, 2, 14, 2, 333, 3, 3, 7, 3, 337, 10,
	3, 12, 3, 14, 3, 340, 11, 3, 3, 3, 5, 3, 343, 10, 3, 3, 3, 3, 3, 7, 3,
	347, 10, 3, 12, 3, 14, 3, 350, 11, 3, 3, 3, 7, 3, 353, 10, 3, 12, 3, 14,
	3, 356, 11, 3, 3, 4, 3, 4, 3, 4, 3, 4, 7, 4, 362, 10, 4, 12, 4, 14, 4,
	365, 11, 4, 3, 4, 3, 4, 3, 4, 3, 5, 5, 5, 371, 10, 5, 3, 5, 3, 5, 3, 5,
	5, 5, 376, 10, 5, 5, 5, 378, 10, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 395, 10, 6,
	3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 9, 5, 9,
	408, 10, 9, 3, 9, 3, 9, 3, 9, 7, 9, 413, 10, 9, 12, 9, 14, 9, 416, 11,
	9, 3, 9, 3, 9, 3, 9, 7, 9, 421, 10, 9, 12, 9, 14, 9, 424, 11, 9, 3, 9,
	3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 5, 10, 432, 10, 10, 3, 10, 5, 10, 435,
	10, 10, 3, 10, 3, 10, 3, 11, 5, 11, 440, 10, 11, 3, 11, 3, 11, 3, 11, 3,
	11, 3, 11, 3, 11, 5, 11, 448, 10, 11, 5, 11, 450, 10, 11, 3, 11, 3, 11,
	3, 12, 5, 12, 455, 10, 12, 3, 12, 3, 12, 3, 12, 5, 12, 460, 10, 12, 3,
	12, 3, 12, 3, 12, 3, 12, 6, 12, 466, 10, 12, 13, 12, 14, 12, 467, 3, 12,
	3, 12, 5, 12, 472, 10, 12, 3, 12, 3, 12, 3, 13, 5, 13, 477, 10, 13, 3,
	13, 3, 13, 5, 13, 481, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 14, 5, 14,
	488, 10, 14, 3, 14, 3, 14, 5, 14, 492, 10, 14, 3, 14, 3, 14, 3, 14, 3,
	14, 7, 14, 498, 10, 14, 12, 14, 14, 14, 501, 11, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 7, 14, 507, 10, 14, 12, 14, 14, 14, 510, 11, 14, 3, 14, 3, 14, 3,
	14, 3, 15, 5, 15, 516, 10, 15, 3, 15, 3, 15, 5, 15, 520, 10, 15, 3, 15,
	3, 15, 3, 15, 7, 15, 525, 10, 15, 12, 15, 14, 15, 528, 11, 15, 3, 15, 3,
	15, 3, 15, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 537, 10, 16, 3, 17, 3, 17,
	3, 17, 3, 17, 3, 18, 5, 18, 544, 10, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 5, 18, 554, 10, 18, 3, 18, 3, 18, 5, 18, 558,
	10, 18, 3, 18, 3, 18, 7, 18, 562, 10, 18, 12, 18, 14, 18, 565, 11, 18,
	3, 18, 3, 18, 3, 19, 5, 19, 570, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 3, 19, 5, 19, 578, 10, 19, 5, 19, 580, 10, 19, 3, 19, 3, 19, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 589, 10, 20, 3, 20, 3, 20, 6, 20, 593,
	10, 20, 13, 20, 14, 20, 594, 3, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 22, 3, 22, 3, 22, 5, 22, 610, 10, 22, 3,
	22, 7, 22, 613, 10, 22, 12, 22, 14, 22, 616, 11, 22, 3, 22, 3, 22, 7, 22,
	620, 10, 22, 12, 22, 14, 22, 623, 11, 22, 3, 22, 3, 22, 3, 22, 3, 23, 3,
	23, 3, 23, 5, 23, 631, 10, 23, 3, 24, 5, 24, 634, 10, 24, 3, 24, 3, 24,
	5, 24, 638, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 7, 24, 644, 10, 24, 12,
	24, 14, 24, 647, 11, 24, 3, 24, 3, 24, 3, 24, 3, 24, 7, 24, 653, 10, 24,
	12, 24, 14, 24, 656, 11, 24, 3, 24, 3, 24, 3, 24, 3, 25, 5, 25, 662, 10,
	25, 3, 25, 3, 25, 3, 25, 5, 25, 667, 10, 25, 3, 25, 3, 25, 3, 25, 3, 25,
	6, 25, 673, 10, 25, 13, 25, 14, 25, 674, 3, 25, 3, 25, 5, 25, 679, 10,
	25, 3, 25, 3, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 7, 26, 689,
	10, 26, 12, 26, 14, 26, 692, 11, 26, 3, 26, 3, 26, 7, 26, 696, 10, 26,
	12, 26, 14, 26, 699, 11, 26, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27,
	5, 27, 707, 10, 27, 3, 28, 5, 28, 710, 10, 28, 3, 28, 5, 28, 713, 10, 28,
	3, 28, 3, 28, 5, 28, 717, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 723,
	10, 28, 12, 28, 14, 28, 726, 11, 28, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28,
	732, 10, 28, 12, 28, 14, 28, 735, 11, 28, 3, 28, 3, 28, 3, 28, 3, 29, 5,
	29, 741, 10, 29, 3, 29, 5, 29, 744, 10, 29, 3, 29, 3, 29, 3, 29, 5, 29,
	749, 10, 29, 3, 29, 3, 29, 3, 29, 3, 29, 6, 29, 755, 10, 29, 13, 29, 14,
	29, 756, 3, 29, 3, 29, 5, 29, 761, 10, 29, 3, 29, 3, 29, 3, 30, 5, 30,
	766, 10, 30, 3, 30, 3, 30, 5, 30, 770, 10, 30, 3, 30, 3, 30, 3, 30, 7,
	30, 775, 10, 30, 12, 30, 14, 30, 778, 11, 30, 3, 30, 3, 30, 3, 30, 3, 31,
	3, 31, 3, 31, 3, 31, 5, 31, 787, 10, 31, 3, 32, 5, 32, 790, 10, 32, 3,
	32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 7, 32, 798, 10, 32, 12, 32, 14,
	32, 801, 11, 32, 3, 32, 3, 32, 5, 32, 805, 10, 32, 3, 32, 3, 32, 3, 33,
	3, 33, 3, 34, 5, 34, 812, 10, 34, 3, 34, 3, 34, 5, 34, 816, 10, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 7, 34, 822, 10, 34, 12, 34, 14, 34, 825, 11, 34,
	3, 34, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 5, 35, 833, 10, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 7, 35, 839, 10, 35, 12, 35, 14, 35, 842, 11, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 7, 35, 848, 10, 35, 12, 35, 14, 35, 851, 11, 35, 3,
	35, 3, 35, 3, 35, 3, 36, 3, 36, 5, 36, 858, 10, 36, 3, 36, 3, 36, 3, 37,
	5, 37, 863, 10, 37, 3, 37, 3, 37, 3, 37, 7, 37, 868, 10, 37, 12, 37, 14,
	37, 871, 11, 37, 3, 38, 5, 38, 874, 10, 38, 3, 38, 3, 38, 3, 38, 7, 38,
	879, 10, 38, 12, 38, 14, 38, 882, 11, 38, 3, 39, 3, 39, 3, 39, 3, 40, 5,
	40, 888, 10, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 894, 10, 40, 3, 41,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 915, 10, 41,
	3, 42, 3, 42, 3, 42, 6, 42, 920, 10, 42, 13, 42, 14, 42, 921, 3, 42, 3,
	42, 3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 930, 10, 43, 12, 43, 14, 43, 933,
	11, 43, 3, 43, 3, 43, 7, 43, 937, 10, 43, 12, 43, 14, 43, 940, 11, 43,
	3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 948, 10, 44, 3, 44, 5,
	44, 951, 10, 44, 3, 45, 3, 45, 7, 45, 955, 10, 45, 12, 45, 14, 45, 958,
	11, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 965, 10, 45, 12, 45,
	14, 45, 968, 11, 45, 3, 45, 3, 45, 5, 45, 972, 10, 45, 3, 46, 3, 46, 3,
	46, 7, 46, 977, 10, 46, 12, 46, 14, 46, 980, 11, 46, 3, 46, 3, 46, 3, 47,
	3, 47, 3, 47, 3, 47, 7, 47, 988, 10, 47, 12, 47, 14, 47, 991, 11, 47, 3,
	47, 3, 47, 3, 48, 3, 48, 3, 48, 7, 48, 998, 10, 48, 12, 48, 14, 48, 1001,
	11, 48, 3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 7, 49, 1010, 10,
	49, 12, 49, 14, 49, 1013, 11, 49, 3, 49, 3, 49, 3, 49, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 5, 50, 1024, 10, 50, 3, 50, 3, 50, 3, 50, 7, 50,
	1029, 10, 50, 12, 50, 14, 50, 1032, 11, 50, 3, 50, 3, 50, 3, 50, 3, 51,
	3, 51, 3, 51, 3, 51, 7, 51, 1041, 10, 51, 12, 51, 14, 51, 1044, 11, 51,
	3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 52, 7, 52, 1052, 10, 52, 12, 52,
	14, 52, 1055, 11, 52, 3, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53,
	3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 7, 55, 1071, 10, 55, 12,
	55, 14, 55, 1074, 11, 55, 3, 55, 3, 55, 7, 55, 1078, 10, 55, 12, 55, 14,
	55, 1081, 11, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 7, 55, 1089,
	10, 55, 12, 55, 14, 55, 1092, 11, 55, 3, 55, 3, 55, 6, 55, 1096, 10, 55,
	13, 55, 14, 55, 1097, 3, 55, 3, 55, 5, 55, 1102, 10, 55, 3, 56, 3, 56,
	3, 56, 5, 56, 1107, 10, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3,
	57, 3, 57, 5, 57, 1117, 10, 57, 3, 57, 3, 57, 7, 57, 1121, 10, 57, 12,
	57, 14, 57, 1124, 11, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58, 7, 58, 1131,
	10, 58, 12, 58, 14, 58, 1134, 11, 58, 3, 58, 3, 58, 3, 59, 3, 59, 3, 59,
	5, 59, 1141, 10, 59, 3, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3,
	60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 5, 60,
	1160, 10, 60, 3, 61, 3, 61, 5, 61, 1164, 10, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 62, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63,
	3, 63, 3, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3,
	66, 3, 66, 3, 66, 3, 66, 7, 66, 1194, 10, 66, 12, 66, 14, 66, 1197, 11,
	66, 3, 67, 3, 67, 5, 67, 1201, 10, 67, 3, 68, 3, 68, 3, 68, 3, 68, 7, 68,
	1207, 10, 68, 12, 68, 14, 68, 1210, 11, 68, 3, 69, 3, 69, 5, 69, 1214,
	10, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1222, 10, 69,
	3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3,
	70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 1241, 10, 70, 3, 70,
	3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3,
	70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70,
	3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3,
	70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 7, 70,
	1285, 10, 70, 12, 70, 14, 70, 1288, 11, 70, 3, 71, 3, 71, 5, 71, 1292,
	10, 71, 3, 71, 3, 71, 5, 71, 1296, 10, 71, 3, 71, 3, 71, 3, 71, 5, 71,
	1301, 10, 71, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 7, 72, 1308, 10, 72, 12,
	72, 14, 72, 1311, 11, 72, 5, 72, 1313, 10, 72, 3, 72, 3, 72, 3, 73, 3,
	73, 3, 73, 3, 73, 7, 73, 1321, 10, 73, 12, 73, 14, 73, 1324, 11, 73, 3,
	74, 3, 74, 5, 74, 1328, 10, 74, 3, 75, 3, 75, 3, 75, 3, 75, 5, 75, 1334,
	10, 75, 3, 75, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76, 3, 76, 7, 76, 1343, 10,
	76, 12, 76, 14, 76, 1346, 11, 76, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3,
	77, 7, 77, 1354, 10, 77, 12, 77, 14, 77, 1357, 11, 77, 3, 77, 3, 77, 5,
	77, 1361, 10, 77, 3, 78, 3, 78, 3, 78, 5, 78, 1366, 10, 78, 3, 78, 3, 78,
	3, 79, 3, 79, 5, 79, 1372, 10, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 81, 3,
	81, 3, 81, 5, 81, 1381, 10, 81, 3, 81, 3, 81, 3, 82, 3, 82, 3, 82, 3, 82,
	3, 82, 3, 82, 5, 82, 1391, 10, 82, 3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 3,
	83, 3, 83, 5, 83, 1400, 10, 83, 3, 83, 5, 83, 1403, 10, 83, 3, 83, 5, 83,
	1406, 10, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 3, 86, 3, 86, 3, 86, 3, 86, 7, 86, 1424, 10, 86,
	12, 86, 14, 86, 1427, 11, 86, 3, 87, 3, 87, 3, 87, 3, 87, 3, 88, 3, 88,
	3, 88, 3, 88, 7, 88, 1437, 10, 88, 12, 88, 14, 88, 1440, 11, 88, 3, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 7, 89, 1450, 10, 89, 12,
	89, 14, 89, 1453, 11, 89, 3, 90, 3, 90, 3, 90, 3, 90, 7, 90, 1459, 10,
	90, 12, 90, 14, 90, 1462, 11, 90, 3, 91, 3, 91, 3, 91, 3, 92, 3, 92, 3,
	92, 3, 92, 3, 92, 7, 92, 1472, 10, 92, 12, 92, 14, 92, 1475, 11, 92, 3,
	92, 3, 92, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93,
	7, 93, 1488, 10, 93, 12, 93, 14, 93, 1491, 11, 93, 3, 93, 3, 93, 3, 94,
	3, 94, 3, 94, 3, 94, 3, 94, 7, 94, 1500, 10, 94, 12, 94, 14, 94, 1503,
	11, 94, 3, 94, 3, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 96, 3, 96,
	3, 96, 5, 96, 1515, 10, 96, 3, 97, 3, 97, 3, 97, 3, 97, 3, 98, 3, 98, 3,
	98, 3, 99, 3, 99, 3, 99, 3, 100, 3, 100, 3, 100, 5, 100, 1530, 10, 100,
	7, 100, 1532, 10, 100, 12, 100, 14, 100, 1535, 11, 100, 3, 100, 3, 100,
	3, 101, 3, 101, 3, 101, 5, 101, 1542, 10, 101, 3, 101, 3, 101, 7, 101,
	1546, 10, 101, 12, 101, 14, 101, 1549, 11, 101, 3, 102, 3, 102, 3, 102,
	3, 102, 3, 102, 7, 102, 1556, 10, 102, 12, 102, 14, 102, 1559, 11, 102,
	3, 102, 3, 102, 3, 103, 3, 103, 5, 103, 1565, 10, 103, 3, 104, 3, 104,
	3, 104, 3, 104, 3, 104, 7, 104, 1572, 10, 104, 12, 104, 14, 104, 1575,
	11, 104, 3, 104, 3, 104, 3, 105, 3, 105, 5, 105, 1581, 10, 105, 3, 105,
	3, 105, 7, 105, 1585, 10, 105, 12, 105, 14, 105, 1588, 11, 105, 3, 105,
	3, 105, 3, 105, 3, 105, 3, 105, 5, 105, 1595, 10, 105, 3, 105, 3, 105,
	7, 105, 1599, 10, 105, 12, 105, 14, 105, 1602, 11, 105, 3, 105, 7, 105,
	1605, 10, 105, 12, 105, 14, 105, 1608, 11, 105, 3, 105, 3, 105, 5, 105,
	1612, 10, 105, 3, 106, 3, 106, 3, 106, 3, 106, 7, 106, 1618, 10, 106, 12,
	106, 14, 106, 1621, 11, 106, 3, 107, 3, 107, 3, 108, 3, 108, 3, 108, 3,
	108, 3, 108, 7, 108, 1630, 10, 108, 12, 108, 14, 108, 1633, 11, 108, 3,
	108, 3, 108, 3, 109, 3, 109, 3, 109, 3, 109, 3, 110, 3, 110, 3, 110, 3,
	110, 7, 110, 1645, 10, 110, 12, 110, 14, 110, 1648, 11, 110, 3, 110, 3,
	110, 3, 110, 3, 110, 7, 110, 1654, 10, 110, 12, 110, 14, 110, 1657, 11,
	110, 3, 110, 3, 110, 3, 111, 3, 111, 3, 111, 3, 112, 3, 112, 3, 112, 3,
	113, 3, 113, 3, 113, 3, 114, 3, 114, 5, 114, 1672, 10, 114, 3, 114, 3,
	114, 3, 114, 5, 114, 1677, 10, 114, 3, 114, 6, 114, 1680, 10, 114, 13,
	114, 14, 114, 1681, 3, 114, 3, 114, 5, 114, 1686, 10, 114, 3, 114, 3, 114,
	3, 115, 3, 115, 5, 115, 1692, 10, 115, 3, 115, 3, 115, 5, 115, 1696, 10,
	115, 3, 116, 3, 116, 5, 116, 1700, 10, 116, 3, 117, 3, 117, 3, 118, 3,
	118, 3, 119, 3, 119, 6, 119, 1708, 10, 119, 13, 119, 14, 119, 1709, 3,
	120, 3, 120, 3, 120, 3, 121, 3, 121, 3, 121, 3, 121, 3, 121, 3, 121, 3,
	121, 3, 121, 5, 121, 1723, 10, 121, 3, 122, 3, 122, 3, 122, 3, 122, 3,
	123, 3, 123, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3, 124, 3,
	124, 3, 124, 3, 124, 5, 124, 1741, 10, 124, 3, 125, 3, 125, 3, 125, 5,
	125, 1746, 10, 125, 3, 126, 3, 126, 3, 126, 5, 126, 1751, 10, 126, 3, 127,
	3, 127, 3, 127, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 6, 128, 1761, 10,
	128, 13, 128, 14, 128, 1762, 3, 128, 3, 128, 3, 129, 3, 129, 3, 129, 3,
	129, 3, 129, 3, 130, 3, 130, 3, 130, 3, 130, 3, 131, 3, 131, 3, 131, 3,
	131, 3, 132, 3, 132, 3, 132, 3, 132, 3, 132, 3, 133, 3, 133, 3, 133, 3,
	133, 3, 133, 3, 134, 3, 134, 5, 134, 1792, 10, 134, 3, 135, 3, 135, 3,
	135, 3, 135, 7, 135, 1798, 10, 135, 12, 135, 14, 135, 1801, 11, 135, 3,
	135, 3, 135, 3, 135, 3, 136, 3, 136, 3, 137, 5, 137, 1809, 10, 137, 3,
	137, 3, 137, 3, 137, 7, 137, 1814, 10, 137, 12, 137, 14, 137, 1817, 11,
	137, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3,
	138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 5, 138, 1835,
	10, 138, 3, 139, 3, 139, 3, 140, 3, 140, 5, 140, 1841, 10, 140, 3, 141,
	3, 141, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 5, 142, 1850, 10, 142,
	3, 142, 5, 142, 1853, 10, 142, 3, 143, 3, 143, 3, 143, 3, 144, 3, 144,
	3, 144, 3, 145, 3, 145, 3, 145, 3, 146, 3, 146, 3, 146, 3, 147, 3, 147,
	3, 147, 3, 148, 3, 148, 3, 148, 3, 149, 3, 149, 5, 149, 1875, 10, 149,
	3, 150, 3, 150, 5, 150, 1879, 10, 150, 3, 151, 3, 151, 5, 151, 1883, 10,
	151, 3, 152, 3, 152, 5, 152, 1887, 10, 152, 3, 153, 3, 153, 5, 153, 1891,
	10, 153, 3, 154, 3, 154, 5, 154, 1895, 10, 154, 3, 155, 3, 155, 3, 156,
	3, 156, 3, 157, 3, 157, 3, 157, 3, 157, 5, 157, 1905, 10, 157, 3, 158,
	3, 158, 3, 159, 3, 159, 7, 159, 1911, 10, 159, 12, 159, 14, 159, 1914,
	11, 159, 3, 160, 3, 160, 7, 160, 1918, 10, 160, 12, 160, 14, 160, 1921,
	11, 160, 3, 161, 7, 161, 1924, 10, 161, 12, 161, 14, 161, 1927, 11, 161,
	3, 161, 3, 161, 3, 162, 3, 162, 3, 163, 3, 163, 3, 164, 3, 164, 7, 164,
	1937, 10, 164, 12, 164, 14, 164, 1940, 11, 164, 3, 165, 7, 165, 1943, 10,
	165, 12, 165, 14, 165, 1946, 11, 165, 3, 165, 3, 165, 3, 165, 2, 3, 138,
	166, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
	38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
	74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
	108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
	138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166,
	168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196,
	198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226,
	228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256,
	258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286,
	288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316,
	318, 320, 322, 324, 326, 328, 2, 14, 4, 2, 35, 35, 37, 37, 4, 2, 27, 28,
	40, 41, 3, 2, 4, 5, 3, 2, 4, 16, 4, 2, 26, 26, 29, 29, 5, 2, 26, 29, 40,
	41, 61, 62, 4, 2, 20, 24, 39, 39, 3, 2, 55, 56, 3, 2, 57, 59, 3, 2, 17,
	19, 3, 2, 88, 89, 4, 2, 42, 42, 94, 94, 2, 2088, 2, 331, 3, 2, 2, 2, 4,
	338, 3, 2, 2, 2, 6, 357, 3, 2, 2, 2, 8, 370, 3, 2, 2, 2, 10, 394, 3, 2,
	2, 2, 12, 396, 3, 2, 2, 2, 14, 401, 3, 2, 2, 2, 16, 407, 3, 2, 2, 2, 18,
	428, 3, 2, 2, 2, 20, 439, 3, 2, 2, 2, 22, 454, 3, 2, 2, 2, 24, 476, 3,
	2, 2, 2, 26, 487, 3, 2, 2, 2, 28, 515, 3, 2, 2, 2, 30, 536, 3, 2, 2, 2,
	32, 538, 3, 2, 2, 2, 34, 543, 3, 2, 2, 2, 36, 569, 3, 2, 2, 2, 38, 583,
	3, 2, 2, 2, 40, 599, 3, 2, 2, 2, 42, 606, 3, 2, 2, 2, 44, 630, 3, 2, 2,
	2, 46, 633, 3, 2, 2, 2, 48, 661, 3, 2, 2, 2, 50, 682, 3, 2, 2, 2, 52, 706,
	3, 2, 2, 2, 54, 709, 3, 2, 2, 2, 56, 740, 3, 2, 2, 2, 58, 765, 3, 2, 2,
	2, 60, 786, 3, 2, 2, 2, 62, 789, 3, 2, 2, 2, 64, 808, 3, 2, 2, 2, 66, 811,
	3, 2, 2, 2, 68, 830, 3, 2, 2, 2, 70, 855, 3, 2, 2, 2, 72, 862, 3, 2, 2,
	2, 74, 873, 3, 2, 2, 2, 76, 883, 3, 2, 2, 2, 78, 887, 3, 2, 2, 2, 80, 914,
	3, 2, 2, 2, 82, 916, 3, 2, 2, 2, 84, 925, 3, 2, 2, 2, 86, 950, 3, 2, 2,
	2, 88, 971, 3, 2, 2, 2, 90, 973, 3, 2, 2, 2, 92, 983, 3, 2, 2, 2, 94, 994,
	3, 2, 2, 2, 96, 1004, 3, 2, 2, 2, 98, 1017, 3, 2, 2, 2, 100, 1036, 3, 2,
	2, 2, 102, 1048, 3, 2, 2, 2, 104, 1059, 3, 2, 2, 2, 106, 1063, 3, 2, 2,
	2, 108, 1101, 3, 2, 2, 2, 110, 1103, 3, 2, 2, 2, 112, 1116, 3, 2, 2, 2,
	114, 1127, 3, 2, 2, 2, 116, 1137, 3, 2, 2, 2, 118, 1159, 3, 2, 2, 2, 120,
	1161, 3, 2, 2, 2, 122, 1169, 3, 2, 2, 2, 124, 1173, 3, 2, 2, 2, 126, 1181,
	3, 2, 2, 2, 128, 1186, 3, 2, 2, 2, 130, 1189, 3, 2, 2, 2, 132, 1200, 3,
	2, 2, 2, 134, 1202, 3, 2, 2, 2, 136, 1221, 3, 2, 2, 2, 138, 1240, 3, 2,
	2, 2, 140, 1289, 3, 2, 2, 2, 142, 1302, 3, 2, 2, 2, 144, 1316, 3, 2, 2,
	2, 146, 1325, 3, 2, 2, 2, 148, 1329, 3, 2, 2, 2, 150, 1338, 3, 2, 2, 2,
	152, 1347, 3, 2, 2, 2, 154, 1365, 3, 2, 2, 2, 156, 1371, 3, 2, 2, 2, 158,
	1373, 3, 2, 2, 2, 160, 1377, 3, 2, 2, 2, 162, 1384, 3, 2, 2, 2, 164, 1394,
	3, 2, 2, 2, 166, 1409, 3, 2, 2, 2, 168, 1414, 3, 2, 2, 2, 170, 1419, 3,
	2, 2, 2, 172, 1428, 3, 2, 2, 2, 174, 1432, 3, 2, 2, 2, 176, 1441, 3, 2,
	2, 2, 178, 1454, 3, 2, 2, 2, 180, 1463, 3, 2, 2, 2, 182, 1466, 3, 2, 2,
	2, 184, 1478, 3, 2, 2, 2, 186, 1494, 3, 2, 2, 2, 188, 1506, 3, 2, 2, 2,
	190, 1514, 3, 2, 2, 2, 192, 1516, 3, 2, 2, 2, 194, 1520, 3, 2, 2, 2, 196,
	1523, 3, 2, 2, 2, 198, 1533, 3, 2, 2, 2, 200, 1538, 3, 2, 2, 2, 202, 1550,
	3, 2, 2, 2, 204, 1562, 3, 2, 2, 2, 206, 1566, 3, 2, 2, 2, 208, 1611, 3,
	2, 2, 2, 210, 1613, 3, 2, 2, 2, 212, 1622, 3, 2, 2, 2, 214, 1624, 3, 2,
	2, 2, 216, 1636, 3, 2, 2, 2, 218, 1640, 3, 2, 2, 2, 220, 1660, 3, 2, 2,
	2, 222, 1663, 3, 2, 2, 2, 224, 1666, 3, 2, 2, 2, 226, 1669, 3, 2, 2, 2,
	228, 1689, 3, 2, 2, 2, 230, 1699, 3, 2, 2, 2, 232, 1701, 3, 2, 2, 2, 234,
	1703, 3, 2, 2, 2, 236, 1705, 3, 2, 2, 2, 238, 1711, 3, 2, 2, 2, 240, 1722,
	3, 2, 2, 2, 242, 1724, 3, 2, 2, 2, 244, 1728, 3, 2, 2, 2, 246, 1740, 3,
	2, 2, 2, 248, 1745, 3, 2, 2, 2, 250, 1747, 3, 2, 2, 2, 252, 1752, 3, 2,
	2, 2, 254, 1755, 3, 2, 2, 2, 256, 1766, 3, 2, 2, 2, 258, 1771, 3, 2, 2,
	2, 260, 1775, 3, 2, 2, 2, 262, 1779, 3, 2, 2, 2, 264, 1784, 3, 2, 2, 2,
	266, 1789, 3, 2, 2, 2, 268, 1793, 3, 2, 2, 2, 270, 1805, 3, 2, 2, 2, 272,
	1808, 3, 2, 2, 2, 274, 1834, 3, 2, 2, 2, 276, 1836, 3, 2, 2, 2, 278, 1840,
	3, 2, 2, 2, 280, 1842, 3, 2, 2, 2, 282, 1849, 3, 2, 2, 2, 284, 1854, 3,
	2, 2, 2, 286, 1857, 3, 2, 2, 2, 288, 1860, 3, 2, 2, 2, 290, 1863, 3, 2,
	2, 2, 292, 1866, 3, 2, 2, 2, 294, 1869, 3, 2, 2, 2, 296, 1872, 3, 2, 2,
	2, 298, 1876, 3, 2, 2, 2, 300, 1880, 3, 2, 2, 2, 302, 1884, 3, 2, 2, 2,
	304, 1888, 3, 2, 2, 2, 306, 1892, 3, 2, 2, 2, 308, 1896, 3, 2, 2, 2, 310,
	1898, 3, 2, 2, 2, 312, 1904, 3, 2, 2, 2, 314, 1906, 3, 2, 2, 2, 316, 1908,
	3, 2, 2, 2, 318, 1915, 3, 2, 2, 2, 320, 1925, 3, 2, 2, 2, 322, 1930, 3,
	2, 2, 2, 324, 1932, 3, 2, 2, 2, 326, 1934, 3, 2, 2, 2, 328, 1944, 3, 2,
	2, 2, 330, 332, 5, 4, 3, 2, 331, 330, 3, 2, 2, 2, 332, 333, 3, 2, 2, 2,
	333, 331, 3, 2, 2, 2, 333, 334, 3, 2, 2, 2, 334, 3, 3, 2, 2, 2, 335, 337,
	7, 94, 2, 2, 336, 335, 3, 2, 2, 2, 337, 340, 3, 2, 2, 2, 338, 336, 3, 2,
	2, 2, 338, 339, 3, 2, 2, 2, 339, 342, 3, 2, 2, 2, 340, 338, 3, 2, 2, 2,
	341, 343, 5, 146, 74, 2, 342, 341, 3, 2, 2, 2, 342, 343, 3, 2, 2, 2, 343,
	344, 3, 2, 2, 2, 344, 348, 5, 6, 4, 2, 345, 347, 7, 94, 2, 2, 346, 345,
	3, 2, 2, 2, 347, 350, 3, 2, 2, 2, 348, 346, 3, 2, 2, 2, 348, 349, 3, 2,
	2, 2, 349, 354, 3, 2, 2, 2, 350, 348, 3, 2, 2, 2, 351, 353, 5, 10, 6, 2,
	352, 351, 3, 2, 2, 2, 353, 356, 3, 2, 2, 2, 354, 352, 3, 2, 2, 2, 354,
	355, 3, 2, 2, 2, 355, 5, 3, 2, 2, 2, 356, 354, 3, 2, 2, 2, 357, 358, 7,
	86, 2, 2, 358, 363, 5, 318, 160, 2, 359, 362, 5, 8, 5, 2, 360, 362, 7,
	94, 2, 2, 361, 359, 3, 2, 2, 2, 361, 360, 3, 2, 2, 2, 362, 365, 3, 2, 2,
	2, 363, 361, 3, 2, 2, 2, 363, 364, 3, 2, 2, 2, 364, 366, 3, 2, 2, 2, 365,
	363, 3, 2, 2, 2, 366, 367, 5, 320, 161, 2, 367, 368, 5, 314, 158, 2, 368,
	7, 3, 2, 2, 2, 369, 371, 5, 146, 74, 2, 370, 369, 3, 2, 2, 2, 370, 371,
	3, 2, 2, 2, 371, 372, 3, 2, 2, 2, 372, 377, 7, 86, 2, 2, 373, 375, 5, 310,
	156, 2, 374, 376, 5, 306, 154, 2, 375, 374, 3, 2, 2, 2, 375, 376, 3, 2,
	2, 2, 376, 378, 3, 2, 2, 2, 377, 373, 3, 2, 2, 2, 377, 378, 3, 2, 2, 2,
	378, 379, 3, 2, 2, 2, 379, 380, 5, 314, 158, 2, 380, 9, 3, 2, 2, 2, 381,
	395, 5, 20, 11, 2, 382, 395, 5, 22, 12, 2, 383, 395, 5, 26, 14, 2, 384,
	395, 5, 24, 13, 2, 385, 395, 5, 28, 15, 2, 386, 395, 5, 58, 30, 2, 387,
	395, 5, 42, 22, 2, 388, 395, 5, 50, 26, 2, 389, 395, 5, 34, 18, 2, 390,
	395, 5, 16, 9, 2, 391, 395, 5, 12, 7, 2, 392, 395, 5, 14, 8, 2, 393, 395,
	7, 94, 2, 2, 394, 381, 3, 2, 2, 2, 394, 382, 3, 2, 2, 2, 394, 383, 3, 2,
	2, 2, 394, 384, 3, 2, 2, 2, 394, 385, 3, 2, 2, 2, 394, 386, 3, 2, 2, 2,
	394, 387, 3, 2, 2, 2, 394, 388, 3, 2, 2, 2, 394, 389, 3, 2, 2, 2, 394,
	390, 3, 2, 2, 2, 394, 391, 3, 2, 2, 2, 394, 392, 3, 2, 2, 2, 394, 393,
	3, 2, 2, 2, 395, 11, 3, 2, 2, 2, 396, 397, 5, 310, 156, 2, 397, 398, 7,
	34, 2, 2, 398, 399, 5, 248, 125, 2, 399, 400, 5, 314, 158, 2, 400, 13,
	3, 2, 2, 2, 401, 402, 5, 310, 156, 2, 402, 403, 7, 35, 2, 2, 403, 404,
	5, 248, 125, 2, 404, 405, 5, 314, 158, 2, 405, 15, 3, 2, 2, 2, 406, 408,
	5, 146, 74, 2, 407, 406, 3, 2, 2, 2, 407, 408, 3, 2, 2, 2, 408, 409, 3,
	2, 2, 2, 409, 410, 5, 310, 156, 2, 410, 414, 7, 35, 2, 2, 411, 413, 7,
	94, 2, 2, 412, 411, 3, 2, 2, 2, 413, 416, 3, 2, 2, 2, 414, 412, 3, 2, 2,
	2, 414, 415, 3, 2, 2, 2, 415, 417, 3, 2, 2, 2, 416, 414, 3, 2, 2, 2, 417,
	418, 5, 248, 125, 2, 418, 422, 5, 326, 164, 2, 419, 421, 5, 18, 10, 2,
	420, 419, 3, 2, 2, 2, 421, 424, 3, 2, 2, 2, 422, 420, 3, 2, 2, 2, 422,
	423, 3, 2, 2, 2, 423, 425, 3, 2, 2, 2, 424, 422, 3, 2, 2, 2, 425, 426,
	5, 328, 165, 2, 426, 427, 5, 314, 158, 2, 427, 17, 3, 2, 2, 2, 428, 434,
	5, 310, 156, 2, 429, 431, 7, 39, 2, 2, 430, 432, 5, 300, 151, 2, 431, 430,
	3, 2, 2, 2, 431, 432, 3, 2, 2, 2, 432, 433, 3, 2, 2, 2, 433, 435, 5, 244,
	123, 2, 434, 429, 3, 2, 2, 2, 434, 435, 3, 2, 2, 2, 435, 436, 3, 2, 2,
	2, 436, 437, 5, 314, 158, 2, 437, 19, 3, 2, 2, 2, 438, 440, 5, 146, 74,
	2, 439, 438, 3, 2, 2, 2, 439, 440, 3, 2, 2, 2, 440, 441, 3, 2, 2, 2, 441,
	449, 5, 310, 156, 2, 442, 443, 7, 39, 2, 2, 443, 450, 5, 138, 70, 2, 444,
	447, 5, 248, 125, 2, 445, 446, 7, 39, 2, 2, 446, 448, 5, 138, 70, 2, 447,
	445, 3, 2, 2, 2, 447, 448, 3, 2, 2, 2, 448, 450, 3, 2, 2, 2, 449, 442,
	3, 2, 2, 2, 449, 444, 3, 2, 2, 2, 450, 451, 3, 2, 2, 2, 451, 452, 5, 314,
	158, 2, 452, 21, 3, 2, 2, 2, 453, 455, 5, 146, 74, 2, 454, 453, 3, 2, 2,
	2, 454, 455, 3, 2, 2, 2, 455, 456, 3, 2, 2, 2, 456, 457, 5, 310, 156, 2,
	457, 459, 5, 322, 162, 2, 458, 460, 5, 138, 70, 2, 459, 458, 3, 2, 2, 2,
	459, 460, 3, 2, 2, 2, 460, 461, 3, 2, 2, 2, 461, 462, 5, 324, 163, 2, 462,
	471, 5, 248, 125, 2, 463, 465, 5, 318, 160, 2, 464, 466, 5, 38, 20, 2,
	465, 464, 3, 2, 2, 2, 466, 467, 3, 2, 2, 2, 467, 465, 3, 2, 2, 2, 467,
	468, 3, 2, 2, 2, 468, 469, 3, 2, 2, 2, 469, 470, 5, 320, 161, 2, 470, 472,
	3, 2, 2, 2, 471, 463, 3, 2, 2, 2, 471, 472, 3, 2, 2, 2, 472, 473, 3, 2,
	2, 2, 473, 474, 5, 314, 158, 2, 474, 23, 3, 2, 2, 2, 475, 477, 5, 146,
	74, 2, 476, 475, 3, 2, 2, 2, 476, 477, 3, 2, 2, 2, 477, 478, 3, 2, 2, 2,
	478, 480, 5, 310, 156, 2, 479, 481, 5, 248, 125, 2, 480, 479, 3, 2, 2,
	2, 480, 481, 3, 2, 2, 2, 481, 482, 3, 2, 2, 2, 482, 483, 7, 50, 2, 2, 483,
	484, 5, 138, 70, 2, 484, 485, 5, 314, 158, 2, 485, 25, 3, 2, 2, 2, 486,
	488, 5, 146, 74, 2, 487, 486, 3, 2, 2, 2, 487, 488, 3, 2, 2, 2, 488, 489,
	3, 2, 2, 2, 489, 491, 5, 310, 156, 2, 490, 492, 5, 202, 102, 2, 491, 490,
	3, 2, 2, 2, 491, 492, 3, 2, 2, 2, 492, 493, 3, 2, 2, 2, 493, 494, 5, 322,
	162, 2, 494, 495, 5, 72, 37, 2, 495, 499, 9, 2, 2, 2, 496, 498, 7, 94,
	2, 2, 497, 496, 3, 2, 2, 2, 498, 501, 3, 2, 2, 2, 499, 497, 3, 2, 2, 2,
	499, 500, 3, 2, 2, 2, 500, 502, 3, 2, 2, 2, 501, 499, 3, 2, 2, 2, 502,
	503, 5, 74, 38, 2, 503, 504, 5, 324, 163, 2, 504, 508, 5, 318, 160, 2,
	505, 507, 5, 80, 41, 2, 506, 505, 3, 2, 2, 2, 507, 510, 3, 2, 2, 2, 508,
	506, 3, 2, 2, 2, 508, 509, 3, 2, 2, 2, 509, 511, 3, 2, 2, 2, 510, 508,
	3, 2, 2, 2, 511, 512, 5, 320, 161, 2, 512, 513, 5, 314, 158, 2, 513, 27,
	3, 2, 2, 2, 514, 516, 5, 146, 74, 2, 515, 514, 3, 2, 2, 2, 515, 516, 3,
	2, 2, 2, 516, 517, 3, 2, 2, 2, 517, 519, 5, 310, 156, 2, 518, 520, 5, 202,
	102, 2, 519, 518, 3, 2, 2, 2, 519, 520, 3, 2, 2, 2, 520, 521, 3, 2, 2,
	2, 521, 522, 7, 35, 2, 2, 522, 526, 5, 318, 160, 2, 523, 525, 5, 30, 16,
	2, 524, 523, 3, 2, 2, 2, 525, 528, 3, 2, 2, 2, 526, 524, 3, 2, 2, 2, 526,
	527, 3, 2, 2, 2, 527, 529, 3, 2, 2, 2, 528, 526, 3, 2, 2, 2, 529, 530,
	5, 320, 161, 2, 530, 531, 5, 314, 158, 2, 531, 29, 3, 2, 2, 2, 532, 537,
	5, 32, 17, 2, 533, 537, 5, 36, 19, 2, 534, 537, 5, 40, 21, 2, 535, 537,
	7, 94, 2, 2, 536, 532, 3, 2, 2, 2, 536, 533, 3, 2, 2, 2, 536, 534, 3, 2,
	2, 2, 536, 535, 3, 2, 2, 2, 537, 31, 3, 2, 2, 2, 538, 539, 7, 90, 2, 2,
	539, 540, 5, 248, 125, 2, 540, 541, 5, 314, 158, 2, 541, 33, 3, 2, 2, 2,
	542, 544, 5, 146, 74, 2, 543, 542, 3, 2, 2, 2, 543, 544, 3, 2, 2, 2, 544,
	545, 3, 2, 2, 2, 545, 546, 5, 76, 39, 2, 546, 547, 7, 40, 2, 2, 547, 548,
	7, 41, 2, 2, 548, 549, 5, 322, 162, 2, 549, 550, 5, 72, 37, 2, 550, 557,
	5, 324, 163, 2, 551, 553, 5, 322, 162, 2, 552, 554, 5, 144, 73, 2, 553,
	552, 3, 2, 2, 2, 553, 554, 3, 2, 2, 2, 554, 555, 3, 2, 2, 2, 555, 556,
	5, 324, 163, 2, 556, 558, 3, 2, 2, 2, 557, 551, 3, 2, 2, 2, 557, 558, 3,
	2, 2, 2, 558, 559, 3, 2, 2, 2, 559, 563, 5, 318, 160, 2, 560, 562, 5, 80,
	41, 2, 561, 560, 3, 2, 2, 2, 562, 565, 3, 2, 2, 2, 563, 561, 3, 2, 2, 2,
	563, 564, 3, 2, 2, 2, 564, 566, 3, 2, 2, 2, 565, 563, 3, 2, 2, 2, 566,
	567, 5, 320, 161, 2, 567, 35, 3, 2, 2, 2, 568, 570, 5, 146, 74, 2, 569,
	568, 3, 2, 2, 2, 569, 570, 3, 2, 2, 2, 570, 571, 3, 2, 2, 2, 571, 579,
	5, 310, 156, 2, 572, 573, 7, 39, 2, 2, 573, 580, 5, 138, 70, 2, 574, 577,
	5, 248, 125, 2, 575, 576, 7, 39, 2, 2, 576, 578, 5, 138, 70, 2, 577, 575,
	3, 2, 2, 2, 577, 578, 3, 2, 2, 2, 578, 580, 3, 2, 2, 2, 579, 572, 3, 2,
	2, 2, 579, 574, 3, 2, 2, 2, 580, 581, 3, 2, 2, 2, 581, 582, 5, 314, 158,
	2, 582, 37, 3, 2, 2, 2, 583, 588, 5, 310, 156, 2, 584, 585, 5, 322, 162,
	2, 585, 586, 5, 310, 156, 2, 586, 587, 5, 324, 163, 2, 587, 589, 3, 2,
	2, 2, 588, 584, 3, 2, 2, 2, 588, 589, 3, 2, 2, 2, 589, 590, 3, 2, 2, 2,
	590, 592, 5, 318, 160, 2, 591, 593, 5, 80, 41, 2, 592, 591, 3, 2, 2, 2,
	593, 594, 3, 2, 2, 2, 594, 592, 3, 2, 2, 2, 594, 595, 3, 2, 2, 2, 595,
	596, 3, 2, 2, 2, 596, 597, 5, 320, 161, 2, 597, 598, 5, 314, 158, 2, 598,
	39, 3, 2, 2, 2, 599, 600, 5, 310, 156, 2, 600, 601, 5, 326, 164, 2, 601,
	602, 7, 51, 2, 2, 602, 603, 5, 328, 165, 2, 603, 604, 5, 198, 100, 2, 604,
	605, 5, 314, 158, 2, 605, 41, 3, 2, 2, 2, 606, 607, 5, 76, 39, 2, 607,
	609, 7, 35, 2, 2, 608, 610, 5, 248, 125, 2, 609, 608, 3, 2, 2, 2, 609,
	610, 3, 2, 2, 2, 610, 614, 3, 2, 2, 2, 611, 613, 7, 94, 2, 2, 612, 611,
	3, 2, 2, 2, 613, 616, 3, 2, 2, 2, 614, 612, 3, 2, 2, 2, 614, 615, 3, 2,
	2, 2, 615, 617, 3, 2, 2, 2, 616, 614, 3, 2, 2, 2, 617, 621, 5, 318, 160,
	2, 618, 620, 5, 44, 23, 2, 619, 618, 3, 2, 2, 2, 620, 623, 3, 2, 2, 2,
	621, 619, 3, 2, 2, 2, 621, 622, 3, 2, 2, 2, 622, 624, 3, 2, 2, 2, 623,
	621, 3, 2, 2, 2, 624, 625, 5, 320, 161, 2, 625, 626, 5, 314, 158, 2, 626,
	43, 3, 2, 2, 2, 627, 631, 5, 46, 24, 2, 628, 631, 5, 48, 25, 2, 629, 631,
	7, 94, 2, 2, 630, 627, 3, 2, 2, 2, 630, 628, 3, 2, 2, 2, 630, 629, 3, 2,
	2, 2, 631, 45, 3, 2, 2, 2, 632, 634, 5, 146, 74, 2, 633, 632, 3, 2, 2,
	2, 633, 634, 3, 2, 2, 2, 634, 635, 3, 2, 2, 2, 635, 637, 5, 310, 156, 2,
	636, 638, 5, 202, 102, 2, 637, 636, 3, 2, 2, 2, 637, 638, 3, 2, 2, 2, 638,
	639, 3, 2, 2, 2, 639, 640, 5, 322, 162, 2, 640, 641, 5, 72, 37, 2, 641,
	645, 9, 2, 2, 2, 642, 644, 7, 94, 2, 2, 643, 642, 3, 2, 2, 2, 644, 647,
	3, 2, 2, 2, 645, 643, 3, 2, 2, 2, 645, 646, 3, 2, 2, 2, 646, 648, 3, 2,
	2, 2, 647, 645, 3, 2, 2, 2, 648, 649, 5, 74, 38, 2, 649, 650, 5, 324, 163,
	2, 650, 654, 5, 318, 160, 2, 651, 653, 5, 80, 41, 2, 652, 651, 3, 2, 2,
	2, 653, 656, 3, 2, 2, 2, 654, 652, 3, 2, 2, 2, 654, 655, 3, 2, 2, 2, 655,
	657, 3, 2, 2, 2, 656, 654, 3, 2, 2, 2, 657, 658, 5, 320, 161, 2, 658, 659,
	5, 314, 158, 2, 659, 47, 3, 2, 2, 2, 660, 662, 5, 146, 74, 2, 661, 660,
	3, 2, 2, 2, 661, 662, 3, 2, 2, 2, 662, 663, 3, 2, 2, 2, 663, 664, 5, 310,
	156, 2, 664, 666, 5, 322, 162, 2, 665, 667, 5, 138, 70, 2, 666, 665, 3,
	2, 2, 2, 666, 667, 3, 2, 2, 2, 667, 668, 3, 2, 2, 2, 668, 669, 5, 324,
	163, 2, 669, 678, 5, 248, 125, 2, 670, 672, 5, 318, 160, 2, 671, 673, 5,
	38, 20, 2, 672, 671, 3, 2, 2, 2, 673, 674, 3, 2, 2, 2, 674, 672, 3, 2,
	2, 2, 674, 675, 3, 2, 2, 2, 675, 676, 3, 2, 2, 2, 676, 677, 5, 320, 161,
	2, 677, 679, 3, 2, 2, 2, 678, 670, 3, 2, 2, 2, 678, 679, 3, 2, 2, 2, 679,
	680, 3, 2, 2, 2, 680, 681, 5, 314, 158, 2, 681, 49, 3, 2, 2, 2, 682, 683,
	5, 322, 162, 2, 683, 684, 5, 310, 156, 2, 684, 685, 5, 324, 163, 2, 685,
	686, 5, 76, 39, 2, 686, 690, 7, 35, 2, 2, 687, 689, 7, 94, 2, 2, 688, 687,
	3, 2, 2, 2, 689, 692, 3, 2, 2, 2, 690, 688, 3, 2, 2, 2, 690, 691, 3, 2,
	2, 2, 691, 693, 3, 2, 2, 2, 692, 690, 3, 2, 2, 2, 693, 697, 5, 318, 160,
	2, 694, 696, 5, 52, 27, 2, 695, 694, 3, 2, 2, 2, 696, 699, 3, 2, 2, 2,
	697, 695, 3, 2, 2, 2, 697, 698, 3, 2, 2, 2, 698, 700, 3, 2, 2, 2, 699,
	697, 3, 2, 2, 2, 700, 701, 5, 320, 161, 2, 701, 702, 5, 314, 158, 2, 702,
	51, 3, 2, 2, 2, 703, 707, 5, 54, 28, 2, 704, 707, 5, 56, 29, 2, 705, 707,
	7, 94, 2, 2, 706, 703, 3, 2, 2, 2, 706, 704, 3, 2, 2, 2, 706, 705, 3, 2,
	2, 2, 707, 53, 3, 2, 2, 2, 708, 710, 5, 146, 74, 2, 709, 708, 3, 2, 2,
	2, 709, 710, 3, 2, 2, 2, 710, 712, 3, 2, 2, 2, 711, 713, 7, 90, 2, 2, 712,
	711, 3, 2, 2, 2, 712, 713, 3, 2, 2, 2, 713, 714, 3, 2, 2, 2, 714, 716,
	5, 310, 156, 2, 715, 717, 5, 202, 102, 2, 716, 715, 3, 2, 2, 2, 716, 717,
	3, 2, 2, 2, 717, 718, 3, 2, 2, 2, 718, 719, 5, 322, 162, 2, 719, 720, 5,
	72, 37, 2, 720, 724, 9, 2, 2, 2, 721, 723, 7, 94, 2, 2, 722, 721, 3, 2,
	2, 2, 723, 726, 3, 2, 2, 2, 724, 722, 3, 2, 2, 2, 724, 725, 3, 2, 2, 2,
	725, 727, 3, 2, 2, 2, 726, 724, 3, 2, 2, 2, 727, 728, 5, 74, 38, 2, 728,
	729, 5, 324, 163, 2, 729, 733, 5, 318, 160, 2, 730, 732, 5, 80, 41, 2,
	731, 730, 3, 2, 2, 2, 732, 735, 3, 2, 2, 2, 733, 731, 3, 2, 2, 2, 733,
	734, 3, 2, 2, 2, 734, 736, 3, 2, 2, 2, 735, 733, 3, 2, 2, 2, 736, 737,
	5, 320, 161, 2, 737, 738, 5, 314, 158, 2, 738, 55, 3, 2, 2, 2, 739, 741,
	5, 146, 74, 2, 740, 739, 3, 2, 2, 2, 740, 741, 3, 2, 2, 2, 741, 743, 3,
	2, 2, 2, 742, 744, 7, 90, 2, 2, 743, 742, 3, 2, 2, 2, 743, 744, 3, 2, 2,
	2, 744, 745, 3, 2, 2, 2, 745, 746, 5, 310, 156, 2, 746, 748, 5, 322, 162,
	2, 747, 749, 5, 138, 70, 2, 748, 747, 3, 2, 2, 2, 748, 749, 3, 2, 2, 2,
	749, 750, 3, 2, 2, 2, 750, 751, 5, 324, 163, 2, 751, 760, 5, 248, 125,
	2, 752, 754, 5, 318, 160, 2, 753, 755, 5, 38, 20, 2, 754, 753, 3, 2, 2,
	2, 755, 756, 3, 2, 2, 2, 756, 754, 3, 2, 2, 2, 756, 757, 3, 2, 2, 2, 757,
	758, 3, 2, 2, 2, 758, 759, 5, 320, 161, 2, 759, 761, 3, 2, 2, 2, 760, 752,
	3, 2, 2, 2, 760, 761, 3, 2, 2, 2, 761, 762, 3, 2, 2, 2, 762, 763, 5, 314,
	158, 2, 763, 57, 3, 2, 2, 2, 764, 766, 5, 146, 74, 2, 765, 764, 3, 2, 2,
	2, 765, 766, 3, 2, 2, 2, 766, 767, 3, 2, 2, 2, 767, 769, 5, 310, 156, 2,
	768, 770, 5, 202, 102, 2, 769, 768, 3, 2, 2, 2, 769, 770, 3, 2, 2, 2, 770,
	771, 3, 2, 2, 2, 771, 772, 7, 36, 2, 2, 772, 776, 5, 318, 160, 2, 773,
	775, 5, 60, 31, 2, 774, 773, 3, 2, 2, 2, 775, 778, 3, 2, 2, 2, 776, 774,
	3, 2, 2, 2, 776, 777, 3, 2, 2, 2, 777, 779, 3, 2, 2, 2, 778, 776, 3, 2,
	2, 2, 779, 780, 5, 320, 161, 2, 780, 781, 5, 314, 158, 2, 781, 59, 3, 2,
	2, 2, 782, 787, 5, 32, 17, 2, 783, 787, 5, 66, 34, 2, 784, 787, 5, 62,
	32, 2, 785, 787, 7, 94, 2, 2, 786, 782, 3, 2, 2, 2, 786, 783, 3, 2, 2,
	2, 786, 784, 3, 2, 2, 2, 786, 785, 3, 2, 2, 2, 787, 61, 3, 2, 2, 2, 788,
	790, 5, 146, 74, 2, 789, 788, 3, 2, 2, 2, 789, 790, 3, 2, 2, 2, 790, 791,
	3, 2, 2, 2, 791, 792, 5, 310, 156, 2, 792, 793, 5, 322, 162, 2, 793, 794,
	5, 324, 163, 2, 794, 804, 5, 248, 125, 2, 795, 799, 5, 318, 160, 2, 796,
	798, 5, 64, 33, 2, 797, 796, 3, 2, 2, 2, 798, 801, 3, 2, 2, 2, 799, 797,
	3, 2, 2, 2, 799, 800, 3, 2, 2, 2, 800, 802, 3, 2, 2, 2, 801, 799, 3, 2,
	2, 2, 802, 803, 5, 320, 161, 2, 803, 805, 3, 2, 2, 2, 804, 795, 3, 2, 2,
	2, 804, 805, 3, 2, 2, 2, 805, 806, 3, 2, 2, 2, 806, 807, 5, 314, 158, 2,
	807, 63, 3, 2, 2, 2, 808, 809, 5, 310, 156, 2, 809, 65, 3, 2, 2, 2, 810,
	812, 5, 146, 74, 2, 811, 810, 3, 2, 2, 2, 811, 812, 3, 2, 2, 2, 812, 813,
	3, 2, 2, 2, 813, 815, 5, 310, 156, 2, 814, 816, 5, 202, 102, 2, 815, 814,
	3, 2, 2, 2, 815, 816, 3, 2, 2, 2, 816, 817, 3, 2, 2, 2, 817, 818, 5, 322,
	162, 2, 818, 819, 5, 72, 37, 2, 819, 823, 9, 2, 2, 2, 820, 822, 7, 94,
	2, 2, 821, 820, 3, 2, 2, 2, 822, 825, 3, 2, 2, 2, 823, 821, 3, 2, 2, 2,
	823, 824, 3, 2, 2, 2, 824, 826, 3, 2, 2, 2, 825, 823, 3, 2, 2, 2, 826,
	827, 5, 74, 38, 2, 827, 828, 5, 324, 163, 2, 828, 829, 5, 314, 158, 2,
	829, 67, 3, 2, 2, 2, 830, 832, 5, 310, 156, 2, 831, 833, 5, 202, 102, 2,
	832, 831, 3, 2, 2, 2, 832, 833, 3, 2, 2, 2, 833, 834, 3, 2, 2, 2, 834,
	835, 5, 322, 162, 2, 835, 836, 5, 72, 37, 2, 836, 840, 9, 2, 2, 2, 837,
	839, 7, 94, 2, 2, 838, 837, 3, 2, 2, 2, 839, 842, 3, 2, 2, 2, 840, 838,
	3, 2, 2, 2, 840, 841, 3, 2, 2, 2, 841, 843, 3, 2, 2, 2, 842, 840, 3, 2,
	2, 2, 843, 844, 5, 74, 38, 2, 844, 845, 5, 324, 163, 2, 845, 849, 5, 318,
	160, 2, 846, 848, 5, 80, 41, 2, 847, 846, 3, 2, 2, 2, 848, 851, 3, 2, 2,
	2, 849, 847, 3, 2, 2, 2, 849, 850, 3, 2, 2, 2, 850, 852, 3, 2, 2, 2, 851,
	849, 3, 2, 2, 2, 852, 853, 5, 320, 161, 2, 853, 854, 5, 314, 158, 2, 854,
	69, 3, 2, 2, 2, 855, 857, 7, 36, 2, 2, 856, 858, 5, 134, 68, 2, 857, 856,
	3, 2, 2, 2, 857, 858, 3, 2, 2, 2, 858, 859, 3, 2, 2, 2, 859, 860, 5, 314,
	158, 2, 860, 71, 3, 2, 2, 2, 861, 863, 5, 78, 40, 2, 862, 861, 3, 2, 2,
	2, 862, 863, 3, 2, 2, 2, 863, 869, 3, 2, 2, 2, 864, 865, 5, 316, 159, 2,
	865, 866, 5, 78, 40, 2, 866, 868, 3, 2, 2, 2, 867, 864, 3, 2, 2, 2, 868,
	871, 3, 2, 2, 2, 869, 867, 3, 2, 2, 2, 869, 870, 3, 2, 2, 2, 870, 73, 3,
	2, 2, 2, 871, 869, 3, 2, 2, 2, 872, 874, 5, 78, 40, 2, 873, 872, 3, 2,
	2, 2, 873, 874, 3, 2, 2, 2, 874, 880, 3, 2, 2, 2, 875, 876, 5, 316, 159,
	2, 876, 877, 5, 78, 40, 2, 877, 879, 3, 2, 2, 2, 878, 875, 3, 2, 2, 2,
	879, 882, 3, 2, 2, 2, 880, 878, 3, 2, 2, 2, 880, 881, 3, 2, 2, 2, 881,
	75, 3, 2, 2, 2, 882, 880, 3, 2, 2, 2, 883, 884, 5, 310, 156, 2, 884, 885,
	5, 248, 125, 2, 885, 77, 3, 2, 2, 2, 886, 888, 5, 146, 74, 2, 887, 886,
	3, 2, 2, 2, 887, 888, 3, 2, 2, 2, 888, 889, 3, 2, 2, 2, 889, 890, 5, 310,
	156, 2, 890, 893, 5, 248, 125, 2, 891, 892, 7, 39, 2, 2, 892, 894, 5, 138,
	70, 2, 893, 891, 3, 2, 2, 2, 893, 894, 3, 2, 2, 2, 894, 79, 3, 2, 2, 2,
	895, 915, 5, 70, 36, 2, 896, 915, 5, 82, 42, 2, 897, 915, 5, 88, 45, 2,
	898, 915, 5, 96, 49, 2, 899, 915, 5, 98, 50, 2, 900, 915, 5, 100, 51, 2,
	901, 915, 5, 102, 52, 2, 902, 915, 5, 104, 53, 2, 903, 915, 5, 106, 54,
	2, 904, 915, 5, 110, 56, 2, 905, 915, 5, 108, 55, 2, 906, 915, 5, 116,
	59, 2, 907, 915, 5, 68, 35, 2, 908, 915, 5, 120, 61, 2, 909, 915, 5, 122,
	62, 2, 910, 915, 5, 124, 63, 2, 911, 915, 5, 126, 64, 2, 912, 915, 5, 128,
	65, 2, 913, 915, 7, 94, 2, 2, 914, 895, 3, 2, 2, 2, 914, 896, 3, 2, 2,
	2, 914, 897, 3, 2, 2, 2, 914, 898, 3, 2, 2, 2, 914, 899, 3, 2, 2, 2, 914,
	900, 3, 2, 2, 2, 914, 901, 3, 2, 2, 2, 914, 902, 3, 2, 2, 2, 914, 903,
	3, 2, 2, 2, 914, 904, 3, 2, 2, 2, 914, 905, 3, 2, 2, 2, 914, 906, 3, 2,
	2, 2, 914, 907, 3, 2, 2, 2, 914, 908, 3, 2, 2, 2, 914, 909, 3, 2, 2, 2,
	914, 910, 3, 2, 2, 2, 914, 911, 3, 2, 2, 2, 914, 912, 3, 2, 2, 2, 914,
	913, 3, 2, 2, 2, 915, 81, 3, 2, 2, 2, 916, 917, 5, 138, 70, 2, 917, 919,
	7, 51, 2, 2, 918, 920, 5, 84, 43, 2, 919, 918, 3, 2, 2, 2, 920, 921, 3,
	2, 2, 2, 921, 919, 3, 2, 2, 2, 921, 922, 3, 2, 2, 2, 922, 923, 3, 2, 2,
	2, 923, 924, 5, 314, 158, 2, 924, 83, 3, 2, 2, 2, 925, 931, 5, 86, 44,
	2, 926, 927, 5, 316, 159, 2, 927, 928, 5, 86, 44, 2, 928, 930, 3, 2, 2,
	2, 929, 926, 3, 2, 2, 2, 930, 933, 3, 2, 2, 2, 931, 929, 3, 2, 2, 2, 931,
	932, 3, 2, 2, 2, 932, 934, 3, 2, 2, 2, 933, 931, 3, 2, 2, 2, 934, 938,
	5, 318, 160, 2, 935, 937, 5, 80, 41, 2, 936, 935, 3, 2, 2, 2, 937, 940,
	3, 2, 2, 2, 938, 936, 3, 2, 2, 2, 938, 939, 3, 2, 2, 2, 939, 941, 3, 2,
	2, 2, 940, 938, 3, 2, 2, 2, 941, 942, 5, 320, 161, 2, 942, 85, 3, 2, 2,
	2, 943, 951, 7, 90, 2, 2, 944, 951, 5, 138, 70, 2, 945, 948, 5, 310, 156,
	2, 946, 948, 7, 90, 2, 2, 947, 945, 3, 2, 2, 2, 947, 946, 3, 2, 2, 2, 948,
	949, 3, 2, 2, 2, 949, 951, 5, 248, 125, 2, 950, 943, 3, 2, 2, 2, 950, 944,
	3, 2, 2, 2, 950, 947, 3, 2, 2, 2, 951, 87, 3, 2, 2, 2, 952, 956, 5, 92,
	47, 2, 953, 955, 5, 94, 48, 2, 954, 953, 3, 2, 2, 2, 955, 958, 3, 2, 2,
	2, 956, 954, 3, 2, 2, 2, 956, 957, 3, 2, 2, 2, 957, 959, 3, 2, 2, 2, 958,
	956, 3, 2, 2, 2, 959, 960, 5, 90, 46, 2, 960, 961, 5, 314, 158, 2, 961,
	972, 3, 2, 2, 2, 962, 966, 5, 92, 47, 2, 963, 965, 5, 94, 48, 2, 964, 963,
	3, 2, 2, 2, 965, 968, 3, 2, 2, 2, 966, 964, 3, 2, 2, 2, 966, 967, 3, 2,
	2, 2, 967, 969, 3, 2, 2, 2, 968, 966, 3, 2, 2, 2, 969, 970, 5, 314, 158,
	2, 970, 972, 3, 2, 2, 2, 971, 952, 3, 2, 2, 2, 971, 962, 3, 2, 2, 2, 972,
	89, 3, 2, 2, 2, 973, 974, 7, 90, 2, 2, 974, 978, 5, 318, 160, 2, 975, 977,
	5, 80, 41, 2, 976, 975, 3, 2, 2, 2, 977, 980, 3, 2, 2, 2, 978, 976, 3,
	2, 2, 2, 978, 979, 3, 2, 2, 2, 979, 981, 3, 2, 2, 2, 980, 978, 3, 2, 2,
	2, 981, 982, 5, 320, 161, 2, 982, 91, 3, 2, 2, 2, 983, 984, 7, 51, 2, 2,
	984, 985, 5, 138, 70, 2, 985, 989, 5, 318, 160, 2, 986, 988, 5, 80, 41,
	2, 987, 986, 3, 2, 2, 2, 988, 991, 3, 2, 2, 2, 989, 987, 3, 2, 2, 2, 989,
	990, 3, 2, 2, 2, 990, 992, 3, 2, 2, 2, 991, 989, 3, 2, 2, 2, 992, 993,
	5, 320, 161, 2, 993, 93, 3, 2, 2, 2, 994, 995, 5, 138, 70, 2, 995, 999,
	5, 318, 160, 2, 996, 998, 5, 80, 41, 2, 997, 996, 3, 2, 2, 2, 998, 1001,
	3, 2, 2, 2, 999, 997, 3, 2, 2, 2, 999, 1000, 3, 2, 2, 2, 1000, 1002, 3,
	2, 2, 2, 1001, 999, 3, 2, 2, 2, 1002, 1003, 5, 320, 161, 2, 1003, 95, 3,
	2, 2, 2, 1004, 1005, 5, 118, 60, 2, 1005, 1006, 7, 52, 2, 2, 1006, 1007,
	5, 310, 156, 2, 1007, 1011, 5, 318, 160, 2, 1008, 1010, 5, 80, 41, 2, 1009,
	1008, 3, 2, 2, 2, 1010, 1013, 3, 2, 2, 2, 1011, 1009, 3, 2, 2, 2, 1011,
	1012, 3, 2, 2, 2, 1012, 1014, 3, 2, 2, 2, 1013, 1011, 3, 2, 2, 2, 1014,
	1015, 5, 320, 161, 2, 1015, 1016, 5, 314, 158, 2, 1016, 97, 3, 2, 2, 2,
	1017, 1018, 5, 138, 70, 2, 1018, 1023, 7, 52, 2, 2, 1019, 1020, 7, 47,
	2, 2, 1020, 1021, 5, 310, 156, 2, 1021, 1022, 7, 48, 2, 2, 1022, 1024,
	3, 2, 2, 2, 1023, 1019, 3, 2, 2, 2, 1023, 1024, 3, 2, 2, 2, 1024, 1025,
	3, 2, 2, 2, 1025, 1026, 5, 310, 156, 2, 1026, 1030, 5, 318, 160, 2, 1027,
	1029, 5, 80, 41, 2, 1028, 1027, 3, 2, 2, 2, 1029, 1032, 3, 2, 2, 2, 1030,
	1028, 3, 2, 2, 2, 1030, 1031, 3, 2, 2, 2, 1031, 1033, 3, 2, 2, 2, 1032,
	1030, 3, 2, 2, 2, 1033, 1034, 5, 320, 161, 2, 1034, 1035, 5, 314, 158,
	2, 1035, 99, 3, 2, 2, 2, 1036, 1037, 7, 52, 2, 2, 1037, 1038, 5, 138, 70,
	2, 1038, 1042, 5, 318, 160, 2, 1039, 1041, 5, 80, 41, 2, 1040, 1039, 3,
	2, 2, 2, 1041, 1044, 3, 2, 2, 2, 1042, 1040, 3, 2, 2, 2, 1042, 1043, 3,
	2, 2, 2, 1043, 1045, 3, 2, 2, 2, 1044, 1042, 3, 2, 2, 2, 1045, 1046, 5,
	320, 161, 2, 1046, 1047, 5, 314, 158, 2, 1047, 101, 3, 2, 2, 2, 1048, 1049,
	7, 52, 2, 2, 1049, 1053, 5, 318, 160, 2, 1050, 1052, 5, 80, 41, 2, 1051,
	1050, 3, 2, 2, 2, 1052, 1055, 3, 2, 2, 2, 1053, 1051, 3, 2, 2, 2, 1053,
	1054, 3, 2, 2, 2, 1054, 1056, 3, 2, 2, 2, 1055, 1053, 3, 2, 2, 2, 1056,
	1057, 5, 320, 161, 2, 1057, 1058, 5, 314, 158, 2, 1058, 103, 3, 2, 2, 2,
	1059, 1060, 7, 36, 2, 2, 1060, 1061, 7, 52, 2, 2, 1061, 1062, 5, 314, 158,
	2, 1062, 105, 3, 2, 2, 2, 1063, 1064, 7, 35, 2, 2, 1064, 1065, 7, 52, 2,
	2, 1065, 1066, 5, 314, 158, 2, 1066, 107, 3, 2, 2, 2, 1067, 1068, 7, 53,
	2, 2, 1068, 1072, 5, 318, 160, 2, 1069, 1071, 5, 80, 41, 2, 1070, 1069,
	3, 2, 2, 2, 1071, 1074, 3, 2, 2, 2, 1072, 1070, 3, 2, 2, 2, 1072, 1073,
	3, 2, 2, 2, 1073, 1075, 3, 2, 2, 2, 1074, 1072, 3, 2, 2, 2, 1075, 1079,
	5, 320, 161, 2, 1076, 1078, 5, 112, 57, 2, 1077, 1076, 3, 2, 2, 2, 1078,
	1081, 3, 2, 2, 2, 1079, 1077, 3, 2, 2, 2, 1079, 1080, 3, 2, 2, 2, 1080,
	1082, 3, 2, 2, 2, 1081, 1079, 3, 2, 2, 2, 1082, 1083, 5, 114, 58, 2, 1083,
	1084, 5, 314, 158, 2, 1084, 1102, 3, 2, 2, 2, 1085, 1086, 7, 53, 2, 2,
	1086, 1090, 5, 318, 160, 2, 1087, 1089, 5, 80, 41, 2, 1088, 1087, 3, 2,
	2, 2, 1089, 1092, 3, 2, 2, 2, 1090, 1088, 3, 2, 2, 2, 1090, 1091, 3, 2,
	2, 2, 1091, 1093, 3, 2, 2, 2, 1092, 1090, 3, 2, 2, 2, 1093, 1095, 5, 320,
	161, 2, 1094, 1096, 5, 112, 57, 2, 1095, 1094, 3, 2, 2, 2, 1096, 1097,
	3, 2, 2, 2, 1097, 1095, 3, 2, 2, 2, 1097, 1098, 3, 2, 2, 2, 1098, 1099,
	3, 2, 2, 2, 1099, 1100, 5, 314, 158, 2, 1100, 1102, 3, 2, 2, 2, 1101, 1067,
	3, 2, 2, 2, 1101, 1085, 3, 2, 2, 2, 1102, 109, 3, 2, 2, 2, 1103, 1104,
	7, 53, 2, 2, 1104, 1106, 5, 138, 70, 2, 1105, 1107, 5, 248, 125, 2, 1106,
	1105, 3, 2, 2, 2, 1106, 1107, 3, 2, 2, 2, 1107, 1108, 3, 2, 2, 2, 1108,
	1109, 7, 39, 2, 2, 1109, 1110, 5, 138, 70, 2, 1110, 1111, 5, 314, 158,
	2, 1111, 111, 3, 2, 2, 2, 1112, 1117, 5, 310, 156, 2, 1113, 1114, 5, 310,
	156, 2, 1114, 1115, 5, 248, 125, 2, 1115, 1117, 3, 2, 2, 2, 1116, 1112,
	3, 2, 2, 2, 1116, 1113, 3, 2, 2, 2, 1117, 1118, 3, 2, 2, 2, 1118, 1122,
	5, 318, 160, 2, 1119, 1121, 5, 80, 41, 2, 1120, 1119, 3, 2, 2, 2, 1121,
	1124, 3, 2, 2, 2, 1122, 1120, 3, 2, 2, 2, 1122, 1123, 3, 2, 2, 2, 1123,
	1125, 3, 2, 2, 2, 1124, 1122, 3, 2, 2, 2, 1125, 1126, 5, 320, 161, 2, 1126,
	113, 3, 2, 2, 2, 1127, 1128, 7, 90, 2, 2, 1128, 1132, 5, 318, 160, 2, 1129,
	1131, 5, 80, 41, 2, 1130, 1129, 3, 2, 2, 2, 1131, 1134, 3, 2, 2, 2, 1132,
	1130, 3, 2, 2, 2, 1132, 1133, 3, 2, 2, 2, 1133, 1135, 3, 2, 2, 2, 1134,
	1132, 3, 2, 2, 2, 1135, 1136, 5, 320, 161, 2, 1136, 115, 3, 2, 2, 2, 1137,
	1138, 7, 53, 2, 2, 1138, 1140, 5, 322, 162, 2, 1139, 1141, 5, 138, 70,
	2, 1140, 1139, 3, 2, 2, 2, 1140, 1141, 3, 2, 2, 2, 1141, 1142, 3, 2, 2,
	2, 1142, 1143, 5, 324, 163, 2, 1143, 1144, 5, 314, 158, 2, 1144, 117, 3,
	2, 2, 2, 1145, 1146, 7, 47, 2, 2, 1146, 1147, 5, 138, 70, 2, 1147, 1148,
	9, 3, 2, 2, 1148, 1149, 5, 138, 70, 2, 1149, 1150, 5, 316, 159, 2, 1150,
	1151, 5, 138, 70, 2, 1151, 1152, 7, 48, 2, 2, 1152, 1160, 3, 2, 2, 2, 1153,
	1154, 7, 47, 2, 2, 1154, 1155, 5, 138, 70, 2, 1155, 1156, 9, 3, 2, 2, 1156,
	1157, 5, 138, 70, 2, 1157, 1158, 7, 48, 2, 2, 1158, 1160, 3, 2, 2, 2, 1159,
	1145, 3, 2, 2, 2, 1159, 1153, 3, 2, 2, 2, 1160, 119, 3, 2, 2, 2, 1161,
	1163, 5, 130, 66, 2, 1162, 1164, 5, 248, 125, 2, 1163, 1162, 3, 2, 2, 2,
	1163, 1164, 3, 2, 2, 2, 1164, 1165, 3, 2, 2, 2, 1165, 1166, 7, 39, 2, 2,
	1166, 1167, 5, 138, 70, 2, 1167, 1168, 5, 314, 158, 2, 1168, 121, 3, 2,
	2, 2, 1169, 1170, 5, 130, 66, 2, 1170, 1171, 5, 248, 125, 2, 1171, 1172,
	5, 314, 158, 2, 1172, 123, 3, 2, 2, 2, 1173, 1174, 5, 138, 70, 2, 1174,
	1175, 7, 47, 2, 2, 1175, 1176, 7, 36, 2, 2, 1176, 1177, 7, 48, 2, 2, 1177,
	1178, 5, 298, 150, 2, 1178, 1179, 5, 138, 70, 2, 1179, 1180, 5, 314, 158,
	2, 1180, 125, 3, 2, 2, 2, 1181, 1182, 5, 134, 68, 2, 1182, 1183, 5, 298,
	150, 2, 1183, 1184, 5, 134, 68, 2, 1184, 1185, 5, 314, 158, 2, 1185, 127,
	3, 2, 2, 2, 1186, 1187, 5, 138, 70, 2, 1187, 1188, 5, 314, 158, 2, 1188,
	129, 3, 2, 2, 2, 1189, 1195, 5, 132, 67, 2, 1190, 1191, 5, 316, 159, 2,
	1191, 1192, 5, 132, 67, 2, 1192, 1194, 3, 2, 2, 2, 1193, 1190, 3, 2, 2,
	2, 1194, 1197, 3, 2, 2, 2, 1195, 1193, 3, 2, 2, 2, 1195, 1196, 3, 2, 2,
	2, 1196, 131, 3, 2, 2, 2, 1197, 1195, 3, 2, 2, 2, 1198, 1201, 5, 310, 156,
	2, 1199, 1201, 7, 90, 2, 2, 1200, 1198, 3, 2, 2, 2, 1200, 1199, 3, 2, 2,
	2, 1201, 133, 3, 2, 2, 2, 1202, 1208, 5, 138, 70, 2, 1203, 1204, 5, 316,
	159, 2, 1204, 1205, 5, 138, 70, 2, 1205, 1207, 3, 2, 2, 2, 1206, 1203,
	3, 2, 2, 2, 1207, 1210, 3, 2, 2, 2, 1208, 1206, 3, 2, 2, 2, 1208, 1209,
	3, 2, 2, 2, 1209, 135, 3, 2, 2, 2, 1210, 1208, 3, 2, 2, 2, 1211, 1213,
	5, 310, 156, 2, 1212, 1214, 5, 206, 104, 2, 1213, 1212, 3, 2, 2, 2, 1213,
	1214, 3, 2, 2, 2, 1214, 1222, 3, 2, 2, 2, 1215, 1222, 7, 90, 2, 2, 1216,
	1217, 5, 322, 162, 2, 1217, 1218, 5, 138, 70, 2, 1218, 1219, 5, 324, 163,
	2, 1219, 1222, 3, 2, 2, 2, 1220, 1222, 5, 240, 121, 2, 1221, 1211, 3, 2,
	2, 2, 1221, 1215, 3, 2, 2, 2, 1221, 1216, 3, 2, 2, 2, 1221, 1220, 3, 2,
	2, 2, 1222, 137, 3, 2, 2, 2, 1223, 1224, 8, 70, 1, 2, 1224, 1241, 5, 226,
	114, 2, 1225, 1241, 5, 136, 69, 2, 1226, 1241, 5, 164, 83, 2, 1227, 1241,
	5, 162, 82, 2, 1228, 1241, 5, 166, 84, 2, 1229, 1241, 5, 180, 91, 2, 1230,
	1241, 5, 182, 92, 2, 1231, 1241, 5, 184, 93, 2, 1232, 1241, 5, 186, 94,
	2, 1233, 1241, 5, 208, 105, 2, 1234, 1241, 5, 218, 110, 2, 1235, 1241,
	5, 212, 107, 2, 1236, 1241, 5, 220, 111, 2, 1237, 1241, 5, 224, 113, 2,
	1238, 1241, 5, 222, 112, 2, 1239, 1241, 5, 236, 119, 2, 1240, 1223, 3,
	2, 2, 2, 1240, 1225, 3, 2, 2, 2, 1240, 1226, 3, 2, 2, 2, 1240, 1227, 3,
	2, 2, 2, 1240, 1228, 3, 2, 2, 2, 1240, 1229, 3, 2, 2, 2, 1240, 1230, 3,
	2, 2, 2, 1240, 1231, 3, 2, 2, 2, 1240, 1232, 3, 2, 2, 2, 1240, 1233, 3,
	2, 2, 2, 1240, 1234, 3, 2, 2, 2, 1240, 1235, 3, 2, 2, 2, 1240, 1236, 3,
	2, 2, 2, 1240, 1237, 3, 2, 2, 2, 1240, 1238, 3, 2, 2, 2, 1240, 1239, 3,
	2, 2, 2, 1241, 1286, 3, 2, 2, 2, 1242, 1243, 12, 8, 2, 2, 1243, 1244, 5,
	282, 142, 2, 1244, 1245, 5, 138, 70, 9, 1245, 1285, 3, 2, 2, 2, 1246, 1247,
	12, 7, 2, 2, 1247, 1248, 5, 296, 149, 2, 1248, 1249, 5, 138, 70, 8, 1249,
	1285, 3, 2, 2, 2, 1250, 1251, 12, 6, 2, 2, 1251, 1252, 5, 300, 151, 2,
	1252, 1253, 5, 138, 70, 7, 1253, 1285, 3, 2, 2, 2, 1254, 1255, 12, 5, 2,
	2, 1255, 1256, 5, 302, 152, 2, 1256, 1257, 5, 138, 70, 6, 1257, 1285, 3,
	2, 2, 2, 1258, 1259, 12, 4, 2, 2, 1259, 1260, 5, 304, 153, 2, 1260, 1261,
	5, 138, 70, 5, 1261, 1285, 3, 2, 2, 2, 1262, 1263, 12, 17, 2, 2, 1263,
	1285, 7, 53, 2, 2, 1264, 1265, 12, 16, 2, 2, 1265, 1285, 7, 51, 2, 2, 1266,
	1267, 12, 15, 2, 2, 1267, 1285, 7, 38, 2, 2, 1268, 1269, 12, 14, 2, 2,
	1269, 1285, 5, 168, 85, 2, 1270, 1271, 12, 13, 2, 2, 1271, 1285, 5, 156,
	79, 2, 1272, 1273, 12, 12, 2, 2, 1273, 1285, 5, 158, 80, 2, 1274, 1275,
	12, 11, 2, 2, 1275, 1285, 5, 160, 81, 2, 1276, 1277, 12, 10, 2, 2, 1277,
	1285, 5, 140, 71, 2, 1278, 1279, 12, 9, 2, 2, 1279, 1280, 5, 280, 141,
	2, 1280, 1281, 7, 40, 2, 2, 1281, 1282, 5, 248, 125, 2, 1282, 1283, 7,
	41, 2, 2, 1283, 1285, 3, 2, 2, 2, 1284, 1242, 3, 2, 2, 2, 1284, 1246, 3,
	2, 2, 2, 1284, 1250, 3, 2, 2, 2, 1284, 1254, 3, 2, 2, 2, 1284, 1258, 3,
	2, 2, 2, 1284, 1262, 3, 2, 2, 2, 1284, 1264, 3, 2, 2, 2, 1284, 1266, 3,
	2, 2, 2, 1284, 1268, 3, 2, 2, 2, 1284, 1270, 3, 2, 2, 2, 1284, 1272, 3,
	2, 2, 2, 1284, 1274, 3, 2, 2, 2, 1284, 1276, 3, 2, 2, 2, 1284, 1278, 3,
	2, 2, 2, 1285, 1288, 3, 2, 2, 2, 1286, 1284, 3, 2, 2, 2, 1286, 1287, 3,
	2, 2, 2, 1287, 139, 3, 2, 2, 2, 1288, 1286, 3, 2, 2, 2, 1289, 1291, 5,
	306, 154, 2, 1290, 1292, 7, 94, 2, 2, 1291, 1290, 3, 2, 2, 2, 1291, 1292,
	3, 2, 2, 2, 1292, 1293, 3, 2, 2, 2, 1293, 1295, 5, 310, 156, 2, 1294, 1296,
	5, 206, 104, 2, 1295, 1294, 3, 2, 2, 2, 1295, 1296, 3, 2, 2, 2, 1296, 1300,
	3, 2, 2, 2, 1297, 1301, 5, 156, 79, 2, 1298, 1301, 5, 158, 80, 2, 1299,
	1301, 5, 160, 81, 2, 1300, 1297, 3, 2, 2, 2, 1300, 1298, 3, 2, 2, 2, 1300,
	1299, 3, 2, 2, 2, 1300, 1301, 3, 2, 2, 2, 1301, 141, 3, 2, 2, 2, 1302,
	1312, 5, 322, 162, 2, 1303, 1309, 5, 138, 70, 2, 1304, 1305, 5, 316, 159,
	2, 1305, 1306, 5, 138, 70, 2, 1306, 1308, 3, 2, 2, 2, 1307, 1304, 3, 2,
	2, 2, 1308, 1311, 3, 2, 2, 2, 1309, 1307, 3, 2, 2, 2, 1309, 1310, 3, 2,
	2, 2, 1310, 1313, 3, 2, 2, 2, 1311, 1309, 3, 2, 2, 2, 1312, 1303, 3, 2,
	2, 2, 1312, 1313, 3, 2, 2, 2, 1313, 1314, 3, 2, 2, 2, 1314, 1315, 5, 324,
	163, 2, 1315, 143, 3, 2, 2, 2, 1316, 1322, 5, 138, 70, 2, 1317, 1318, 5,
	316, 159, 2, 1318, 1319, 5, 138, 70, 2, 1319, 1321, 3, 2, 2, 2, 1320, 1317,
	3, 2, 2, 2, 1321, 1324, 3, 2, 2, 2, 1322, 1320, 3, 2, 2, 2, 1322, 1323,
	3, 2, 2, 2, 1323, 145, 3, 2, 2, 2, 1324, 1322, 3, 2, 2, 2, 1325, 1327,
	5, 148, 75, 2, 1326, 1328, 7, 94, 2, 2, 1327, 1326, 3, 2, 2, 2, 1327, 1328,
	3, 2, 2, 2, 1328, 147, 3, 2, 2, 2, 1329, 1333, 7, 47, 2, 2, 1330, 1331,
	5, 310, 156, 2, 1331, 1332, 7, 35, 2, 2, 1332, 1334, 3, 2, 2, 2, 1333,
	1330, 3, 2, 2, 2, 1333, 1334, 3, 2, 2, 2, 1334, 1335, 3, 2, 2, 2, 1335,
	1336, 5, 150, 76, 2, 1336, 1337, 7, 48, 2, 2, 1337, 149, 3, 2, 2, 2, 1338,
	1344, 5, 152, 77, 2, 1339, 1340, 5, 316, 159, 2, 1340, 1341, 5, 152, 77,
	2, 1341, 1343, 3, 2, 2, 2, 1342, 1339, 3, 2, 2, 2, 1343, 1346, 3, 2, 2,
	2, 1344, 1342, 3, 2, 2, 2, 1344, 1345, 3, 2, 2, 2, 1345, 151, 3, 2, 2,
	2, 1346, 1344, 3, 2, 2, 2, 1347, 1360, 5, 310, 156, 2, 1348, 1349, 5, 322,
	162, 2, 1349, 1355, 5, 154, 78, 2, 1350, 1351, 5, 316, 159, 2, 1351, 1352,
	5, 154, 78, 2, 1352, 1354, 3, 2, 2, 2, 1353, 1350, 3, 2, 2, 2, 1354, 1357,
	3, 2, 2, 2, 1355, 1353, 3, 2, 2, 2, 1355, 1356, 3, 2, 2, 2, 1356, 1358,
	3, 2, 2, 2, 1357, 1355, 3, 2, 2, 2, 1358, 1359, 5, 324, 163, 2, 1359, 1361,
	3, 2, 2, 2, 1360, 1348, 3, 2, 2, 2, 1360, 1361, 3, 2, 2, 2, 1361, 153,
	3, 2, 2, 2, 1362, 1363, 5, 310, 156, 2, 1363, 1364, 7, 39, 2, 2, 1364,
	1366, 3, 2, 2, 2, 1365, 1362, 3, 2, 2, 2, 1365, 1366, 3, 2, 2, 2, 1366,
	1367, 3, 2, 2, 2, 1367, 1368, 5, 138, 70, 2, 1368, 155, 3, 2, 2, 2, 1369,
	1372, 5, 142, 72, 2, 1370, 1372, 5, 208, 105, 2, 1371, 1369, 3, 2, 2, 2,
	1371, 1370, 3, 2, 2, 2, 1372, 157, 3, 2, 2, 2, 1373, 1374, 7, 47, 2, 2,
	1374, 1375, 7, 36, 2, 2, 1375, 1376, 7, 48, 2, 2, 1376, 159, 3, 2, 2, 2,
	1377, 1380, 7, 47, 2, 2, 1378, 1381, 5, 190, 96, 2, 1379, 1381, 5, 138,
	70, 2, 1380, 1378, 3, 2, 2, 2, 1380, 1379, 3, 2, 2, 2, 1381, 1382, 3, 2,
	2, 2, 1382, 1383, 7, 48, 2, 2, 1383, 161, 3, 2, 2, 2, 1384, 1385, 5, 248,
	125, 2, 1385, 1390, 5, 318, 160, 2, 1386, 1391, 5, 170, 86, 2, 1387, 1391,
	5, 174, 88, 2, 1388, 1391, 5, 176, 89, 2, 1389, 1391, 5, 178, 90, 2, 1390,
	1386, 3, 2, 2, 2, 1390, 1387, 3, 2, 2, 2, 1390, 1388, 3, 2, 2, 2, 1390,
	1389, 3, 2, 2, 2, 1390, 1391, 3, 2, 2, 2, 1391, 1392, 3, 2, 2, 2, 1392,
	1393, 5, 320, 161, 2, 1393, 163, 3, 2, 2, 2, 1394, 1395, 7, 40, 2, 2, 1395,
	1396, 5, 248, 125, 2, 1396, 1397, 7, 41, 2, 2, 1397, 1399, 5, 322, 162,
	2, 1398, 1400, 7, 94, 2, 2, 1399, 1398, 3, 2, 2, 2, 1399, 1400, 3, 2, 2,
	2, 1400, 1402, 3, 2, 2, 2, 1401, 1403, 5, 144, 73, 2, 1402, 1401, 3, 2,
	2, 2, 1402, 1403, 3, 2, 2, 2, 1403, 1405, 3, 2, 2, 2, 1404, 1406, 7, 94,
	2, 2, 1405, 1404, 3, 2, 2, 2, 1405, 1406, 3, 2, 2, 2, 1406, 1407, 3, 2,
	2, 2, 1407, 1408, 5, 324, 163, 2, 1408, 165, 3, 2, 2, 2, 1409, 1410, 7,
	51, 2, 2, 1410, 1411, 5, 322, 162, 2, 1411, 1412, 5, 248, 125, 2, 1412,
	1413, 5, 324, 163, 2, 1413, 167, 3, 2, 2, 2, 1414, 1415, 7, 32, 2, 2, 1415,
	1416, 5, 322, 162, 2, 1416, 1417, 5, 248, 125, 2, 1417, 1418, 5, 324, 163,
	2, 1418, 169, 3, 2, 2, 2, 1419, 1425, 5, 172, 87, 2, 1420, 1421, 5, 316,
	159, 2, 1421, 1422, 5, 172, 87, 2, 1422, 1424, 3, 2, 2, 2, 1423, 1420,
	3, 2, 2, 2, 1424, 1427, 3, 2, 2, 2, 1425, 1423, 3, 2, 2, 2, 1425, 1426,
	3, 2, 2, 2, 1426, 171, 3, 2, 2, 2, 1427, 1425, 3, 2, 2, 2, 1428, 1429,
	5, 200, 101, 2, 1429, 1430, 7, 39, 2, 2, 1430, 1431, 5, 138, 70, 2, 1431,
	173, 3, 2, 2, 2, 1432, 1438, 5, 138, 70, 2, 1433, 1434, 5, 316, 159, 2,
	1434, 1435, 5, 138, 70, 2, 1435, 1437, 3, 2, 2, 2, 1436, 1433, 3, 2, 2,
	2, 1437, 1440, 3, 2, 2, 2, 1438, 1436, 3, 2, 2, 2, 1438, 1439, 3, 2, 2,
	2, 1439, 175, 3, 2, 2, 2, 1440, 1438, 3, 2, 2, 2, 1441, 1442, 7, 47, 2,
	2, 1442, 1443, 5, 138, 70, 2, 1443, 1451, 7, 48, 2, 2, 1444, 1445, 5, 316,
	159, 2, 1445, 1446, 7, 47, 2, 2, 1446, 1447, 5, 138, 70, 2, 1447, 1448,
	7, 48, 2, 2, 1448, 1450, 3, 2, 2, 2, 1449, 1444, 3, 2, 2, 2, 1450, 1453,
	3, 2, 2, 2, 1451, 1449, 3, 2, 2, 2, 1451, 1452, 3, 2, 2, 2, 1452, 177,
	3, 2, 2, 2, 1453, 1451, 3, 2, 2, 2, 1454, 1460, 5, 188, 95, 2, 1455, 1456,
	5, 316, 159, 2, 1456, 1457, 5, 188, 95, 2, 1457, 1459, 3, 2, 2, 2, 1458,
	1455, 3, 2, 2, 2, 1459, 1462, 3, 2, 2, 2, 1460, 1458, 3, 2, 2, 2, 1460,
	1461, 3, 2, 2, 2, 1461, 179, 3, 2, 2, 2, 1462, 1460, 3, 2, 2, 2, 1463,
	1464, 7, 38, 2, 2, 1464, 1465, 5, 138, 70, 2, 1465, 181, 3, 2, 2, 2, 1466,
	1467, 5, 318, 160, 2, 1467, 1473, 5, 138, 70, 2, 1468, 1469, 5, 316, 159,
	2, 1469, 1470, 5, 138, 70, 2, 1470, 1472, 3, 2, 2, 2, 1471, 1468, 3, 2,
	2, 2, 1472, 1475, 3, 2, 2, 2, 1473, 1471, 3, 2, 2, 2, 1473, 1474, 3, 2,
	2, 2, 1474, 1476, 3, 2, 2, 2, 1475, 1473, 3, 2, 2, 2, 1476, 1477, 5, 320,
	161, 2, 1477, 183, 3, 2, 2, 2, 1478, 1479, 5, 318, 160, 2, 1479, 1480,
	7, 47, 2, 2, 1480, 1481, 5, 138, 70, 2, 1481, 1489, 7, 48, 2, 2, 1482,
	1483, 5, 316, 159, 2, 1483, 1484, 7, 47, 2, 2, 1484, 1485, 5, 138, 70,
	2, 1485, 1486, 7, 48, 2, 2, 1486, 1488, 3, 2, 2, 2, 1487, 1482, 3, 2, 2,
	2, 1488, 1491, 3, 2, 2, 2, 1489, 1487, 3, 2, 2, 2, 1489, 1490, 3, 2, 2,
	2, 1490, 1492, 3, 2, 2, 2, 1491, 1489, 3, 2, 2, 2, 1492, 1493, 5, 320,
	161, 2, 1493, 185, 3, 2, 2, 2, 1494, 1495, 5, 318, 160, 2, 1495, 1501,
	5, 188, 95, 2, 1496, 1497, 5, 316, 159, 2, 1497, 1498, 5, 188, 95, 2, 1498,
	1500, 3, 2, 2, 2, 1499, 1496, 3, 2, 2, 2, 1500, 1503, 3, 2, 2, 2, 1501,
	1499, 3, 2, 2, 2, 1501, 1502, 3, 2, 2, 2, 1502, 1504, 3, 2, 2, 2, 1503,
	1501, 3, 2, 2, 2, 1504, 1505, 5, 320, 161, 2, 1505, 187, 3, 2, 2, 2, 1506,
	1507, 7, 47, 2, 2, 1507, 1508, 5, 138, 70, 2, 1508, 1509, 7, 48, 2, 2,
	1509, 1510, 5, 138, 70, 2, 1510, 189, 3, 2, 2, 2, 1511, 1515, 5, 192, 97,
	2, 1512, 1515, 5, 194, 98, 2, 1513, 1515, 5, 196, 99, 2, 1514, 1511, 3,
	2, 2, 2, 1514, 1512, 3, 2, 2, 2, 1514, 1513, 3, 2, 2, 2, 1515, 191, 3,
	2, 2, 2, 1516, 1517, 5, 138, 70, 2, 1517, 1518, 9, 3, 2, 2, 1518, 1519,
	5, 138, 70, 2, 1519, 193, 3, 2, 2, 2, 1520, 1521, 5, 138, 70, 2, 1521,
	1522, 9, 3, 2, 2, 1522, 195, 3, 2, 2, 2, 1523, 1524, 9, 3, 2, 2, 1524,
	1525, 5, 138, 70, 2, 1525, 197, 3, 2, 2, 2, 1526, 1527, 5, 310, 156, 2,
	1527, 1529, 5, 306, 154, 2, 1528, 1530, 7, 94, 2, 2, 1529, 1528, 3, 2,
	2, 2, 1529, 1530, 3, 2, 2, 2, 1530, 1532, 3, 2, 2, 2, 1531, 1526, 3, 2,
	2, 2, 1532, 1535, 3, 2, 2, 2, 1533, 1531, 3, 2, 2, 2, 1533, 1534, 3, 2,
	2, 2, 1534, 1536, 3, 2, 2, 2, 1535, 1533, 3, 2, 2, 2, 1536, 1537, 5, 310,
	156, 2, 1537, 199, 3, 2, 2, 2, 1538, 1547, 5, 310, 156, 2, 1539, 1541,
	5, 306, 154, 2, 1540, 1542, 7, 94, 2, 2, 1541, 1540, 3, 2, 2, 2, 1541,
	1542, 3, 2, 2, 2, 1542, 1543, 3, 2, 2, 2, 1543, 1544, 5, 310, 156, 2, 1544,
	1546, 3, 2, 2, 2, 1545, 1539, 3, 2, 2, 2, 1546, 1549, 3, 2, 2, 2, 1547,
	1545, 3, 2, 2, 2, 1547, 1548, 3, 2, 2, 2, 1548, 201, 3, 2, 2, 2, 1549,
	1547, 3, 2, 2, 2, 1550, 1551, 7, 40, 2, 2, 1551, 1557, 5, 204, 103, 2,
	1552, 1553, 5, 316, 159, 2, 1553, 1554, 5, 204, 103, 2, 1554, 1556, 3,
	2, 2, 2, 1555, 1552, 3, 2, 2, 2, 1556, 1559, 3, 2, 2, 2, 1557, 1555, 3,
	2, 2, 2, 1557, 1558, 3, 2, 2, 2, 1558, 1560, 3, 2, 2, 2, 1559, 1557, 3,
	2, 2, 2, 1560, 1561, 7, 41, 2, 2, 1561, 203, 3, 2, 2, 2, 1562, 1564, 5,
	310, 156, 2, 1563, 1565, 5, 310, 156, 2, 1564, 1563, 3, 2, 2, 2, 1564,
	1565, 3, 2, 2, 2, 1565, 205, 3, 2, 2, 2, 1566, 1567, 7, 40, 2, 2, 1567,
	1573, 5, 248, 125, 2, 1568, 1569, 5, 316, 159, 2, 1569, 1570, 5, 248, 125,
	2, 1570, 1572, 3, 2, 2, 2, 1571, 1568, 3, 2, 2, 2, 1572, 1575, 3, 2, 2,
	2, 1573, 1571, 3, 2, 2, 2, 1573, 1574, 3, 2, 2, 2, 1574, 1576, 3, 2, 2,
	2, 1575, 1573, 3, 2, 2, 2, 1576, 1577, 7, 41, 2, 2, 1577, 207, 3, 2, 2,
	2, 1578, 1580, 5, 318, 160, 2, 1579, 1581, 5, 210, 106, 2, 1580, 1579,
	3, 2, 2, 2, 1580, 1581, 3, 2, 2, 2, 1581, 1582, 3, 2, 2, 2, 1582, 1586,
	9, 2, 2, 2, 1583, 1585, 7, 94, 2, 2, 1584, 1583, 3, 2, 2, 2, 1585, 1588,
	3, 2, 2, 2, 1586, 1584, 3, 2, 2, 2, 1586, 1587, 3, 2, 2, 2, 1587, 1589,
	3, 2, 2, 2, 1588, 1586, 3, 2, 2, 2, 1589, 1590, 5, 134, 68, 2, 1590, 1591,
	5, 320, 161, 2, 1591, 1612, 3, 2, 2, 2, 1592, 1594, 5, 318, 160, 2, 1593,
	1595, 5, 210, 106, 2, 1594, 1593, 3, 2, 2, 2, 1594, 1595, 3, 2, 2, 2, 1595,
	1596, 3, 2, 2, 2, 1596, 1600, 9, 2, 2, 2, 1597, 1599, 7, 94, 2, 2, 1598,
	1597, 3, 2, 2, 2, 1599, 1602, 3, 2, 2, 2, 1600, 1598, 3, 2, 2, 2, 1600,
	1601, 3, 2, 2, 2, 1601, 1606, 3, 2, 2, 2, 1602, 1600, 3, 2, 2, 2, 1603,
	1605, 5, 80, 41, 2, 1604, 1603, 3, 2, 2, 2, 1605, 1608, 3, 2, 2, 2, 1606,
	1604, 3, 2, 2, 2, 1606, 1607, 3, 2, 2, 2, 1607, 1609, 3, 2, 2, 2, 1608,
	1606, 3, 2, 2, 2, 1609, 1610, 5, 320, 161, 2, 1610, 1612, 3, 2, 2, 2, 1611,
	1578, 3, 2, 2, 2, 1611, 1592, 3, 2, 2, 2, 1612, 209, 3, 2, 2, 2, 1613,
	1619, 5, 310, 156, 2, 1614, 1615, 5, 316, 159, 2, 1615, 1616, 5, 310, 156,
	2, 1616, 1618, 3, 2, 2, 2, 1617, 1614, 3, 2, 2, 2, 1618, 1621, 3, 2, 2,
	2, 1619, 1617, 3, 2, 2, 2, 1619, 1620, 3, 2, 2, 2, 1620, 211, 3, 2, 2,
	2, 1621, 1619, 3, 2, 2, 2, 1622, 1623, 5, 214, 108, 2, 1623, 213, 3, 2,
	2, 2, 1624, 1625, 5, 318, 160, 2, 1625, 1631, 5, 216, 109, 2, 1626, 1627,
	5, 316, 159, 2, 1627, 1628, 5, 216, 109, 2, 1628, 1630, 3, 2, 2, 2, 1629,
	1626, 3, 2, 2, 2, 1630, 1633, 3, 2, 2, 2, 1631, 1629, 3, 2, 2, 2, 1631,
	1632, 3, 2, 2, 2, 1632, 1634, 3, 2, 2, 2, 1633, 1631, 3, 2, 2, 2, 1634,
	1635, 5, 320, 161, 2, 1635, 215, 3, 2, 2, 2, 1636, 1637, 5, 200, 101, 2,
	1637, 1638, 7, 39, 2, 2, 1638, 1639, 5, 138, 70, 2, 1639, 217, 3, 2, 2,
	2, 1640, 1641, 5, 322, 162, 2, 1641, 1642, 5, 72, 37, 2, 1642, 1646, 9,
	2, 2, 2, 1643, 1645, 7, 94, 2, 2, 1644, 1643, 3, 2, 2, 2, 1645, 1648, 3,
	2, 2, 2, 1646, 1644, 3, 2, 2, 2, 1646, 1647, 3, 2, 2, 2, 1647, 1649, 3,
	2, 2, 2, 1648, 1646, 3, 2, 2, 2, 1649, 1650, 5, 74, 38, 2, 1650, 1651,
	5, 324, 163, 2, 1651, 1655, 5, 318, 160, 2, 1652, 1654, 5, 80, 41, 2, 1653,
	1652, 3, 2, 2, 2, 1654, 1657, 3, 2, 2, 2, 1655, 1653, 3, 2, 2, 2, 1655,
	1656, 3, 2, 2, 2, 1656, 1658, 3, 2, 2, 2, 1657, 1655, 3, 2, 2, 2, 1658,
	1659, 5, 320, 161, 2, 1659, 219, 3, 2, 2, 2, 1660, 1661, 5, 300, 151, 2,
	1661, 1662, 5, 138, 70, 2, 1662, 221, 3, 2, 2, 2, 1663, 1664, 5, 308, 155,
	2, 1664, 1665, 5, 138, 70, 2, 1665, 223, 3, 2, 2, 2, 1666, 1667, 5, 288,
	145, 2, 1667, 1668, 5, 138, 70, 2, 1668, 225, 3, 2, 2, 2, 1669, 1671, 5,
	232, 117, 2, 1670, 1672, 7, 94, 2, 2, 1671, 1670, 3, 2, 2, 2, 1671, 1672,
	3, 2, 2, 2, 1672, 1673, 3, 2, 2, 2, 1673, 1674, 5, 138, 70, 2, 1674, 1676,
	7, 35, 2, 2, 1675, 1677, 7, 94, 2, 2, 1676, 1675, 3, 2, 2, 2, 1676, 1677,
	3, 2, 2, 2, 1677, 1679, 3, 2, 2, 2, 1678, 1680, 5, 228, 115, 2, 1679, 1678,
	3, 2, 2, 2, 1680, 1681, 3, 2, 2, 2, 1681, 1679, 3, 2, 2, 2, 1681, 1682,
	3, 2, 2, 2, 1682, 1683, 3, 2, 2, 2, 1683, 1685, 9, 4, 2, 2, 1684, 1686,
	7, 94, 2, 2, 1685, 1684, 3, 2, 2, 2, 1685, 1686, 3, 2, 2, 2, 1686, 1687,
	3, 2, 2, 2, 1687, 1688, 5, 138, 70, 2, 1688, 227, 3, 2, 2, 2, 1689, 1691,
	5, 230, 116, 2, 1690, 1692, 5, 138, 70, 2, 1691, 1690, 3, 2, 2, 2, 1691,
	1692, 3, 2, 2, 2, 1692, 1693, 3, 2, 2, 2, 1693, 1695, 7, 35, 2, 2, 1694,
	1696, 7, 94, 2, 2, 1695, 1694, 3, 2, 2, 2, 1695, 1696, 3, 2, 2, 2, 1696,
	229, 3, 2, 2, 2, 1697, 1700, 5, 232, 117, 2, 1698, 1700, 5, 234, 118, 2,
	1699, 1697, 3, 2, 2, 2, 1699, 1698, 3, 2, 2, 2, 1700, 231, 3, 2, 2, 2,
	1701, 1702, 7, 3, 2, 2, 1702, 233, 3, 2, 2, 2, 1703, 1704, 9, 5, 2, 2,
	1704, 235, 3, 2, 2, 2, 1705, 1707, 7, 86, 2, 2, 1706, 1708, 5, 238, 120,
	2, 1707, 1706, 3, 2, 2, 2, 1708, 1709, 3, 2, 2, 2, 1709, 1707, 3, 2, 2,
	2, 1709, 1710, 3, 2, 2, 2, 1710, 237, 3, 2, 2, 2, 1711, 1712, 5, 138, 70,
	2, 1712, 1713, 7, 86, 2, 2, 1713, 239, 3, 2, 2, 2, 1714, 1723, 5, 242,
	122, 2, 1715, 1723, 5, 244, 123, 2, 1716, 1723, 7, 86, 2, 2, 1717, 1723,
	7, 87, 2, 2, 1718, 1723, 7, 82, 2, 2, 1719, 1723, 7, 83, 2, 2, 1720, 1723,
	5, 276, 139, 2, 1721, 1723, 7, 84, 2, 2, 1722, 1714, 3, 2, 2, 2, 1722,
	1715, 3, 2, 2, 2, 1722, 1716, 3, 2, 2, 2, 1722, 1717, 3, 2, 2, 2, 1722,
	1718, 3, 2, 2, 2, 1722, 1719, 3, 2, 2, 2, 1722, 1720, 3, 2, 2, 2, 1722,
	1721, 3, 2, 2, 2, 1723, 241, 3, 2, 2, 2, 1724, 1725, 5, 244, 123, 2, 1725,
	1726, 5, 306, 154, 2, 1726, 1727, 5, 244, 123, 2, 1727, 243, 3, 2, 2, 2,
	1728, 1729, 7, 85, 2, 2, 1729, 245, 3, 2, 2, 2, 1730, 1741, 5, 270, 136,
	2, 1731, 1741, 5, 254, 128, 2, 1732, 1741, 5, 256, 129, 2, 1733, 1741,
	5, 258, 130, 2, 1734, 1741, 5, 260, 131, 2, 1735, 1741, 5, 262, 132, 2,
	1736, 1741, 5, 264, 133, 2, 1737, 1741, 5, 274, 138, 2, 1738, 1741, 5,
	266, 134, 2, 1739, 1741, 5, 268, 135, 2, 1740, 1730, 3, 2, 2, 2, 1740,
	1731, 3, 2, 2, 2, 1740, 1732, 3, 2, 2, 2, 1740, 1733, 3, 2, 2, 2, 1740,
	1734, 3, 2, 2, 2, 1740, 1735, 3, 2, 2, 2, 1740, 1736, 3, 2, 2, 2, 1740,
	1737, 3, 2, 2, 2, 1740, 1738, 3, 2, 2, 2, 1740, 1739, 3, 2, 2, 2, 1741,
	247, 3, 2, 2, 2, 1742, 1746, 5, 246, 124, 2, 1743, 1746, 5, 252, 127, 2,
	1744, 1746, 5, 250, 126, 2, 1745, 1742, 3, 2, 2, 2, 1745, 1743, 3, 2, 2,
	2, 1745, 1744, 3, 2, 2, 2, 1746, 249, 3, 2, 2, 2, 1747, 1750, 7, 53, 2,
	2, 1748, 1751, 5, 246, 124, 2, 1749, 1751, 5, 252, 127, 2, 1750, 1748,
	3, 2, 2, 2, 1750, 1749, 3, 2, 2, 2, 1751, 251, 3, 2, 2, 2, 1752, 1753,
	7, 51, 2, 2, 1753, 1754, 5, 246, 124, 2, 1754, 253, 3, 2, 2, 2, 1755, 1756,
	7, 40, 2, 2, 1756, 1760, 5, 248, 125, 2, 1757, 1758, 5, 316, 159, 2, 1758,
	1759, 5, 248, 125, 2, 1759, 1761, 3, 2, 2, 2, 1760, 1757, 3, 2, 2, 2, 1761,
	1762, 3, 2, 2, 2, 1762, 1760, 3, 2, 2, 2, 1762, 1763, 3, 2, 2, 2, 1763,
	1764, 3, 2, 2, 2, 1764, 1765, 7, 41, 2, 2, 1765, 255, 3, 2, 2, 2, 1766,
	1767, 7, 47, 2, 2, 1767, 1768, 7, 50, 2, 2, 1768, 1769, 7, 48, 2, 2, 1769,
	1770, 5, 248, 125, 2, 1770, 257, 3, 2, 2, 2, 1771, 1772, 7, 47, 2, 2, 1772,
	1773, 7, 48, 2, 2, 1773, 1774, 5, 248, 125, 2, 1774, 259, 3, 2, 2, 2, 1775,
	1776, 7, 47, 2, 2, 1776, 1777, 5, 248, 125, 2, 1777, 1778, 7, 48, 2, 2,
	1778, 261, 3, 2, 2, 2, 1779, 1780, 7, 47, 2, 2, 1780, 1781, 5, 248, 125,
	2, 1781, 1782, 7, 48, 2, 2, 1782, 1783, 5, 248, 125, 2, 1783, 263, 3, 2,
	2, 2, 1784, 1785, 7, 47, 2, 2, 1785, 1786, 7, 35, 2, 2, 1786, 1787, 7,
	48, 2, 2, 1787, 1788, 5, 248, 125, 2, 1788, 265, 3, 2, 2, 2, 1789, 1791,
	5, 198, 100, 2, 1790, 1792, 5, 206, 104, 2, 1791, 1790, 3, 2, 2, 2, 1791,
	1792, 3, 2, 2, 2, 1792, 267, 3, 2, 2, 2, 1793, 1794, 5, 322, 162, 2, 1794,
	1795, 5, 272, 137, 2, 1795, 1799, 9, 2, 2, 2, 1796, 1798, 7, 94, 2, 2,
	1797, 1796, 3, 2, 2, 2, 1798, 1801, 3, 2, 2, 2, 1799, 1797, 3, 2, 2, 2,
	1799, 1800, 3, 2, 2, 2, 1800, 1802, 3, 2, 2, 2, 1801, 1799, 3, 2, 2, 2,
	1802, 1803, 5, 272, 137, 2, 1803, 1804, 5, 324, 163, 2, 1804, 269, 3, 2,
	2, 2, 1805, 1806, 7, 80, 2, 2, 1806, 271, 3, 2, 2, 2, 1807, 1809, 5, 248,
	125, 2, 1808, 1807, 3, 2, 2, 2, 1808, 1809, 3, 2, 2, 2, 1809, 1815, 3,
	2, 2, 2, 1810, 1811, 5, 316, 159, 2, 1811, 1812, 5, 248, 125, 2, 1812,
	1814, 3, 2, 2, 2, 1813, 1810, 3, 2, 2, 2, 1814, 1817, 3, 2, 2, 2, 1815,
	1813, 3, 2, 2, 2, 1815, 1816, 3, 2, 2, 2, 1816, 273, 3, 2, 2, 2, 1817,
	1815, 3, 2, 2, 2, 1818, 1835, 7, 64, 2, 2, 1819, 1835, 7, 65, 2, 2, 1820,
	1835, 7, 66, 2, 2, 1821, 1835, 7, 67, 2, 2, 1822, 1835, 7, 68, 2, 2, 1823,
	1835, 7, 69, 2, 2, 1824, 1835, 7, 70, 2, 2, 1825, 1835, 7, 71, 2, 2, 1826,
	1835, 7, 72, 2, 2, 1827, 1835, 7, 73, 2, 2, 1828, 1835, 7, 74, 2, 2, 1829,
	1835, 7, 75, 2, 2, 1830, 1835, 7, 76, 2, 2, 1831, 1835, 7, 77, 2, 2, 1832,
	1835, 7, 78, 2, 2, 1833, 1835, 7, 79, 2, 2, 1834, 1818, 3, 2, 2, 2, 1834,
	1819, 3, 2, 2, 2, 1834, 1820, 3, 2, 2, 2, 1834, 1821, 3, 2, 2, 2, 1834,
	1822, 3, 2, 2, 2, 1834, 1823, 3, 2, 2, 2, 1834, 1824, 3, 2, 2, 2, 1834,
	1825, 3, 2, 2, 2, 1834, 1826, 3, 2, 2, 2, 1834, 1827, 3, 2, 2, 2, 1834,
	1828, 3, 2, 2, 2, 1834, 1829, 3, 2, 2, 2, 1834, 1830, 3, 2, 2, 2, 1834,
	1831, 3, 2, 2, 2, 1834, 1832, 3, 2, 2, 2, 1834, 1833, 3, 2, 2, 2, 1835,
	275, 3, 2, 2, 2, 1836, 1837, 7, 81, 2, 2, 1837, 277, 3, 2, 2, 2, 1838,
	1841, 7, 82, 2, 2, 1839, 1841, 7, 83, 2, 2, 1840, 1838, 3, 2, 2, 2, 1840,
	1839, 3, 2, 2, 2, 1841, 279, 3, 2, 2, 2, 1842, 1843, 9, 6, 2, 2, 1843,
	281, 3, 2, 2, 2, 1844, 1850, 5, 284, 143, 2, 1845, 1850, 5, 286, 144, 2,
	1846, 1850, 5, 290, 146, 2, 1847, 1850, 5, 292, 147, 2, 1848, 1850, 5,
	294, 148, 2, 1849, 1844, 3, 2, 2, 2, 1849, 1845, 3, 2, 2, 2, 1849, 1846,
	3, 2, 2, 2, 1849, 1847, 3, 2, 2, 2, 1849, 1848, 3, 2, 2, 2, 1850, 1852,
	3, 2, 2, 2, 1851, 1853, 7, 94, 2, 2, 1852, 1851, 3, 2, 2, 2, 1852, 1853,
	3, 2, 2, 2, 1853, 283, 3, 2, 2, 2, 1854, 1855, 7, 61, 2, 2, 1855, 1856,
	7, 61, 2, 2, 1856, 285, 3, 2, 2, 2, 1857, 1858, 7, 62, 2, 2, 1858, 1859,
	7, 62, 2, 2, 1859, 287, 3, 2, 2, 2, 1860, 1861, 7, 54, 2, 2, 1861, 1862,
	7, 54, 2, 2, 1862, 289, 3, 2, 2, 2, 1863, 1864, 7, 63, 2, 2, 1864, 1865,
	7, 63, 2, 2, 1865, 291, 3, 2, 2, 2, 1866, 1867, 7, 40, 2, 2, 1867, 1868,
	7, 40, 2, 2, 1868, 293, 3, 2, 2, 2, 1869, 1870, 7, 41, 2, 2, 1870, 1871,
	7, 41, 2, 2, 1871, 295, 3, 2, 2, 2, 1872, 1874, 9, 7, 2, 2, 1873, 1875,
	7, 94, 2, 2, 1874, 1873, 3, 2, 2, 2, 1874, 1875, 3, 2, 2, 2, 1875, 297,
	3, 2, 2, 2, 1876, 1878, 9, 8, 2, 2, 1877, 1879, 7, 94, 2, 2, 1878, 1877,
	3, 2, 2, 2, 1878, 1879, 3, 2, 2, 2, 1879, 299, 3, 2, 2, 2, 1880, 1882,
	9, 9, 2, 2, 1881, 1883, 7, 94, 2, 2, 1882, 1881, 3, 2, 2, 2, 1882, 1883,
	3, 2, 2, 2, 1883, 301, 3, 2, 2, 2, 1884, 1886, 9, 10, 2, 2, 1885, 1887,
	7, 94, 2, 2, 1886, 1885, 3, 2, 2, 2, 1886, 1887, 3, 2, 2, 2, 1887, 303,
	3, 2, 2, 2, 1888, 1890, 9, 11, 2, 2, 1889, 1891, 7, 94, 2, 2, 1890, 1889,
	3, 2, 2, 2, 1890, 1891, 3, 2, 2, 2, 1891, 305, 3, 2, 2, 2, 1892, 1894,
	7, 32, 2, 2, 1893, 1895, 7, 94, 2, 2, 1894, 1893, 3, 2, 2, 2, 1894, 1895,
	3, 2, 2, 2, 1895, 307, 3, 2, 2, 2, 1896, 1897, 7, 54, 2, 2, 1897, 309,
	3, 2, 2, 2, 1898, 1899, 5, 312, 157, 2, 1899, 311, 3, 2, 2, 2, 1900, 1905,
	9, 12, 2, 2, 1901, 1905, 5, 274, 138, 2, 1902, 1905, 5, 270, 136, 2, 1903,
	1905, 5, 230, 116, 2, 1904, 1900, 3, 2, 2, 2, 1904, 1901, 3, 2, 2, 2, 1904,
	1902, 3, 2, 2, 2, 1904, 1903, 3, 2, 2, 2, 1905, 313, 3, 2, 2, 2, 1906,
	1907, 9, 13, 2, 2, 1907, 315, 3, 2, 2, 2, 1908, 1912, 7, 33, 2, 2, 1909,
	1911, 7, 94, 2, 2, 1910, 1909, 3, 2, 2, 2, 1911, 1914, 3, 2, 2, 2, 1912,
	1910, 3, 2, 2, 2, 1912, 1913, 3, 2, 2, 2, 1913, 317, 3, 2, 2, 2, 1914,
	1912, 3, 2, 2, 2, 1915, 1919, 7, 45, 2, 2, 1916, 1918, 7, 94, 2, 2, 1917,
	1916, 3, 2, 2, 2, 1918, 1921, 3, 2, 2, 2, 1919, 1917, 3, 2, 2, 2, 1919,
	1920, 3, 2, 2, 2, 1920, 319, 3, 2, 2, 2, 1921, 1919, 3, 2, 2, 2, 1922,
	1924, 7, 94, 2, 2, 1923, 1922, 3, 2, 2, 2, 1924, 1927, 3, 2, 2, 2, 1925,
	1923, 3, 2, 2, 2, 1925, 1926, 3, 2, 2, 2, 1926, 1928, 3, 2, 2, 2, 1927,
	1925, 3, 2, 2, 2, 1928, 1929, 7, 46, 2, 2, 1929, 321, 3, 2, 2, 2, 1930,
	1931, 7, 43, 2, 2, 1931, 323, 3, 2, 2, 2, 1932, 1933, 7, 44, 2, 2, 1933,
	325, 3, 2, 2, 2, 1934, 1938, 7, 47, 2, 2, 1935, 1937, 7, 94, 2, 2, 1936,
	1935, 3, 2, 2, 2, 1937, 1940, 3, 2, 2, 2, 1938, 1936, 3, 2, 2, 2, 1938,
	1939, 3, 2, 2, 2, 1939, 327, 3, 2, 2, 2, 1940, 1938, 3, 2, 2, 2, 1941,
	1943, 7, 94, 2, 2, 1942, 1941, 3, 2, 2, 2, 1943, 1946, 3, 2, 2, 2, 1944,
	1942, 3, 2, 2, 2, 1944, 1945, 3, 2, 2, 2, 1945, 1947, 3, 2, 2, 2, 1946,
	1944, 3, 2, 2, 2, 1947, 1948, 7, 48, 2, 2, 1948, 329, 3, 2, 2, 2, 202,
	333, 338, 342, 348, 354, 361, 363, 370, 375, 377, 394, 407, 414, 422, 431,
	434, 439, 447, 449, 454, 459, 467, 471, 476, 480, 487, 491, 499, 508, 515,
	519, 526, 536, 543, 553, 557, 563, 569, 577, 579, 588, 594, 609, 614, 621,
	630, 633, 637, 645, 654, 661, 666, 674, 678, 690, 697, 706, 709, 712, 716,
	724, 733, 740, 743, 748, 756, 760, 765, 769, 776, 786, 789, 799, 804, 811,
	815, 823, 832, 840, 849, 857, 862, 869, 873, 880, 887, 893, 914, 921, 931,
	938, 947, 950, 956, 966, 971, 978, 989, 999, 1011, 1023, 1030, 1042, 1053,
	1072, 1079, 1090, 1097, 1101, 1106, 1116, 1122, 1132, 1140, 1159, 1163,
	1195, 1200, 1208, 1213, 1221, 1240, 1284, 1286, 1291, 1295, 1300, 1309,
	1312, 1322, 1327, 1333, 1344, 1355, 1360, 1365, 1371, 1380, 1390, 1399,
	1402, 1405, 1425, 1438, 1451, 1460, 1473, 1489, 1501, 1514, 1529, 1533,
	1541, 1547, 1557, 1564, 1573, 1580, 1586, 1594, 1600, 1606, 1611, 1619,
	1631, 1646, 1655, 1671, 1676, 1681, 1685, 1691, 1695, 1699, 1709, 1722,
	1740, 1745, 1750, 1762, 1791, 1799, 1808, 1815, 1834, 1840, 1849, 1852,
	1874, 1878, 1882, 1886, 1890, 1894, 1904, 1912, 1919, 1925, 1938, 1944,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'from'", "'by'", "'select'", "'where'", "'group'", "'into'", "'orderby'",
	"'join'", "'let'", "'in'", "'on'", "'equals'", "'ascending'", "'descending'",
	"'**'", "'//'", "'%%'", "'+='", "'-='", "'*='", "'/='", "'%='", "':='",
	"'=='", "'<='", "'>='", "'><'", "'...'", "'..'", "'.'", "','", "'=>'",
	"'->'", "'<-'", "'~>'", "'<~'", "'='", "'<'", "'>'", "';'", "'('", "')'",
	"'{'", "'}'", "'['", "']'", "'::'", "':'", "'?'", "'@'", "'!'", "'~'",
	"'+'", "'-'", "'*'", "'/'", "'%'", "'\\'", "'&'", "'|'", "'^'", "'i8'",
	"'u8'", "'i16'", "'u16'", "'i32'", "'u32'", "'i64'", "'u64'", "'f32'",
	"'f64'", "'chr'", "'str'", "'bool'", "'int'", "'num'", "'byte'", "'any'",
	"'nil'", "'true'", "'false'", "'undef'", "", "", "", "", "", "'_'", "",
	"", "", "'\n'",
}
var symbolicNames = []string{
	"", "LinqFrom", "LinqBy", "LinqSelect", "LinqWhere", "LinqGroup", "LinqInto",
	"LinqOrderby", "LinqJoin", "LinqLet", "LinqIn", "LinqOn", "LinqEquals",
	"LinqAscending", "LinqDescending", "Pow", "Root", "Log", "Add_Equal", "Sub_Equal",
	"Mul_Equal", "Div_Equal", "Mod_Equal", "Colon_Equal", "Equal_Equal", "Less_Equal",
	"Greater_Equal", "Not_Equal", "Dot_Dot_Dot", "Dot_Dot", "Dot", "Comma",
	"Equal_Arrow", "Right_Arrow", "Left_Arrow", "Right_Flow", "Left_Flow",
	"Equal", "Less", "Greater", "Semi", "Left_Paren", "Right_Paren", "Left_Brace",
	"Right_Brace", "Left_Brack", "Right_Brack", "Colon_Colon", "Colon", "Question",
	"At", "Bang", "Wave", "Add", "Sub", "Mul", "Div", "Mod", "Slash", "And",
	"Or", "Xor", "TypeI8", "TypeU8", "TypeI16", "TypeU16", "TypeI32", "TypeU32",
	"TypeI64", "TypeU64", "TypeF32", "TypeF64", "TypeChr", "TypeStr", "TypeBool",
	"TypeInt", "TypeNum", "TypeByte", "TypeAny", "NilLiteral", "TrueLiteral",
	"FalseLiteral", "UndefinedLiteral", "NumberLiteral", "TextLiteral", "CharLiteral",
	"IDPrivate", "IDPublic", "Discard", "Big_Big_Comment", "Big_Comment", "Comment",
	"New_Line", "WS",
}

var ruleNames = []string{
	"program", "statement", "exportStatement", "importStatement", "namespaceSupportStatement",
	"typeAliasStatement", "typeRedefineStatement", "enumStatement", "enumSupportStatement",
	"namespaceVariableStatement", "namespaceControlStatement", "namespaceConstantStatement",
	"namespaceFunctionStatement", "packageStatement", "packageSupportStatement",
	"includeStatement", "packageNewStatement", "packageVariableStatement",
	"packageControlSubStatement", "packageEventStatement", "implementStatement",
	"implementSupportStatement", "implementFunctionStatement", "implementControlStatement",
	"overrideStatement", "overrideSupportStatement", "overrideFunctionStatement",
	"overrideControlStatement", "protocolStatement", "protocolSupportStatement",
	"protocolControlStatement", "protocolControlSubStatement", "protocolFunctionStatement",
	"functionStatement", "returnStatement", "parameterClauseIn", "parameterClauseOut",
	"parameterClauseSelf", "parameter", "functionSupportStatement", "judgeCaseStatement",
	"caseStatement", "caseExprStatement", "judgeStatement", "judgeElseStatement",
	"judgeIfStatement", "judgeElseIfStatement", "loopStatement", "loopEachStatement",
	"loopCaseStatement", "loopInfiniteStatement", "loopJumpStatement", "loopContinueStatement",
	"checkStatement", "usingStatement", "checkErrorStatement", "checkFinallyStatment",
	"reportStatement", "iteratorStatement", "variableStatement", "variableDeclaredStatement",
	"channelAssignStatement", "assignStatement", "expressionStatement", "idExpression",
	"idExprItem", "tupleExpression", "primaryExpression", "expression", "callExpression",
	"tuple", "expressionList", "annotationSupport", "annotation", "annotationList",
	"annotationItem", "annotationAssign", "callFunc", "callChannel", "callElement",
	"callPkg", "callNew", "getType", "typeConversion", "pkgAssign", "pkgAssignElement",
	"listAssign", "setAssign", "dictionaryAssign", "callAwait", "list", "set",
	"dictionary", "dictionaryElement", "slice", "sliceFull", "sliceStart",
	"sliceEnd", "nameSpaceItem", "name", "templateDefine", "templateDefineItem",
	"templateCall", "lambda", "lambdaIn", "pkgAnonymous", "pkgAnonymousAssign",
	"pkgAnonymousAssignElement", "functionExpression", "plusMinus", "negate",
	"bitwiseNotExpression", "linq", "linqItem", "linqKeyword", "linqHeadKeyword",
	"linqBodyKeyword", "stringExpression", "stringExpressionElement", "dataStatement",
	"floatExpr", "integerExpr", "typeNotNull", "typeType", "typeReference",
	"typeNullable", "typeTuple", "typeArray", "typeList", "typeSet", "typeDictionary",
	"typeChannel", "typePackage", "typeFunction", "typeAny", "typeFunctionParameterClause",
	"typeBasic", "nilExpr", "boolExpr", "judgeType", "bitwise", "bitwiseAnd",
	"bitwiseOr", "bitwiseNot", "bitwiseXor", "bitwiseLeftShift", "bitwiseRightShift",
	"judge", "assign", "add", "mul", "pow", "call", "wave", "id", "idItem",
	"end", "more", "left_brace", "right_brace", "left_paren", "right_paren",
	"left_brack", "right_brack",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type LiteParser struct {
	*antlr.BaseParser
}

func NewLiteParser(input antlr.TokenStream) *LiteParser {
	this := new(LiteParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "LiteParser.g4"

	return this
}

// LiteParser tokens.
const (
	LiteParserEOF              = antlr.TokenEOF
	LiteParserLinqFrom         = 1
	LiteParserLinqBy           = 2
	LiteParserLinqSelect       = 3
	LiteParserLinqWhere        = 4
	LiteParserLinqGroup        = 5
	LiteParserLinqInto         = 6
	LiteParserLinqOrderby      = 7
	LiteParserLinqJoin         = 8
	LiteParserLinqLet          = 9
	LiteParserLinqIn           = 10
	LiteParserLinqOn           = 11
	LiteParserLinqEquals       = 12
	LiteParserLinqAscending    = 13
	LiteParserLinqDescending   = 14
	LiteParserPow              = 15
	LiteParserRoot             = 16
	LiteParserLog              = 17
	LiteParserAdd_Equal        = 18
	LiteParserSub_Equal        = 19
	LiteParserMul_Equal        = 20
	LiteParserDiv_Equal        = 21
	LiteParserMod_Equal        = 22
	LiteParserColon_Equal      = 23
	LiteParserEqual_Equal      = 24
	LiteParserLess_Equal       = 25
	LiteParserGreater_Equal    = 26
	LiteParserNot_Equal        = 27
	LiteParserDot_Dot_Dot      = 28
	LiteParserDot_Dot          = 29
	LiteParserDot              = 30
	LiteParserComma            = 31
	LiteParserEqual_Arrow      = 32
	LiteParserRight_Arrow      = 33
	LiteParserLeft_Arrow       = 34
	LiteParserRight_Flow       = 35
	LiteParserLeft_Flow        = 36
	LiteParserEqual            = 37
	LiteParserLess             = 38
	LiteParserGreater          = 39
	LiteParserSemi             = 40
	LiteParserLeft_Paren       = 41
	LiteParserRight_Paren      = 42
	LiteParserLeft_Brace       = 43
	LiteParserRight_Brace      = 44
	LiteParserLeft_Brack       = 45
	LiteParserRight_Brack      = 46
	LiteParserColon_Colon      = 47
	LiteParserColon            = 48
	LiteParserQuestion         = 49
	LiteParserAt               = 50
	LiteParserBang             = 51
	LiteParserWave             = 52
	LiteParserAdd              = 53
	LiteParserSub              = 54
	LiteParserMul              = 55
	LiteParserDiv              = 56
	LiteParserMod              = 57
	LiteParserSlash            = 58
	LiteParserAnd              = 59
	LiteParserOr               = 60
	LiteParserXor              = 61
	LiteParserTypeI8           = 62
	LiteParserTypeU8           = 63
	LiteParserTypeI16          = 64
	LiteParserTypeU16          = 65
	LiteParserTypeI32          = 66
	LiteParserTypeU32          = 67
	LiteParserTypeI64          = 68
	LiteParserTypeU64          = 69
	LiteParserTypeF32          = 70
	LiteParserTypeF64          = 71
	LiteParserTypeChr          = 72
	LiteParserTypeStr          = 73
	LiteParserTypeBool         = 74
	LiteParserTypeInt          = 75
	LiteParserTypeNum          = 76
	LiteParserTypeByte         = 77
	LiteParserTypeAny          = 78
	LiteParserNilLiteral       = 79
	LiteParserTrueLiteral      = 80
	LiteParserFalseLiteral     = 81
	LiteParserUndefinedLiteral = 82
	LiteParserNumberLiteral    = 83
	LiteParserTextLiteral      = 84
	LiteParserCharLiteral      = 85
	LiteParserIDPrivate        = 86
	LiteParserIDPublic         = 87
	LiteParserDiscard          = 88
	LiteParserBig_Big_Comment  = 89
	LiteParserBig_Comment      = 90
	LiteParserComment          = 91
	LiteParserNew_Line         = 92
	LiteParserWS               = 93
)

// LiteParser rules.
const (
	LiteParserRULE_program                     = 0
	LiteParserRULE_statement                   = 1
	LiteParserRULE_exportStatement             = 2
	LiteParserRULE_importStatement             = 3
	LiteParserRULE_namespaceSupportStatement   = 4
	LiteParserRULE_typeAliasStatement          = 5
	LiteParserRULE_typeRedefineStatement       = 6
	LiteParserRULE_enumStatement               = 7
	LiteParserRULE_enumSupportStatement        = 8
	LiteParserRULE_namespaceVariableStatement  = 9
	LiteParserRULE_namespaceControlStatement   = 10
	LiteParserRULE_namespaceConstantStatement  = 11
	LiteParserRULE_namespaceFunctionStatement  = 12
	LiteParserRULE_packageStatement            = 13
	LiteParserRULE_packageSupportStatement     = 14
	LiteParserRULE_includeStatement            = 15
	LiteParserRULE_packageNewStatement         = 16
	LiteParserRULE_packageVariableStatement    = 17
	LiteParserRULE_packageControlSubStatement  = 18
	LiteParserRULE_packageEventStatement       = 19
	LiteParserRULE_implementStatement          = 20
	LiteParserRULE_implementSupportStatement   = 21
	LiteParserRULE_implementFunctionStatement  = 22
	LiteParserRULE_implementControlStatement   = 23
	LiteParserRULE_overrideStatement           = 24
	LiteParserRULE_overrideSupportStatement    = 25
	LiteParserRULE_overrideFunctionStatement   = 26
	LiteParserRULE_overrideControlStatement    = 27
	LiteParserRULE_protocolStatement           = 28
	LiteParserRULE_protocolSupportStatement    = 29
	LiteParserRULE_protocolControlStatement    = 30
	LiteParserRULE_protocolControlSubStatement = 31
	LiteParserRULE_protocolFunctionStatement   = 32
	LiteParserRULE_functionStatement           = 33
	LiteParserRULE_returnStatement             = 34
	LiteParserRULE_parameterClauseIn           = 35
	LiteParserRULE_parameterClauseOut          = 36
	LiteParserRULE_parameterClauseSelf         = 37
	LiteParserRULE_parameter                   = 38
	LiteParserRULE_functionSupportStatement    = 39
	LiteParserRULE_judgeCaseStatement          = 40
	LiteParserRULE_caseStatement               = 41
	LiteParserRULE_caseExprStatement           = 42
	LiteParserRULE_judgeStatement              = 43
	LiteParserRULE_judgeElseStatement          = 44
	LiteParserRULE_judgeIfStatement            = 45
	LiteParserRULE_judgeElseIfStatement        = 46
	LiteParserRULE_loopStatement               = 47
	LiteParserRULE_loopEachStatement           = 48
	LiteParserRULE_loopCaseStatement           = 49
	LiteParserRULE_loopInfiniteStatement       = 50
	LiteParserRULE_loopJumpStatement           = 51
	LiteParserRULE_loopContinueStatement       = 52
	LiteParserRULE_checkStatement              = 53
	LiteParserRULE_usingStatement              = 54
	LiteParserRULE_checkErrorStatement         = 55
	LiteParserRULE_checkFinallyStatment        = 56
	LiteParserRULE_reportStatement             = 57
	LiteParserRULE_iteratorStatement           = 58
	LiteParserRULE_variableStatement           = 59
	LiteParserRULE_variableDeclaredStatement   = 60
	LiteParserRULE_channelAssignStatement      = 61
	LiteParserRULE_assignStatement             = 62
	LiteParserRULE_expressionStatement         = 63
	LiteParserRULE_idExpression                = 64
	LiteParserRULE_idExprItem                  = 65
	LiteParserRULE_tupleExpression             = 66
	LiteParserRULE_primaryExpression           = 67
	LiteParserRULE_expression                  = 68
	LiteParserRULE_callExpression              = 69
	LiteParserRULE_tuple                       = 70
	LiteParserRULE_expressionList              = 71
	LiteParserRULE_annotationSupport           = 72
	LiteParserRULE_annotation                  = 73
	LiteParserRULE_annotationList              = 74
	LiteParserRULE_annotationItem              = 75
	LiteParserRULE_annotationAssign            = 76
	LiteParserRULE_callFunc                    = 77
	LiteParserRULE_callChannel                 = 78
	LiteParserRULE_callElement                 = 79
	LiteParserRULE_callPkg                     = 80
	LiteParserRULE_callNew                     = 81
	LiteParserRULE_getType                     = 82
	LiteParserRULE_typeConversion              = 83
	LiteParserRULE_pkgAssign                   = 84
	LiteParserRULE_pkgAssignElement            = 85
	LiteParserRULE_listAssign                  = 86
	LiteParserRULE_setAssign                   = 87
	LiteParserRULE_dictionaryAssign            = 88
	LiteParserRULE_callAwait                   = 89
	LiteParserRULE_list                        = 90
	LiteParserRULE_set                         = 91
	LiteParserRULE_dictionary                  = 92
	LiteParserRULE_dictionaryElement           = 93
	LiteParserRULE_slice                       = 94
	LiteParserRULE_sliceFull                   = 95
	LiteParserRULE_sliceStart                  = 96
	LiteParserRULE_sliceEnd                    = 97
	LiteParserRULE_nameSpaceItem               = 98
	LiteParserRULE_name                        = 99
	LiteParserRULE_templateDefine              = 100
	LiteParserRULE_templateDefineItem          = 101
	LiteParserRULE_templateCall                = 102
	LiteParserRULE_lambda                      = 103
	LiteParserRULE_lambdaIn                    = 104
	LiteParserRULE_pkgAnonymous                = 105
	LiteParserRULE_pkgAnonymousAssign          = 106
	LiteParserRULE_pkgAnonymousAssignElement   = 107
	LiteParserRULE_functionExpression          = 108
	LiteParserRULE_plusMinus                   = 109
	LiteParserRULE_negate                      = 110
	LiteParserRULE_bitwiseNotExpression        = 111
	LiteParserRULE_linq                        = 112
	LiteParserRULE_linqItem                    = 113
	LiteParserRULE_linqKeyword                 = 114
	LiteParserRULE_linqHeadKeyword             = 115
	LiteParserRULE_linqBodyKeyword             = 116
	LiteParserRULE_stringExpression            = 117
	LiteParserRULE_stringExpressionElement     = 118
	LiteParserRULE_dataStatement               = 119
	LiteParserRULE_floatExpr                   = 120
	LiteParserRULE_integerExpr                 = 121
	LiteParserRULE_typeNotNull                 = 122
	LiteParserRULE_typeType                    = 123
	LiteParserRULE_typeReference               = 124
	LiteParserRULE_typeNullable                = 125
	LiteParserRULE_typeTuple                   = 126
	LiteParserRULE_typeArray                   = 127
	LiteParserRULE_typeList                    = 128
	LiteParserRULE_typeSet                     = 129
	LiteParserRULE_typeDictionary              = 130
	LiteParserRULE_typeChannel                 = 131
	LiteParserRULE_typePackage                 = 132
	LiteParserRULE_typeFunction                = 133
	LiteParserRULE_typeAny                     = 134
	LiteParserRULE_typeFunctionParameterClause = 135
	LiteParserRULE_typeBasic                   = 136
	LiteParserRULE_nilExpr                     = 137
	LiteParserRULE_boolExpr                    = 138
	LiteParserRULE_judgeType                   = 139
	LiteParserRULE_bitwise                     = 140
	LiteParserRULE_bitwiseAnd                  = 141
	LiteParserRULE_bitwiseOr                   = 142
	LiteParserRULE_bitwiseNot                  = 143
	LiteParserRULE_bitwiseXor                  = 144
	LiteParserRULE_bitwiseLeftShift            = 145
	LiteParserRULE_bitwiseRightShift           = 146
	LiteParserRULE_judge                       = 147
	LiteParserRULE_assign                      = 148
	LiteParserRULE_add                         = 149
	LiteParserRULE_mul                         = 150
	LiteParserRULE_pow                         = 151
	LiteParserRULE_call                        = 152
	LiteParserRULE_wave                        = 153
	LiteParserRULE_id                          = 154
	LiteParserRULE_idItem                      = 155
	LiteParserRULE_end                         = 156
	LiteParserRULE_more                        = 157
	LiteParserRULE_left_brace                  = 158
	LiteParserRULE_right_brace                 = 159
	LiteParserRULE_left_paren                  = 160
	LiteParserRULE_right_paren                 = 161
	LiteParserRULE_left_brack                  = 162
	LiteParserRULE_right_brack                 = 163
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_program
	return p
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *ProgramContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, LiteParserRULE_program)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == LiteParserLeft_Brack || _la == LiteParserTextLiteral || _la == LiteParserNew_Line {
		{
			p.SetState(328)
			p.Statement()
		}

		p.SetState(331)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *StatementContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *StatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *StatementContext) AllNamespaceSupportStatement() []INamespaceSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamespaceSupportStatementContext)(nil)).Elem())
	var tst = make([]INamespaceSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamespaceSupportStatementContext)
		}
	}

	return tst
}

func (s *StatementContext) NamespaceSupportStatement(i int) INamespaceSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamespaceSupportStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, LiteParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(336)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(333)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(338)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(339)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(342)
		p.ExportStatement()
	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(343)
				p.Match(LiteParserNew_Line)
			}

		}
		p.SetState(348)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(349)
				p.NamespaceSupportStatement()
			}

		}
		p.SetState(354)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
	}

	return localctx
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_exportStatement
	return p
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) TextLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserTextLiteral, 0)
}

func (s *ExportStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *ExportStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *ExportStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ExportStatementContext) AllImportStatement() []IImportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportStatementContext)(nil)).Elem())
	var tst = make([]IImportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportStatementContext)
		}
	}

	return tst
}

func (s *ExportStatementContext) ImportStatement(i int) IImportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *ExportStatementContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *ExportStatementContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, LiteParserRULE_exportStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.Match(LiteParserTextLiteral)
	}
	{
		p.SetState(356)
		p.Left_brace()
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(359)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case LiteParserLeft_Brack, LiteParserTextLiteral:
				{
					p.SetState(357)
					p.ImportStatement()
				}

			case LiteParserNew_Line:
				{
					p.SetState(358)
					p.Match(LiteParserNew_Line)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}
	{
		p.SetState(364)
		p.Right_brace()
	}
	{
		p.SetState(365)
		p.End()
	}

	return localctx
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_importStatement
	return p
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) TextLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserTextLiteral, 0)
}

func (s *ImportStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ImportStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *ImportStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ImportStatementContext) Call() ICallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallContext)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ImportStatement() (localctx IImportStatementContext) {
	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, LiteParserRULE_importStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(367)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(370)
		p.Match(LiteParserTextLiteral)
	}
	p.SetState(375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
		{
			p.SetState(371)
			p.Id()
		}
		p.SetState(373)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == LiteParserDot {
			{
				p.SetState(372)
				p.Call()
			}

		}

	}
	{
		p.SetState(377)
		p.End()
	}

	return localctx
}

// INamespaceSupportStatementContext is an interface to support dynamic dispatch.
type INamespaceSupportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceSupportStatementContext differentiates from other interfaces.
	IsNamespaceSupportStatementContext()
}

type NamespaceSupportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceSupportStatementContext() *NamespaceSupportStatementContext {
	var p = new(NamespaceSupportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_namespaceSupportStatement
	return p
}

func (*NamespaceSupportStatementContext) IsNamespaceSupportStatementContext() {}

func NewNamespaceSupportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceSupportStatementContext {
	var p = new(NamespaceSupportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_namespaceSupportStatement

	return p
}

func (s *NamespaceSupportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceSupportStatementContext) NamespaceVariableStatement() INamespaceVariableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceVariableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceVariableStatementContext)
}

func (s *NamespaceSupportStatementContext) NamespaceControlStatement() INamespaceControlStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceControlStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceControlStatementContext)
}

func (s *NamespaceSupportStatementContext) NamespaceFunctionStatement() INamespaceFunctionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceFunctionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceFunctionStatementContext)
}

func (s *NamespaceSupportStatementContext) NamespaceConstantStatement() INamespaceConstantStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceConstantStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceConstantStatementContext)
}

func (s *NamespaceSupportStatementContext) PackageStatement() IPackageStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageStatementContext)
}

func (s *NamespaceSupportStatementContext) ProtocolStatement() IProtocolStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolStatementContext)
}

func (s *NamespaceSupportStatementContext) ImplementStatement() IImplementStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementStatementContext)
}

func (s *NamespaceSupportStatementContext) OverrideStatement() IOverrideStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOverrideStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOverrideStatementContext)
}

func (s *NamespaceSupportStatementContext) PackageNewStatement() IPackageNewStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageNewStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageNewStatementContext)
}

func (s *NamespaceSupportStatementContext) EnumStatement() IEnumStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumStatementContext)
}

func (s *NamespaceSupportStatementContext) TypeAliasStatement() ITypeAliasStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAliasStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAliasStatementContext)
}

func (s *NamespaceSupportStatementContext) TypeRedefineStatement() ITypeRedefineStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeRedefineStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeRedefineStatementContext)
}

func (s *NamespaceSupportStatementContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *NamespaceSupportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceSupportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceSupportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitNamespaceSupportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) NamespaceSupportStatement() (localctx INamespaceSupportStatementContext) {
	localctx = NewNamespaceSupportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, LiteParserRULE_namespaceSupportStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(379)
			p.NamespaceVariableStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(380)
			p.NamespaceControlStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(381)
			p.NamespaceFunctionStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(382)
			p.NamespaceConstantStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(383)
			p.PackageStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(384)
			p.ProtocolStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(385)
			p.ImplementStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(386)
			p.OverrideStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(387)
			p.PackageNewStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(388)
			p.EnumStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(389)
			p.TypeAliasStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(390)
			p.TypeRedefineStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(391)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// ITypeAliasStatementContext is an interface to support dynamic dispatch.
type ITypeAliasStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAliasStatementContext differentiates from other interfaces.
	IsTypeAliasStatementContext()
}

type TypeAliasStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasStatementContext() *TypeAliasStatementContext {
	var p = new(TypeAliasStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeAliasStatement
	return p
}

func (*TypeAliasStatementContext) IsTypeAliasStatementContext() {}

func NewTypeAliasStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasStatementContext {
	var p = new(TypeAliasStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeAliasStatement

	return p
}

func (s *TypeAliasStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *TypeAliasStatementContext) Equal_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual_Arrow, 0)
}

func (s *TypeAliasStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeAliasStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *TypeAliasStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeAliasStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeAliasStatement() (localctx ITypeAliasStatementContext) {
	localctx = NewTypeAliasStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, LiteParserRULE_typeAliasStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(394)
		p.Id()
	}
	{
		p.SetState(395)
		p.Match(LiteParserEqual_Arrow)
	}
	{
		p.SetState(396)
		p.TypeType()
	}
	{
		p.SetState(397)
		p.End()
	}

	return localctx
}

// ITypeRedefineStatementContext is an interface to support dynamic dispatch.
type ITypeRedefineStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeRedefineStatementContext differentiates from other interfaces.
	IsTypeRedefineStatementContext()
}

type TypeRedefineStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeRedefineStatementContext() *TypeRedefineStatementContext {
	var p = new(TypeRedefineStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeRedefineStatement
	return p
}

func (*TypeRedefineStatementContext) IsTypeRedefineStatementContext() {}

func NewTypeRedefineStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeRedefineStatementContext {
	var p = new(TypeRedefineStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeRedefineStatement

	return p
}

func (s *TypeRedefineStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeRedefineStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *TypeRedefineStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *TypeRedefineStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeRedefineStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *TypeRedefineStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeRedefineStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeRedefineStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeRedefineStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeRedefineStatement() (localctx ITypeRedefineStatementContext) {
	localctx = NewTypeRedefineStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, LiteParserRULE_typeRedefineStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)
		p.Id()
	}
	{
		p.SetState(400)
		p.Match(LiteParserRight_Arrow)
	}
	{
		p.SetState(401)
		p.TypeType()
	}
	{
		p.SetState(402)
		p.End()
	}

	return localctx
}

// IEnumStatementContext is an interface to support dynamic dispatch.
type IEnumStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumStatementContext differentiates from other interfaces.
	IsEnumStatementContext()
}

type EnumStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumStatementContext() *EnumStatementContext {
	var p = new(EnumStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_enumStatement
	return p
}

func (*EnumStatementContext) IsEnumStatementContext() {}

func NewEnumStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumStatementContext {
	var p = new(EnumStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_enumStatement

	return p
}

func (s *EnumStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *EnumStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *EnumStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *EnumStatementContext) Left_brack() ILeft_brackContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_brackContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_brackContext)
}

func (s *EnumStatementContext) Right_brack() IRight_brackContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_brackContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_brackContext)
}

func (s *EnumStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *EnumStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *EnumStatementContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *EnumStatementContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *EnumStatementContext) AllEnumSupportStatement() []IEnumSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumSupportStatementContext)(nil)).Elem())
	var tst = make([]IEnumSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumSupportStatementContext)
		}
	}

	return tst
}

func (s *EnumStatementContext) EnumSupportStatement(i int) IEnumSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumSupportStatementContext)
}

func (s *EnumStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitEnumStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) EnumStatement() (localctx IEnumStatementContext) {
	localctx = NewEnumStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, LiteParserRULE_enumStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(404)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(407)
		p.Id()
	}
	{
		p.SetState(408)
		p.Match(LiteParserRight_Arrow)
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(409)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(415)
		p.TypeType()
	}
	{
		p.SetState(416)
		p.Left_brack()
	}
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
		{
			p.SetState(417)
			p.EnumSupportStatement()
		}

		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(423)
		p.Right_brack()
	}
	{
		p.SetState(424)
		p.End()
	}

	return localctx
}

// IEnumSupportStatementContext is an interface to support dynamic dispatch.
type IEnumSupportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumSupportStatementContext differentiates from other interfaces.
	IsEnumSupportStatementContext()
}

type EnumSupportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumSupportStatementContext() *EnumSupportStatementContext {
	var p = new(EnumSupportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_enumSupportStatement
	return p
}

func (*EnumSupportStatementContext) IsEnumSupportStatementContext() {}

func NewEnumSupportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumSupportStatementContext {
	var p = new(EnumSupportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_enumSupportStatement

	return p
}

func (s *EnumSupportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumSupportStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *EnumSupportStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *EnumSupportStatementContext) Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual, 0)
}

func (s *EnumSupportStatementContext) IntegerExpr() IIntegerExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerExprContext)
}

func (s *EnumSupportStatementContext) Add() IAddContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddContext)
}

func (s *EnumSupportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumSupportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumSupportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitEnumSupportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) EnumSupportStatement() (localctx IEnumSupportStatementContext) {
	localctx = NewEnumSupportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, LiteParserRULE_enumSupportStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(426)
		p.Id()
	}
	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserEqual {
		{
			p.SetState(427)
			p.Match(LiteParserEqual)
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == LiteParserAdd || _la == LiteParserSub {
			{
				p.SetState(428)
				p.Add()
			}

		}
		{
			p.SetState(431)
			p.IntegerExpr()
		}

	}
	{
		p.SetState(434)
		p.End()
	}

	return localctx
}

// INamespaceVariableStatementContext is an interface to support dynamic dispatch.
type INamespaceVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceVariableStatementContext differentiates from other interfaces.
	IsNamespaceVariableStatementContext()
}

type NamespaceVariableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceVariableStatementContext() *NamespaceVariableStatementContext {
	var p = new(NamespaceVariableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_namespaceVariableStatement
	return p
}

func (*NamespaceVariableStatementContext) IsNamespaceVariableStatementContext() {}

func NewNamespaceVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceVariableStatementContext {
	var p = new(NamespaceVariableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_namespaceVariableStatement

	return p
}

func (s *NamespaceVariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceVariableStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *NamespaceVariableStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *NamespaceVariableStatementContext) Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual, 0)
}

func (s *NamespaceVariableStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamespaceVariableStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *NamespaceVariableStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *NamespaceVariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceVariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceVariableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitNamespaceVariableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) NamespaceVariableStatement() (localctx INamespaceVariableStatementContext) {
	localctx = NewNamespaceVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, LiteParserRULE_namespaceVariableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(436)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(439)
		p.Id()
	}
	p.SetState(447)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserEqual:
		{
			p.SetState(440)
			p.Match(LiteParserEqual)
		}
		{
			p.SetState(441)
			p.expression(0)
		}

	case LiteParserLinqFrom, LiteParserLinqBy, LiteParserLinqSelect, LiteParserLinqWhere, LiteParserLinqGroup, LiteParserLinqInto, LiteParserLinqOrderby, LiteParserLinqJoin, LiteParserLinqLet, LiteParserLinqIn, LiteParserLinqOn, LiteParserLinqEquals, LiteParserLinqAscending, LiteParserLinqDescending, LiteParserLess, LiteParserLeft_Paren, LiteParserLeft_Brack, LiteParserQuestion, LiteParserBang, LiteParserTypeI8, LiteParserTypeU8, LiteParserTypeI16, LiteParserTypeU16, LiteParserTypeI32, LiteParserTypeU32, LiteParserTypeI64, LiteParserTypeU64, LiteParserTypeF32, LiteParserTypeF64, LiteParserTypeChr, LiteParserTypeStr, LiteParserTypeBool, LiteParserTypeInt, LiteParserTypeNum, LiteParserTypeByte, LiteParserTypeAny, LiteParserIDPrivate, LiteParserIDPublic:
		{
			p.SetState(442)
			p.TypeType()
		}
		p.SetState(445)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == LiteParserEqual {
			{
				p.SetState(443)
				p.Match(LiteParserEqual)
			}
			{
				p.SetState(444)
				p.expression(0)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(449)
		p.End()
	}

	return localctx
}

// INamespaceControlStatementContext is an interface to support dynamic dispatch.
type INamespaceControlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceControlStatementContext differentiates from other interfaces.
	IsNamespaceControlStatementContext()
}

type NamespaceControlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceControlStatementContext() *NamespaceControlStatementContext {
	var p = new(NamespaceControlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_namespaceControlStatement
	return p
}

func (*NamespaceControlStatementContext) IsNamespaceControlStatementContext() {}

func NewNamespaceControlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceControlStatementContext {
	var p = new(NamespaceControlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_namespaceControlStatement

	return p
}

func (s *NamespaceControlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceControlStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *NamespaceControlStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *NamespaceControlStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *NamespaceControlStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *NamespaceControlStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *NamespaceControlStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *NamespaceControlStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamespaceControlStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *NamespaceControlStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *NamespaceControlStatementContext) AllPackageControlSubStatement() []IPackageControlSubStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackageControlSubStatementContext)(nil)).Elem())
	var tst = make([]IPackageControlSubStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackageControlSubStatementContext)
		}
	}

	return tst
}

func (s *NamespaceControlStatementContext) PackageControlSubStatement(i int) IPackageControlSubStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageControlSubStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackageControlSubStatementContext)
}

func (s *NamespaceControlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceControlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceControlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitNamespaceControlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) NamespaceControlStatement() (localctx INamespaceControlStatementContext) {
	localctx = NewNamespaceControlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, LiteParserRULE_namespaceControlStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(452)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(451)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(454)
		p.Id()
	}
	{
		p.SetState(455)
		p.Left_paren()
	}
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
		{
			p.SetState(456)
			p.expression(0)
		}

	}
	{
		p.SetState(459)
		p.Right_paren()
	}
	{
		p.SetState(460)
		p.TypeType()
	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brace {
		{
			p.SetState(461)
			p.Left_brace()
		}
		p.SetState(463)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
			{
				p.SetState(462)
				p.PackageControlSubStatement()
			}

			p.SetState(465)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(467)
			p.Right_brace()
		}

	}
	{
		p.SetState(471)
		p.End()
	}

	return localctx
}

// INamespaceConstantStatementContext is an interface to support dynamic dispatch.
type INamespaceConstantStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceConstantStatementContext differentiates from other interfaces.
	IsNamespaceConstantStatementContext()
}

type NamespaceConstantStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceConstantStatementContext() *NamespaceConstantStatementContext {
	var p = new(NamespaceConstantStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_namespaceConstantStatement
	return p
}

func (*NamespaceConstantStatementContext) IsNamespaceConstantStatementContext() {}

func NewNamespaceConstantStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceConstantStatementContext {
	var p = new(NamespaceConstantStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_namespaceConstantStatement

	return p
}

func (s *NamespaceConstantStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceConstantStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *NamespaceConstantStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(LiteParserColon, 0)
}

func (s *NamespaceConstantStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamespaceConstantStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *NamespaceConstantStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *NamespaceConstantStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *NamespaceConstantStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceConstantStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceConstantStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitNamespaceConstantStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) NamespaceConstantStatement() (localctx INamespaceConstantStatementContext) {
	localctx = NewNamespaceConstantStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, LiteParserRULE_namespaceConstantStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(473)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(476)
		p.Id()
	}
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(LiteParserLess-38))|(1<<(LiteParserLeft_Paren-38))|(1<<(LiteParserLeft_Brack-38))|(1<<(LiteParserQuestion-38))|(1<<(LiteParserBang-38))|(1<<(LiteParserTypeI8-38))|(1<<(LiteParserTypeU8-38))|(1<<(LiteParserTypeI16-38))|(1<<(LiteParserTypeU16-38))|(1<<(LiteParserTypeI32-38))|(1<<(LiteParserTypeU32-38))|(1<<(LiteParserTypeI64-38))|(1<<(LiteParserTypeU64-38)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(LiteParserTypeF32-70))|(1<<(LiteParserTypeF64-70))|(1<<(LiteParserTypeChr-70))|(1<<(LiteParserTypeStr-70))|(1<<(LiteParserTypeBool-70))|(1<<(LiteParserTypeInt-70))|(1<<(LiteParserTypeNum-70))|(1<<(LiteParserTypeByte-70))|(1<<(LiteParserTypeAny-70))|(1<<(LiteParserIDPrivate-70))|(1<<(LiteParserIDPublic-70)))) != 0) {
		{
			p.SetState(477)
			p.TypeType()
		}

	}
	{
		p.SetState(480)
		p.Match(LiteParserColon)
	}
	{
		p.SetState(481)
		p.expression(0)
	}
	{
		p.SetState(482)
		p.End()
	}

	return localctx
}

// INamespaceFunctionStatementContext is an interface to support dynamic dispatch.
type INamespaceFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsNamespaceFunctionStatementContext differentiates from other interfaces.
	IsNamespaceFunctionStatementContext()
}

type NamespaceFunctionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyNamespaceFunctionStatementContext() *NamespaceFunctionStatementContext {
	var p = new(NamespaceFunctionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_namespaceFunctionStatement
	return p
}

func (*NamespaceFunctionStatementContext) IsNamespaceFunctionStatementContext() {}

func NewNamespaceFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceFunctionStatementContext {
	var p = new(NamespaceFunctionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_namespaceFunctionStatement

	return p
}

func (s *NamespaceFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceFunctionStatementContext) GetT() antlr.Token { return s.t }

func (s *NamespaceFunctionStatementContext) SetT(v antlr.Token) { s.t = v }

func (s *NamespaceFunctionStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *NamespaceFunctionStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *NamespaceFunctionStatementContext) ParameterClauseIn() IParameterClauseInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseInContext)
}

func (s *NamespaceFunctionStatementContext) ParameterClauseOut() IParameterClauseOutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseOutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseOutContext)
}

func (s *NamespaceFunctionStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *NamespaceFunctionStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *NamespaceFunctionStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *NamespaceFunctionStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *NamespaceFunctionStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *NamespaceFunctionStatementContext) Right_Flow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Flow, 0)
}

func (s *NamespaceFunctionStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *NamespaceFunctionStatementContext) TemplateDefine() ITemplateDefineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateDefineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateDefineContext)
}

func (s *NamespaceFunctionStatementContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *NamespaceFunctionStatementContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *NamespaceFunctionStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *NamespaceFunctionStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *NamespaceFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitNamespaceFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) NamespaceFunctionStatement() (localctx INamespaceFunctionStatementContext) {
	localctx = NewNamespaceFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, LiteParserRULE_namespaceFunctionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(484)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(487)
		p.Id()
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLess {
		{
			p.SetState(488)
			p.TemplateDefine()
		}

	}
	{
		p.SetState(491)
		p.Left_paren()
	}
	{
		p.SetState(492)
		p.ParameterClauseIn()
	}
	{
		p.SetState(493)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*NamespaceFunctionStatementContext).t = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserRight_Arrow || _la == LiteParserRight_Flow) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*NamespaceFunctionStatementContext).t = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(494)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(500)
		p.ParameterClauseOut()
	}
	{
		p.SetState(501)
		p.Right_paren()
	}
	{
		p.SetState(502)
		p.Left_brace()
	}
	p.SetState(506)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(503)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}
	{
		p.SetState(509)
		p.Right_brace()
	}
	{
		p.SetState(510)
		p.End()
	}

	return localctx
}

// IPackageStatementContext is an interface to support dynamic dispatch.
type IPackageStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageStatementContext differentiates from other interfaces.
	IsPackageStatementContext()
}

type PackageStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageStatementContext() *PackageStatementContext {
	var p = new(PackageStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_packageStatement
	return p
}

func (*PackageStatementContext) IsPackageStatementContext() {}

func NewPackageStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageStatementContext {
	var p = new(PackageStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_packageStatement

	return p
}

func (s *PackageStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *PackageStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *PackageStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *PackageStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *PackageStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *PackageStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *PackageStatementContext) TemplateDefine() ITemplateDefineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateDefineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateDefineContext)
}

func (s *PackageStatementContext) AllPackageSupportStatement() []IPackageSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackageSupportStatementContext)(nil)).Elem())
	var tst = make([]IPackageSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackageSupportStatementContext)
		}
	}

	return tst
}

func (s *PackageStatementContext) PackageSupportStatement(i int) IPackageSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackageSupportStatementContext)
}

func (s *PackageStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPackageStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PackageStatement() (localctx IPackageStatementContext) {
	localctx = NewPackageStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, LiteParserRULE_packageStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(512)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(515)
		p.Id()
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLess {
		{
			p.SetState(516)
			p.TemplateDefine()
		}

	}
	{
		p.SetState(519)
		p.Match(LiteParserRight_Arrow)
	}
	{
		p.SetState(520)
		p.Left_brace()
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(521)
				p.PackageSupportStatement()
			}

		}
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
	}
	{
		p.SetState(527)
		p.Right_brace()
	}
	{
		p.SetState(528)
		p.End()
	}

	return localctx
}

// IPackageSupportStatementContext is an interface to support dynamic dispatch.
type IPackageSupportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageSupportStatementContext differentiates from other interfaces.
	IsPackageSupportStatementContext()
}

type PackageSupportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageSupportStatementContext() *PackageSupportStatementContext {
	var p = new(PackageSupportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_packageSupportStatement
	return p
}

func (*PackageSupportStatementContext) IsPackageSupportStatementContext() {}

func NewPackageSupportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageSupportStatementContext {
	var p = new(PackageSupportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_packageSupportStatement

	return p
}

func (s *PackageSupportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageSupportStatementContext) IncludeStatement() IIncludeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIncludeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIncludeStatementContext)
}

func (s *PackageSupportStatementContext) PackageVariableStatement() IPackageVariableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageVariableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageVariableStatementContext)
}

func (s *PackageSupportStatementContext) PackageEventStatement() IPackageEventStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageEventStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageEventStatementContext)
}

func (s *PackageSupportStatementContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *PackageSupportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageSupportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageSupportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPackageSupportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PackageSupportStatement() (localctx IPackageSupportStatementContext) {
	localctx = NewPackageSupportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, LiteParserRULE_packageSupportStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(530)
			p.IncludeStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(531)
			p.PackageVariableStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(532)
			p.PackageEventStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(533)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IIncludeStatementContext is an interface to support dynamic dispatch.
type IIncludeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIncludeStatementContext differentiates from other interfaces.
	IsIncludeStatementContext()
}

type IncludeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncludeStatementContext() *IncludeStatementContext {
	var p = new(IncludeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_includeStatement
	return p
}

func (*IncludeStatementContext) IsIncludeStatementContext() {}

func NewIncludeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncludeStatementContext {
	var p = new(IncludeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_includeStatement

	return p
}

func (s *IncludeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IncludeStatementContext) Discard() antlr.TerminalNode {
	return s.GetToken(LiteParserDiscard, 0)
}

func (s *IncludeStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *IncludeStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *IncludeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncludeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitIncludeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) IncludeStatement() (localctx IIncludeStatementContext) {
	localctx = NewIncludeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, LiteParserRULE_includeStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(536)
		p.Match(LiteParserDiscard)
	}
	{
		p.SetState(537)
		p.TypeType()
	}
	{
		p.SetState(538)
		p.End()
	}

	return localctx
}

// IPackageNewStatementContext is an interface to support dynamic dispatch.
type IPackageNewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageNewStatementContext differentiates from other interfaces.
	IsPackageNewStatementContext()
}

type PackageNewStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageNewStatementContext() *PackageNewStatementContext {
	var p = new(PackageNewStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_packageNewStatement
	return p
}

func (*PackageNewStatementContext) IsPackageNewStatementContext() {}

func NewPackageNewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageNewStatementContext {
	var p = new(PackageNewStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_packageNewStatement

	return p
}

func (s *PackageNewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageNewStatementContext) ParameterClauseSelf() IParameterClauseSelfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseSelfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseSelfContext)
}

func (s *PackageNewStatementContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *PackageNewStatementContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *PackageNewStatementContext) AllLeft_paren() []ILeft_parenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem())
	var tst = make([]ILeft_parenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILeft_parenContext)
		}
	}

	return tst
}

func (s *PackageNewStatementContext) Left_paren(i int) ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *PackageNewStatementContext) ParameterClauseIn() IParameterClauseInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseInContext)
}

func (s *PackageNewStatementContext) AllRight_paren() []IRight_parenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRight_parenContext)(nil)).Elem())
	var tst = make([]IRight_parenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRight_parenContext)
		}
	}

	return tst
}

func (s *PackageNewStatementContext) Right_paren(i int) IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *PackageNewStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *PackageNewStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *PackageNewStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *PackageNewStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *PackageNewStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *PackageNewStatementContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *PackageNewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageNewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageNewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPackageNewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PackageNewStatement() (localctx IPackageNewStatementContext) {
	localctx = NewPackageNewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, LiteParserRULE_packageNewStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(540)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(543)
		p.ParameterClauseSelf()
	}
	{
		p.SetState(544)
		p.Match(LiteParserLess)
	}
	{
		p.SetState(545)
		p.Match(LiteParserGreater)
	}
	{
		p.SetState(546)
		p.Left_paren()
	}
	{
		p.SetState(547)
		p.ParameterClauseIn()
	}
	{
		p.SetState(548)
		p.Right_paren()
	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Paren {
		{
			p.SetState(549)
			p.Left_paren()
		}
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
			{
				p.SetState(550)
				p.ExpressionList()
			}

		}
		{
			p.SetState(553)
			p.Right_paren()
		}

	}
	{
		p.SetState(557)
		p.Left_brace()
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(558)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(563)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
	}
	{
		p.SetState(564)
		p.Right_brace()
	}

	return localctx
}

// IPackageVariableStatementContext is an interface to support dynamic dispatch.
type IPackageVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageVariableStatementContext differentiates from other interfaces.
	IsPackageVariableStatementContext()
}

type PackageVariableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageVariableStatementContext() *PackageVariableStatementContext {
	var p = new(PackageVariableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_packageVariableStatement
	return p
}

func (*PackageVariableStatementContext) IsPackageVariableStatementContext() {}

func NewPackageVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageVariableStatementContext {
	var p = new(PackageVariableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_packageVariableStatement

	return p
}

func (s *PackageVariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageVariableStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *PackageVariableStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *PackageVariableStatementContext) Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual, 0)
}

func (s *PackageVariableStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PackageVariableStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *PackageVariableStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *PackageVariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageVariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageVariableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPackageVariableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PackageVariableStatement() (localctx IPackageVariableStatementContext) {
	localctx = NewPackageVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, LiteParserRULE_packageVariableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(566)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(569)
		p.Id()
	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserEqual:
		{
			p.SetState(570)
			p.Match(LiteParserEqual)
		}
		{
			p.SetState(571)
			p.expression(0)
		}

	case LiteParserLinqFrom, LiteParserLinqBy, LiteParserLinqSelect, LiteParserLinqWhere, LiteParserLinqGroup, LiteParserLinqInto, LiteParserLinqOrderby, LiteParserLinqJoin, LiteParserLinqLet, LiteParserLinqIn, LiteParserLinqOn, LiteParserLinqEquals, LiteParserLinqAscending, LiteParserLinqDescending, LiteParserLess, LiteParserLeft_Paren, LiteParserLeft_Brack, LiteParserQuestion, LiteParserBang, LiteParserTypeI8, LiteParserTypeU8, LiteParserTypeI16, LiteParserTypeU16, LiteParserTypeI32, LiteParserTypeU32, LiteParserTypeI64, LiteParserTypeU64, LiteParserTypeF32, LiteParserTypeF64, LiteParserTypeChr, LiteParserTypeStr, LiteParserTypeBool, LiteParserTypeInt, LiteParserTypeNum, LiteParserTypeByte, LiteParserTypeAny, LiteParserIDPrivate, LiteParserIDPublic:
		{
			p.SetState(572)
			p.TypeType()
		}
		p.SetState(575)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == LiteParserEqual {
			{
				p.SetState(573)
				p.Match(LiteParserEqual)
			}
			{
				p.SetState(574)
				p.expression(0)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(579)
		p.End()
	}

	return localctx
}

// IPackageControlSubStatementContext is an interface to support dynamic dispatch.
type IPackageControlSubStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageControlSubStatementContext differentiates from other interfaces.
	IsPackageControlSubStatementContext()
}

type PackageControlSubStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageControlSubStatementContext() *PackageControlSubStatementContext {
	var p = new(PackageControlSubStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_packageControlSubStatement
	return p
}

func (*PackageControlSubStatementContext) IsPackageControlSubStatementContext() {}

func NewPackageControlSubStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageControlSubStatementContext {
	var p = new(PackageControlSubStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_packageControlSubStatement

	return p
}

func (s *PackageControlSubStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageControlSubStatementContext) AllId() []IIdContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdContext)(nil)).Elem())
	var tst = make([]IIdContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdContext)
		}
	}

	return tst
}

func (s *PackageControlSubStatementContext) Id(i int) IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *PackageControlSubStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *PackageControlSubStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *PackageControlSubStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *PackageControlSubStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *PackageControlSubStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *PackageControlSubStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *PackageControlSubStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *PackageControlSubStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageControlSubStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageControlSubStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPackageControlSubStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PackageControlSubStatement() (localctx IPackageControlSubStatementContext) {
	localctx = NewPackageControlSubStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, LiteParserRULE_packageControlSubStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.Id()
	}
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Paren {
		{
			p.SetState(582)
			p.Left_paren()
		}
		{
			p.SetState(583)
			p.Id()
		}
		{
			p.SetState(584)
			p.Right_paren()
		}

	}
	{
		p.SetState(588)
		p.Left_brace()
	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(589)
				p.FunctionSupportStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(592)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext())
	}
	{
		p.SetState(594)
		p.Right_brace()
	}
	{
		p.SetState(595)
		p.End()
	}

	return localctx
}

// IPackageEventStatementContext is an interface to support dynamic dispatch.
type IPackageEventStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageEventStatementContext differentiates from other interfaces.
	IsPackageEventStatementContext()
}

type PackageEventStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageEventStatementContext() *PackageEventStatementContext {
	var p = new(PackageEventStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_packageEventStatement
	return p
}

func (*PackageEventStatementContext) IsPackageEventStatementContext() {}

func NewPackageEventStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageEventStatementContext {
	var p = new(PackageEventStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_packageEventStatement

	return p
}

func (s *PackageEventStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageEventStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *PackageEventStatementContext) Left_brack() ILeft_brackContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_brackContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_brackContext)
}

func (s *PackageEventStatementContext) Question() antlr.TerminalNode {
	return s.GetToken(LiteParserQuestion, 0)
}

func (s *PackageEventStatementContext) Right_brack() IRight_brackContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_brackContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_brackContext)
}

func (s *PackageEventStatementContext) NameSpaceItem() INameSpaceItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameSpaceItemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameSpaceItemContext)
}

func (s *PackageEventStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *PackageEventStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageEventStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageEventStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPackageEventStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PackageEventStatement() (localctx IPackageEventStatementContext) {
	localctx = NewPackageEventStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, LiteParserRULE_packageEventStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		p.Id()
	}
	{
		p.SetState(598)
		p.Left_brack()
	}
	{
		p.SetState(599)
		p.Match(LiteParserQuestion)
	}
	{
		p.SetState(600)
		p.Right_brack()
	}
	{
		p.SetState(601)
		p.NameSpaceItem()
	}
	{
		p.SetState(602)
		p.End()
	}

	return localctx
}

// IImplementStatementContext is an interface to support dynamic dispatch.
type IImplementStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplementStatementContext differentiates from other interfaces.
	IsImplementStatementContext()
}

type ImplementStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementStatementContext() *ImplementStatementContext {
	var p = new(ImplementStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_implementStatement
	return p
}

func (*ImplementStatementContext) IsImplementStatementContext() {}

func NewImplementStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementStatementContext {
	var p = new(ImplementStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_implementStatement

	return p
}

func (s *ImplementStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementStatementContext) ParameterClauseSelf() IParameterClauseSelfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseSelfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseSelfContext)
}

func (s *ImplementStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *ImplementStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *ImplementStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *ImplementStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ImplementStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ImplementStatementContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *ImplementStatementContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *ImplementStatementContext) AllImplementSupportStatement() []IImplementSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImplementSupportStatementContext)(nil)).Elem())
	var tst = make([]IImplementSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImplementSupportStatementContext)
		}
	}

	return tst
}

func (s *ImplementStatementContext) ImplementSupportStatement(i int) IImplementSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImplementSupportStatementContext)
}

func (s *ImplementStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitImplementStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ImplementStatement() (localctx IImplementStatementContext) {
	localctx = NewImplementStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, LiteParserRULE_implementStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.ParameterClauseSelf()
	}
	{
		p.SetState(605)
		p.Match(LiteParserRight_Arrow)
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(LiteParserLess-38))|(1<<(LiteParserLeft_Paren-38))|(1<<(LiteParserLeft_Brack-38))|(1<<(LiteParserQuestion-38))|(1<<(LiteParserBang-38))|(1<<(LiteParserTypeI8-38))|(1<<(LiteParserTypeU8-38))|(1<<(LiteParserTypeI16-38))|(1<<(LiteParserTypeU16-38))|(1<<(LiteParserTypeI32-38))|(1<<(LiteParserTypeU32-38))|(1<<(LiteParserTypeI64-38))|(1<<(LiteParserTypeU64-38)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(LiteParserTypeF32-70))|(1<<(LiteParserTypeF64-70))|(1<<(LiteParserTypeChr-70))|(1<<(LiteParserTypeStr-70))|(1<<(LiteParserTypeBool-70))|(1<<(LiteParserTypeInt-70))|(1<<(LiteParserTypeNum-70))|(1<<(LiteParserTypeByte-70))|(1<<(LiteParserTypeAny-70))|(1<<(LiteParserIDPrivate-70))|(1<<(LiteParserIDPublic-70)))) != 0) {
		{
			p.SetState(606)
			p.TypeType()
		}

	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(609)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(614)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(615)
		p.Left_brace()
	}
	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(616)
				p.ImplementSupportStatement()
			}

		}
		p.SetState(621)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())
	}
	{
		p.SetState(622)
		p.Right_brace()
	}
	{
		p.SetState(623)
		p.End()
	}

	return localctx
}

// IImplementSupportStatementContext is an interface to support dynamic dispatch.
type IImplementSupportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplementSupportStatementContext differentiates from other interfaces.
	IsImplementSupportStatementContext()
}

type ImplementSupportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementSupportStatementContext() *ImplementSupportStatementContext {
	var p = new(ImplementSupportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_implementSupportStatement
	return p
}

func (*ImplementSupportStatementContext) IsImplementSupportStatementContext() {}

func NewImplementSupportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementSupportStatementContext {
	var p = new(ImplementSupportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_implementSupportStatement

	return p
}

func (s *ImplementSupportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementSupportStatementContext) ImplementFunctionStatement() IImplementFunctionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementFunctionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementFunctionStatementContext)
}

func (s *ImplementSupportStatementContext) ImplementControlStatement() IImplementControlStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementControlStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementControlStatementContext)
}

func (s *ImplementSupportStatementContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *ImplementSupportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementSupportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementSupportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitImplementSupportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ImplementSupportStatement() (localctx IImplementSupportStatementContext) {
	localctx = NewImplementSupportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, LiteParserRULE_implementSupportStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(625)
			p.ImplementFunctionStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(626)
			p.ImplementControlStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(627)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IImplementFunctionStatementContext is an interface to support dynamic dispatch.
type IImplementFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsImplementFunctionStatementContext differentiates from other interfaces.
	IsImplementFunctionStatementContext()
}

type ImplementFunctionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyImplementFunctionStatementContext() *ImplementFunctionStatementContext {
	var p = new(ImplementFunctionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_implementFunctionStatement
	return p
}

func (*ImplementFunctionStatementContext) IsImplementFunctionStatementContext() {}

func NewImplementFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementFunctionStatementContext {
	var p = new(ImplementFunctionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_implementFunctionStatement

	return p
}

func (s *ImplementFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementFunctionStatementContext) GetT() antlr.Token { return s.t }

func (s *ImplementFunctionStatementContext) SetT(v antlr.Token) { s.t = v }

func (s *ImplementFunctionStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ImplementFunctionStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *ImplementFunctionStatementContext) ParameterClauseIn() IParameterClauseInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseInContext)
}

func (s *ImplementFunctionStatementContext) ParameterClauseOut() IParameterClauseOutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseOutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseOutContext)
}

func (s *ImplementFunctionStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *ImplementFunctionStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *ImplementFunctionStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *ImplementFunctionStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ImplementFunctionStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *ImplementFunctionStatementContext) Right_Flow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Flow, 0)
}

func (s *ImplementFunctionStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *ImplementFunctionStatementContext) TemplateDefine() ITemplateDefineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateDefineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateDefineContext)
}

func (s *ImplementFunctionStatementContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *ImplementFunctionStatementContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *ImplementFunctionStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *ImplementFunctionStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *ImplementFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitImplementFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ImplementFunctionStatement() (localctx IImplementFunctionStatementContext) {
	localctx = NewImplementFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, LiteParserRULE_implementFunctionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(630)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(633)
		p.Id()
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLess {
		{
			p.SetState(634)
			p.TemplateDefine()
		}

	}
	{
		p.SetState(637)
		p.Left_paren()
	}
	{
		p.SetState(638)
		p.ParameterClauseIn()
	}
	{
		p.SetState(639)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*ImplementFunctionStatementContext).t = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserRight_Arrow || _la == LiteParserRight_Flow) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*ImplementFunctionStatementContext).t = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(640)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(645)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(646)
		p.ParameterClauseOut()
	}
	{
		p.SetState(647)
		p.Right_paren()
	}
	{
		p.SetState(648)
		p.Left_brace()
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(649)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())
	}
	{
		p.SetState(655)
		p.Right_brace()
	}
	{
		p.SetState(656)
		p.End()
	}

	return localctx
}

// IImplementControlStatementContext is an interface to support dynamic dispatch.
type IImplementControlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplementControlStatementContext differentiates from other interfaces.
	IsImplementControlStatementContext()
}

type ImplementControlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementControlStatementContext() *ImplementControlStatementContext {
	var p = new(ImplementControlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_implementControlStatement
	return p
}

func (*ImplementControlStatementContext) IsImplementControlStatementContext() {}

func NewImplementControlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementControlStatementContext {
	var p = new(ImplementControlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_implementControlStatement

	return p
}

func (s *ImplementControlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementControlStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ImplementControlStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *ImplementControlStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *ImplementControlStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ImplementControlStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ImplementControlStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *ImplementControlStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ImplementControlStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *ImplementControlStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *ImplementControlStatementContext) AllPackageControlSubStatement() []IPackageControlSubStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackageControlSubStatementContext)(nil)).Elem())
	var tst = make([]IPackageControlSubStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackageControlSubStatementContext)
		}
	}

	return tst
}

func (s *ImplementControlStatementContext) PackageControlSubStatement(i int) IPackageControlSubStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageControlSubStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackageControlSubStatementContext)
}

func (s *ImplementControlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementControlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementControlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitImplementControlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ImplementControlStatement() (localctx IImplementControlStatementContext) {
	localctx = NewImplementControlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, LiteParserRULE_implementControlStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(659)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(658)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(661)
		p.Id()
	}
	{
		p.SetState(662)
		p.Left_paren()
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
		{
			p.SetState(663)
			p.expression(0)
		}

	}
	{
		p.SetState(666)
		p.Right_paren()
	}
	{
		p.SetState(667)
		p.TypeType()
	}
	p.SetState(676)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brace {
		{
			p.SetState(668)
			p.Left_brace()
		}
		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
			{
				p.SetState(669)
				p.PackageControlSubStatement()
			}

			p.SetState(672)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(674)
			p.Right_brace()
		}

	}
	{
		p.SetState(678)
		p.End()
	}

	return localctx
}

// IOverrideStatementContext is an interface to support dynamic dispatch.
type IOverrideStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOverrideStatementContext differentiates from other interfaces.
	IsOverrideStatementContext()
}

type OverrideStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverrideStatementContext() *OverrideStatementContext {
	var p = new(OverrideStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_overrideStatement
	return p
}

func (*OverrideStatementContext) IsOverrideStatementContext() {}

func NewOverrideStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverrideStatementContext {
	var p = new(OverrideStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_overrideStatement

	return p
}

func (s *OverrideStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OverrideStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *OverrideStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *OverrideStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *OverrideStatementContext) ParameterClauseSelf() IParameterClauseSelfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseSelfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseSelfContext)
}

func (s *OverrideStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *OverrideStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *OverrideStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *OverrideStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *OverrideStatementContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *OverrideStatementContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *OverrideStatementContext) AllOverrideSupportStatement() []IOverrideSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOverrideSupportStatementContext)(nil)).Elem())
	var tst = make([]IOverrideSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOverrideSupportStatementContext)
		}
	}

	return tst
}

func (s *OverrideStatementContext) OverrideSupportStatement(i int) IOverrideSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOverrideSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOverrideSupportStatementContext)
}

func (s *OverrideStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverrideStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverrideStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitOverrideStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) OverrideStatement() (localctx IOverrideStatementContext) {
	localctx = NewOverrideStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, LiteParserRULE_overrideStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Left_paren()
	}
	{
		p.SetState(681)
		p.Id()
	}
	{
		p.SetState(682)
		p.Right_paren()
	}
	{
		p.SetState(683)
		p.ParameterClauseSelf()
	}
	{
		p.SetState(684)
		p.Match(LiteParserRight_Arrow)
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(685)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(691)
		p.Left_brace()
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(692)
				p.OverrideSupportStatement()
			}

		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}
	{
		p.SetState(698)
		p.Right_brace()
	}
	{
		p.SetState(699)
		p.End()
	}

	return localctx
}

// IOverrideSupportStatementContext is an interface to support dynamic dispatch.
type IOverrideSupportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOverrideSupportStatementContext differentiates from other interfaces.
	IsOverrideSupportStatementContext()
}

type OverrideSupportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverrideSupportStatementContext() *OverrideSupportStatementContext {
	var p = new(OverrideSupportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_overrideSupportStatement
	return p
}

func (*OverrideSupportStatementContext) IsOverrideSupportStatementContext() {}

func NewOverrideSupportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverrideSupportStatementContext {
	var p = new(OverrideSupportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_overrideSupportStatement

	return p
}

func (s *OverrideSupportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OverrideSupportStatementContext) OverrideFunctionStatement() IOverrideFunctionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOverrideFunctionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOverrideFunctionStatementContext)
}

func (s *OverrideSupportStatementContext) OverrideControlStatement() IOverrideControlStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOverrideControlStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOverrideControlStatementContext)
}

func (s *OverrideSupportStatementContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *OverrideSupportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverrideSupportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverrideSupportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitOverrideSupportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) OverrideSupportStatement() (localctx IOverrideSupportStatementContext) {
	localctx = NewOverrideSupportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, LiteParserRULE_overrideSupportStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(701)
			p.OverrideFunctionStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(702)
			p.OverrideControlStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(703)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IOverrideFunctionStatementContext is an interface to support dynamic dispatch.
type IOverrideFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetN returns the n token.
	GetN() antlr.Token

	// GetT returns the t token.
	GetT() antlr.Token

	// SetN sets the n token.
	SetN(antlr.Token)

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsOverrideFunctionStatementContext differentiates from other interfaces.
	IsOverrideFunctionStatementContext()
}

type OverrideFunctionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	n      antlr.Token
	t      antlr.Token
}

func NewEmptyOverrideFunctionStatementContext() *OverrideFunctionStatementContext {
	var p = new(OverrideFunctionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_overrideFunctionStatement
	return p
}

func (*OverrideFunctionStatementContext) IsOverrideFunctionStatementContext() {}

func NewOverrideFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverrideFunctionStatementContext {
	var p = new(OverrideFunctionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_overrideFunctionStatement

	return p
}

func (s *OverrideFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OverrideFunctionStatementContext) GetN() antlr.Token { return s.n }

func (s *OverrideFunctionStatementContext) GetT() antlr.Token { return s.t }

func (s *OverrideFunctionStatementContext) SetN(v antlr.Token) { s.n = v }

func (s *OverrideFunctionStatementContext) SetT(v antlr.Token) { s.t = v }

func (s *OverrideFunctionStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *OverrideFunctionStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *OverrideFunctionStatementContext) ParameterClauseIn() IParameterClauseInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseInContext)
}

func (s *OverrideFunctionStatementContext) ParameterClauseOut() IParameterClauseOutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseOutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseOutContext)
}

func (s *OverrideFunctionStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *OverrideFunctionStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *OverrideFunctionStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *OverrideFunctionStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *OverrideFunctionStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *OverrideFunctionStatementContext) Right_Flow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Flow, 0)
}

func (s *OverrideFunctionStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *OverrideFunctionStatementContext) TemplateDefine() ITemplateDefineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateDefineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateDefineContext)
}

func (s *OverrideFunctionStatementContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *OverrideFunctionStatementContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *OverrideFunctionStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *OverrideFunctionStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *OverrideFunctionStatementContext) Discard() antlr.TerminalNode {
	return s.GetToken(LiteParserDiscard, 0)
}

func (s *OverrideFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverrideFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverrideFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitOverrideFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) OverrideFunctionStatement() (localctx IOverrideFunctionStatementContext) {
	localctx = NewOverrideFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, LiteParserRULE_overrideFunctionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(706)
			p.AnnotationSupport()
		}

	}
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserDiscard {
		{
			p.SetState(709)

			var _m = p.Match(LiteParserDiscard)

			localctx.(*OverrideFunctionStatementContext).n = _m
		}

	}
	{
		p.SetState(712)
		p.Id()
	}
	p.SetState(714)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLess {
		{
			p.SetState(713)
			p.TemplateDefine()
		}

	}
	{
		p.SetState(716)
		p.Left_paren()
	}
	{
		p.SetState(717)
		p.ParameterClauseIn()
	}
	{
		p.SetState(718)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*OverrideFunctionStatementContext).t = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserRight_Arrow || _la == LiteParserRight_Flow) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*OverrideFunctionStatementContext).t = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(719)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(725)
		p.ParameterClauseOut()
	}
	{
		p.SetState(726)
		p.Right_paren()
	}
	{
		p.SetState(727)
		p.Left_brace()
	}
	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(728)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())
	}
	{
		p.SetState(734)
		p.Right_brace()
	}
	{
		p.SetState(735)
		p.End()
	}

	return localctx
}

// IOverrideControlStatementContext is an interface to support dynamic dispatch.
type IOverrideControlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetN returns the n token.
	GetN() antlr.Token

	// SetN sets the n token.
	SetN(antlr.Token)

	// IsOverrideControlStatementContext differentiates from other interfaces.
	IsOverrideControlStatementContext()
}

type OverrideControlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	n      antlr.Token
}

func NewEmptyOverrideControlStatementContext() *OverrideControlStatementContext {
	var p = new(OverrideControlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_overrideControlStatement
	return p
}

func (*OverrideControlStatementContext) IsOverrideControlStatementContext() {}

func NewOverrideControlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverrideControlStatementContext {
	var p = new(OverrideControlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_overrideControlStatement

	return p
}

func (s *OverrideControlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OverrideControlStatementContext) GetN() antlr.Token { return s.n }

func (s *OverrideControlStatementContext) SetN(v antlr.Token) { s.n = v }

func (s *OverrideControlStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *OverrideControlStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *OverrideControlStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *OverrideControlStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *OverrideControlStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *OverrideControlStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *OverrideControlStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OverrideControlStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *OverrideControlStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *OverrideControlStatementContext) Discard() antlr.TerminalNode {
	return s.GetToken(LiteParserDiscard, 0)
}

func (s *OverrideControlStatementContext) AllPackageControlSubStatement() []IPackageControlSubStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackageControlSubStatementContext)(nil)).Elem())
	var tst = make([]IPackageControlSubStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackageControlSubStatementContext)
		}
	}

	return tst
}

func (s *OverrideControlStatementContext) PackageControlSubStatement(i int) IPackageControlSubStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageControlSubStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackageControlSubStatementContext)
}

func (s *OverrideControlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverrideControlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverrideControlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitOverrideControlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) OverrideControlStatement() (localctx IOverrideControlStatementContext) {
	localctx = NewOverrideControlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, LiteParserRULE_overrideControlStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(738)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(737)
			p.AnnotationSupport()
		}

	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserDiscard {
		{
			p.SetState(740)

			var _m = p.Match(LiteParserDiscard)

			localctx.(*OverrideControlStatementContext).n = _m
		}

	}
	{
		p.SetState(743)
		p.Id()
	}
	{
		p.SetState(744)
		p.Left_paren()
	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
		{
			p.SetState(745)
			p.expression(0)
		}

	}
	{
		p.SetState(748)
		p.Right_paren()
	}
	{
		p.SetState(749)
		p.TypeType()
	}
	p.SetState(758)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brace {
		{
			p.SetState(750)
			p.Left_brace()
		}
		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
			{
				p.SetState(751)
				p.PackageControlSubStatement()
			}

			p.SetState(754)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(756)
			p.Right_brace()
		}

	}
	{
		p.SetState(760)
		p.End()
	}

	return localctx
}

// IProtocolStatementContext is an interface to support dynamic dispatch.
type IProtocolStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocolStatementContext differentiates from other interfaces.
	IsProtocolStatementContext()
}

type ProtocolStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocolStatementContext() *ProtocolStatementContext {
	var p = new(ProtocolStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_protocolStatement
	return p
}

func (*ProtocolStatementContext) IsProtocolStatementContext() {}

func NewProtocolStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolStatementContext {
	var p = new(ProtocolStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_protocolStatement

	return p
}

func (s *ProtocolStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ProtocolStatementContext) Left_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Arrow, 0)
}

func (s *ProtocolStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *ProtocolStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *ProtocolStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ProtocolStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *ProtocolStatementContext) TemplateDefine() ITemplateDefineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateDefineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateDefineContext)
}

func (s *ProtocolStatementContext) AllProtocolSupportStatement() []IProtocolSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProtocolSupportStatementContext)(nil)).Elem())
	var tst = make([]IProtocolSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProtocolSupportStatementContext)
		}
	}

	return tst
}

func (s *ProtocolStatementContext) ProtocolSupportStatement(i int) IProtocolSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProtocolSupportStatementContext)
}

func (s *ProtocolStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitProtocolStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ProtocolStatement() (localctx IProtocolStatementContext) {
	localctx = NewProtocolStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, LiteParserRULE_protocolStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(762)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(765)
		p.Id()
	}
	p.SetState(767)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLess {
		{
			p.SetState(766)
			p.TemplateDefine()
		}

	}
	{
		p.SetState(769)
		p.Match(LiteParserLeft_Arrow)
	}
	{
		p.SetState(770)
		p.Left_brace()
	}
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(771)
				p.ProtocolSupportStatement()
			}

		}
		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
	}
	{
		p.SetState(777)
		p.Right_brace()
	}
	{
		p.SetState(778)
		p.End()
	}

	return localctx
}

// IProtocolSupportStatementContext is an interface to support dynamic dispatch.
type IProtocolSupportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocolSupportStatementContext differentiates from other interfaces.
	IsProtocolSupportStatementContext()
}

type ProtocolSupportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocolSupportStatementContext() *ProtocolSupportStatementContext {
	var p = new(ProtocolSupportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_protocolSupportStatement
	return p
}

func (*ProtocolSupportStatementContext) IsProtocolSupportStatementContext() {}

func NewProtocolSupportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolSupportStatementContext {
	var p = new(ProtocolSupportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_protocolSupportStatement

	return p
}

func (s *ProtocolSupportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolSupportStatementContext) IncludeStatement() IIncludeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIncludeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIncludeStatementContext)
}

func (s *ProtocolSupportStatementContext) ProtocolFunctionStatement() IProtocolFunctionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolFunctionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolFunctionStatementContext)
}

func (s *ProtocolSupportStatementContext) ProtocolControlStatement() IProtocolControlStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolControlStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocolControlStatementContext)
}

func (s *ProtocolSupportStatementContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *ProtocolSupportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolSupportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolSupportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitProtocolSupportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ProtocolSupportStatement() (localctx IProtocolSupportStatementContext) {
	localctx = NewProtocolSupportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, LiteParserRULE_protocolSupportStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(780)
			p.IncludeStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(781)
			p.ProtocolFunctionStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(782)
			p.ProtocolControlStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(783)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IProtocolControlStatementContext is an interface to support dynamic dispatch.
type IProtocolControlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocolControlStatementContext differentiates from other interfaces.
	IsProtocolControlStatementContext()
}

type ProtocolControlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocolControlStatementContext() *ProtocolControlStatementContext {
	var p = new(ProtocolControlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_protocolControlStatement
	return p
}

func (*ProtocolControlStatementContext) IsProtocolControlStatementContext() {}

func NewProtocolControlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolControlStatementContext {
	var p = new(ProtocolControlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_protocolControlStatement

	return p
}

func (s *ProtocolControlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolControlStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ProtocolControlStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *ProtocolControlStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *ProtocolControlStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ProtocolControlStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ProtocolControlStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *ProtocolControlStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *ProtocolControlStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *ProtocolControlStatementContext) AllProtocolControlSubStatement() []IProtocolControlSubStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProtocolControlSubStatementContext)(nil)).Elem())
	var tst = make([]IProtocolControlSubStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProtocolControlSubStatementContext)
		}
	}

	return tst
}

func (s *ProtocolControlStatementContext) ProtocolControlSubStatement(i int) IProtocolControlSubStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocolControlSubStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProtocolControlSubStatementContext)
}

func (s *ProtocolControlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolControlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolControlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitProtocolControlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ProtocolControlStatement() (localctx IProtocolControlStatementContext) {
	localctx = NewProtocolControlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, LiteParserRULE_protocolControlStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(786)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(789)
		p.Id()
	}
	{
		p.SetState(790)
		p.Left_paren()
	}
	{
		p.SetState(791)
		p.Right_paren()
	}
	{
		p.SetState(792)
		p.TypeType()
	}
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brace {
		{
			p.SetState(793)
			p.Left_brace()
		}
		p.SetState(797)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
			{
				p.SetState(794)
				p.ProtocolControlSubStatement()
			}

			p.SetState(799)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(800)
			p.Right_brace()
		}

	}
	{
		p.SetState(804)
		p.End()
	}

	return localctx
}

// IProtocolControlSubStatementContext is an interface to support dynamic dispatch.
type IProtocolControlSubStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocolControlSubStatementContext differentiates from other interfaces.
	IsProtocolControlSubStatementContext()
}

type ProtocolControlSubStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocolControlSubStatementContext() *ProtocolControlSubStatementContext {
	var p = new(ProtocolControlSubStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_protocolControlSubStatement
	return p
}

func (*ProtocolControlSubStatementContext) IsProtocolControlSubStatementContext() {}

func NewProtocolControlSubStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolControlSubStatementContext {
	var p = new(ProtocolControlSubStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_protocolControlSubStatement

	return p
}

func (s *ProtocolControlSubStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolControlSubStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ProtocolControlSubStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolControlSubStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolControlSubStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitProtocolControlSubStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ProtocolControlSubStatement() (localctx IProtocolControlSubStatementContext) {
	localctx = NewProtocolControlSubStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, LiteParserRULE_protocolControlSubStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		p.Id()
	}

	return localctx
}

// IProtocolFunctionStatementContext is an interface to support dynamic dispatch.
type IProtocolFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsProtocolFunctionStatementContext differentiates from other interfaces.
	IsProtocolFunctionStatementContext()
}

type ProtocolFunctionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyProtocolFunctionStatementContext() *ProtocolFunctionStatementContext {
	var p = new(ProtocolFunctionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_protocolFunctionStatement
	return p
}

func (*ProtocolFunctionStatementContext) IsProtocolFunctionStatementContext() {}

func NewProtocolFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProtocolFunctionStatementContext {
	var p = new(ProtocolFunctionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_protocolFunctionStatement

	return p
}

func (s *ProtocolFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProtocolFunctionStatementContext) GetT() antlr.Token { return s.t }

func (s *ProtocolFunctionStatementContext) SetT(v antlr.Token) { s.t = v }

func (s *ProtocolFunctionStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ProtocolFunctionStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *ProtocolFunctionStatementContext) ParameterClauseIn() IParameterClauseInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseInContext)
}

func (s *ProtocolFunctionStatementContext) ParameterClauseOut() IParameterClauseOutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseOutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseOutContext)
}

func (s *ProtocolFunctionStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *ProtocolFunctionStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ProtocolFunctionStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *ProtocolFunctionStatementContext) Right_Flow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Flow, 0)
}

func (s *ProtocolFunctionStatementContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *ProtocolFunctionStatementContext) TemplateDefine() ITemplateDefineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateDefineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateDefineContext)
}

func (s *ProtocolFunctionStatementContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *ProtocolFunctionStatementContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *ProtocolFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProtocolFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProtocolFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitProtocolFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ProtocolFunctionStatement() (localctx IProtocolFunctionStatementContext) {
	localctx = NewProtocolFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, LiteParserRULE_protocolFunctionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(808)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(811)
		p.Id()
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLess {
		{
			p.SetState(812)
			p.TemplateDefine()
		}

	}
	{
		p.SetState(815)
		p.Left_paren()
	}
	{
		p.SetState(816)
		p.ParameterClauseIn()
	}
	{
		p.SetState(817)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*ProtocolFunctionStatementContext).t = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserRight_Arrow || _la == LiteParserRight_Flow) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*ProtocolFunctionStatementContext).t = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(818)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(824)
		p.ParameterClauseOut()
	}
	{
		p.SetState(825)
		p.Right_paren()
	}
	{
		p.SetState(826)
		p.End()
	}

	return localctx
}

// IFunctionStatementContext is an interface to support dynamic dispatch.
type IFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsFunctionStatementContext differentiates from other interfaces.
	IsFunctionStatementContext()
}

type FunctionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyFunctionStatementContext() *FunctionStatementContext {
	var p = new(FunctionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_functionStatement
	return p
}

func (*FunctionStatementContext) IsFunctionStatementContext() {}

func NewFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionStatementContext {
	var p = new(FunctionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_functionStatement

	return p
}

func (s *FunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionStatementContext) GetT() antlr.Token { return s.t }

func (s *FunctionStatementContext) SetT(v antlr.Token) { s.t = v }

func (s *FunctionStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *FunctionStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *FunctionStatementContext) ParameterClauseIn() IParameterClauseInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseInContext)
}

func (s *FunctionStatementContext) ParameterClauseOut() IParameterClauseOutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseOutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseOutContext)
}

func (s *FunctionStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *FunctionStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *FunctionStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *FunctionStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *FunctionStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *FunctionStatementContext) Right_Flow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Flow, 0)
}

func (s *FunctionStatementContext) TemplateDefine() ITemplateDefineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateDefineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateDefineContext)
}

func (s *FunctionStatementContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *FunctionStatementContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *FunctionStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *FunctionStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *FunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) FunctionStatement() (localctx IFunctionStatementContext) {
	localctx = NewFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, LiteParserRULE_functionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Id()
	}
	p.SetState(830)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLess {
		{
			p.SetState(829)
			p.TemplateDefine()
		}

	}
	{
		p.SetState(832)
		p.Left_paren()
	}
	{
		p.SetState(833)
		p.ParameterClauseIn()
	}
	{
		p.SetState(834)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*FunctionStatementContext).t = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserRight_Arrow || _la == LiteParserRight_Flow) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*FunctionStatementContext).t = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(835)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(840)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(841)
		p.ParameterClauseOut()
	}
	{
		p.SetState(842)
		p.Right_paren()
	}
	{
		p.SetState(843)
		p.Left_brace()
	}
	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(844)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(849)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())
	}
	{
		p.SetState(850)
		p.Right_brace()
	}
	{
		p.SetState(851)
		p.End()
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Left_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Arrow, 0)
}

func (s *ReturnStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ReturnStatementContext) TupleExpression() ITupleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITupleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITupleExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, LiteParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Match(LiteParserLeft_Arrow)
	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
		{
			p.SetState(854)
			p.TupleExpression()
		}

	}
	{
		p.SetState(857)
		p.End()
	}

	return localctx
}

// IParameterClauseInContext is an interface to support dynamic dispatch.
type IParameterClauseInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterClauseInContext differentiates from other interfaces.
	IsParameterClauseInContext()
}

type ParameterClauseInContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterClauseInContext() *ParameterClauseInContext {
	var p = new(ParameterClauseInContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_parameterClauseIn
	return p
}

func (*ParameterClauseInContext) IsParameterClauseInContext() {}

func NewParameterClauseInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterClauseInContext {
	var p = new(ParameterClauseInContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_parameterClauseIn

	return p
}

func (s *ParameterClauseInContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterClauseInContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *ParameterClauseInContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterClauseInContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *ParameterClauseInContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *ParameterClauseInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterClauseInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterClauseInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitParameterClauseIn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ParameterClauseIn() (localctx IParameterClauseInContext) {
	localctx = NewParameterClauseInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, LiteParserRULE_parameterClauseIn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(LiteParserLeft_Brack-45))|(1<<(LiteParserTypeI8-45))|(1<<(LiteParserTypeU8-45))|(1<<(LiteParserTypeI16-45))|(1<<(LiteParserTypeU16-45))|(1<<(LiteParserTypeI32-45))|(1<<(LiteParserTypeU32-45))|(1<<(LiteParserTypeI64-45))|(1<<(LiteParserTypeU64-45))|(1<<(LiteParserTypeF32-45))|(1<<(LiteParserTypeF64-45))|(1<<(LiteParserTypeChr-45))|(1<<(LiteParserTypeStr-45))|(1<<(LiteParserTypeBool-45))|(1<<(LiteParserTypeInt-45))|(1<<(LiteParserTypeNum-45)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(LiteParserTypeByte-77))|(1<<(LiteParserTypeAny-77))|(1<<(LiteParserIDPrivate-77))|(1<<(LiteParserIDPublic-77)))) != 0) {
		{
			p.SetState(859)
			p.Parameter()
		}

	}
	p.SetState(867)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(862)
			p.More()
		}
		{
			p.SetState(863)
			p.Parameter()
		}

		p.SetState(869)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParameterClauseOutContext is an interface to support dynamic dispatch.
type IParameterClauseOutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterClauseOutContext differentiates from other interfaces.
	IsParameterClauseOutContext()
}

type ParameterClauseOutContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterClauseOutContext() *ParameterClauseOutContext {
	var p = new(ParameterClauseOutContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_parameterClauseOut
	return p
}

func (*ParameterClauseOutContext) IsParameterClauseOutContext() {}

func NewParameterClauseOutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterClauseOutContext {
	var p = new(ParameterClauseOutContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_parameterClauseOut

	return p
}

func (s *ParameterClauseOutContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterClauseOutContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *ParameterClauseOutContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterClauseOutContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *ParameterClauseOutContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *ParameterClauseOutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterClauseOutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterClauseOutContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitParameterClauseOut(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ParameterClauseOut() (localctx IParameterClauseOutContext) {
	localctx = NewParameterClauseOutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, LiteParserRULE_parameterClauseOut)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(LiteParserLeft_Brack-45))|(1<<(LiteParserTypeI8-45))|(1<<(LiteParserTypeU8-45))|(1<<(LiteParserTypeI16-45))|(1<<(LiteParserTypeU16-45))|(1<<(LiteParserTypeI32-45))|(1<<(LiteParserTypeU32-45))|(1<<(LiteParserTypeI64-45))|(1<<(LiteParserTypeU64-45))|(1<<(LiteParserTypeF32-45))|(1<<(LiteParserTypeF64-45))|(1<<(LiteParserTypeChr-45))|(1<<(LiteParserTypeStr-45))|(1<<(LiteParserTypeBool-45))|(1<<(LiteParserTypeInt-45))|(1<<(LiteParserTypeNum-45)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(LiteParserTypeByte-77))|(1<<(LiteParserTypeAny-77))|(1<<(LiteParserIDPrivate-77))|(1<<(LiteParserIDPublic-77)))) != 0) {
		{
			p.SetState(870)
			p.Parameter()
		}

	}
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(873)
			p.More()
		}
		{
			p.SetState(874)
			p.Parameter()
		}

		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParameterClauseSelfContext is an interface to support dynamic dispatch.
type IParameterClauseSelfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterClauseSelfContext differentiates from other interfaces.
	IsParameterClauseSelfContext()
}

type ParameterClauseSelfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterClauseSelfContext() *ParameterClauseSelfContext {
	var p = new(ParameterClauseSelfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_parameterClauseSelf
	return p
}

func (*ParameterClauseSelfContext) IsParameterClauseSelfContext() {}

func NewParameterClauseSelfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterClauseSelfContext {
	var p = new(ParameterClauseSelfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_parameterClauseSelf

	return p
}

func (s *ParameterClauseSelfContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterClauseSelfContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ParameterClauseSelfContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ParameterClauseSelfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterClauseSelfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterClauseSelfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitParameterClauseSelf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ParameterClauseSelf() (localctx IParameterClauseSelfContext) {
	localctx = NewParameterClauseSelfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, LiteParserRULE_parameterClauseSelf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.Id()
	}
	{
		p.SetState(882)
		p.TypeType()
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *ParameterContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ParameterContext) AnnotationSupport() IAnnotationSupportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationSupportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationSupportContext)
}

func (s *ParameterContext) Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual, 0)
}

func (s *ParameterContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, LiteParserRULE_parameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(885)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(884)
			p.AnnotationSupport()
		}

	}
	{
		p.SetState(887)
		p.Id()
	}
	{
		p.SetState(888)
		p.TypeType()
	}
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserEqual {
		{
			p.SetState(889)
			p.Match(LiteParserEqual)
		}
		{
			p.SetState(890)
			p.expression(0)
		}

	}

	return localctx
}

// IFunctionSupportStatementContext is an interface to support dynamic dispatch.
type IFunctionSupportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionSupportStatementContext differentiates from other interfaces.
	IsFunctionSupportStatementContext()
}

type FunctionSupportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSupportStatementContext() *FunctionSupportStatementContext {
	var p = new(FunctionSupportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_functionSupportStatement
	return p
}

func (*FunctionSupportStatementContext) IsFunctionSupportStatementContext() {}

func NewFunctionSupportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSupportStatementContext {
	var p = new(FunctionSupportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_functionSupportStatement

	return p
}

func (s *FunctionSupportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSupportStatementContext) ReturnStatement() IReturnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *FunctionSupportStatementContext) JudgeCaseStatement() IJudgeCaseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJudgeCaseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJudgeCaseStatementContext)
}

func (s *FunctionSupportStatementContext) JudgeStatement() IJudgeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJudgeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJudgeStatementContext)
}

func (s *FunctionSupportStatementContext) LoopStatement() ILoopStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoopStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *FunctionSupportStatementContext) LoopEachStatement() ILoopEachStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoopEachStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoopEachStatementContext)
}

func (s *FunctionSupportStatementContext) LoopCaseStatement() ILoopCaseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoopCaseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoopCaseStatementContext)
}

func (s *FunctionSupportStatementContext) LoopInfiniteStatement() ILoopInfiniteStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoopInfiniteStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoopInfiniteStatementContext)
}

func (s *FunctionSupportStatementContext) LoopJumpStatement() ILoopJumpStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoopJumpStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoopJumpStatementContext)
}

func (s *FunctionSupportStatementContext) LoopContinueStatement() ILoopContinueStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoopContinueStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoopContinueStatementContext)
}

func (s *FunctionSupportStatementContext) UsingStatement() IUsingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsingStatementContext)
}

func (s *FunctionSupportStatementContext) CheckStatement() ICheckStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheckStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheckStatementContext)
}

func (s *FunctionSupportStatementContext) ReportStatement() IReportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportStatementContext)
}

func (s *FunctionSupportStatementContext) FunctionStatement() IFunctionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionStatementContext)
}

func (s *FunctionSupportStatementContext) VariableStatement() IVariableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *FunctionSupportStatementContext) VariableDeclaredStatement() IVariableDeclaredStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaredStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaredStatementContext)
}

func (s *FunctionSupportStatementContext) ChannelAssignStatement() IChannelAssignStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChannelAssignStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChannelAssignStatementContext)
}

func (s *FunctionSupportStatementContext) AssignStatement() IAssignStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignStatementContext)
}

func (s *FunctionSupportStatementContext) ExpressionStatement() IExpressionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *FunctionSupportStatementContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *FunctionSupportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSupportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSupportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitFunctionSupportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) FunctionSupportStatement() (localctx IFunctionSupportStatementContext) {
	localctx = NewFunctionSupportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, LiteParserRULE_functionSupportStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(893)
			p.ReturnStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(894)
			p.JudgeCaseStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(895)
			p.JudgeStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(896)
			p.LoopStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(897)
			p.LoopEachStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(898)
			p.LoopCaseStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(899)
			p.LoopInfiniteStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(900)
			p.LoopJumpStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(901)
			p.LoopContinueStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(902)
			p.UsingStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(903)
			p.CheckStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(904)
			p.ReportStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(905)
			p.FunctionStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(906)
			p.VariableStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(907)
			p.VariableDeclaredStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(908)
			p.ChannelAssignStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(909)
			p.AssignStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(910)
			p.ExpressionStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(911)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IJudgeCaseStatementContext is an interface to support dynamic dispatch.
type IJudgeCaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJudgeCaseStatementContext differentiates from other interfaces.
	IsJudgeCaseStatementContext()
}

type JudgeCaseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJudgeCaseStatementContext() *JudgeCaseStatementContext {
	var p = new(JudgeCaseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_judgeCaseStatement
	return p
}

func (*JudgeCaseStatementContext) IsJudgeCaseStatementContext() {}

func NewJudgeCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JudgeCaseStatementContext {
	var p = new(JudgeCaseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_judgeCaseStatement

	return p
}

func (s *JudgeCaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JudgeCaseStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JudgeCaseStatementContext) Question() antlr.TerminalNode {
	return s.GetToken(LiteParserQuestion, 0)
}

func (s *JudgeCaseStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *JudgeCaseStatementContext) AllCaseStatement() []ICaseStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseStatementContext)(nil)).Elem())
	var tst = make([]ICaseStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseStatementContext)
		}
	}

	return tst
}

func (s *JudgeCaseStatementContext) CaseStatement(i int) ICaseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *JudgeCaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JudgeCaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JudgeCaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitJudgeCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) JudgeCaseStatement() (localctx IJudgeCaseStatementContext) {
	localctx = NewJudgeCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, LiteParserRULE_judgeCaseStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.expression(0)
	}
	{
		p.SetState(915)
		p.Match(LiteParserQuestion)
	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
		{
			p.SetState(916)
			p.CaseStatement()
		}

		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(921)
		p.End()
	}

	return localctx
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_caseStatement
	return p
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) AllCaseExprStatement() []ICaseExprStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseExprStatementContext)(nil)).Elem())
	var tst = make([]ICaseExprStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseExprStatementContext)
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseExprStatement(i int) ICaseExprStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseExprStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseExprStatementContext)
}

func (s *CaseStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *CaseStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *CaseStatementContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *CaseStatementContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *CaseStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *CaseStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, LiteParserRULE_caseStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(923)
		p.CaseExprStatement()
	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(924)
			p.More()
		}
		{
			p.SetState(925)
			p.CaseExprStatement()
		}

		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(932)
		p.Left_brace()
	}
	p.SetState(936)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(933)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(938)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
	}
	{
		p.SetState(939)
		p.Right_brace()
	}

	return localctx
}

// ICaseExprStatementContext is an interface to support dynamic dispatch.
type ICaseExprStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseExprStatementContext differentiates from other interfaces.
	IsCaseExprStatementContext()
}

type CaseExprStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExprStatementContext() *CaseExprStatementContext {
	var p = new(CaseExprStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_caseExprStatement
	return p
}

func (*CaseExprStatementContext) IsCaseExprStatementContext() {}

func NewCaseExprStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExprStatementContext {
	var p = new(CaseExprStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_caseExprStatement

	return p
}

func (s *CaseExprStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExprStatementContext) Discard() antlr.TerminalNode {
	return s.GetToken(LiteParserDiscard, 0)
}

func (s *CaseExprStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExprStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *CaseExprStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *CaseExprStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExprStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExprStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCaseExprStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CaseExprStatement() (localctx ICaseExprStatementContext) {
	localctx = NewCaseExprStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, LiteParserRULE_caseExprStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(941)
			p.Match(LiteParserDiscard)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(942)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(945)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case LiteParserLinqFrom, LiteParserLinqBy, LiteParserLinqSelect, LiteParserLinqWhere, LiteParserLinqGroup, LiteParserLinqInto, LiteParserLinqOrderby, LiteParserLinqJoin, LiteParserLinqLet, LiteParserLinqIn, LiteParserLinqOn, LiteParserLinqEquals, LiteParserLinqAscending, LiteParserLinqDescending, LiteParserTypeI8, LiteParserTypeU8, LiteParserTypeI16, LiteParserTypeU16, LiteParserTypeI32, LiteParserTypeU32, LiteParserTypeI64, LiteParserTypeU64, LiteParserTypeF32, LiteParserTypeF64, LiteParserTypeChr, LiteParserTypeStr, LiteParserTypeBool, LiteParserTypeInt, LiteParserTypeNum, LiteParserTypeByte, LiteParserTypeAny, LiteParserIDPrivate, LiteParserIDPublic:
			{
				p.SetState(943)
				p.Id()
			}

		case LiteParserDiscard:
			{
				p.SetState(944)
				p.Match(LiteParserDiscard)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(947)
			p.TypeType()
		}

	}

	return localctx
}

// IJudgeStatementContext is an interface to support dynamic dispatch.
type IJudgeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJudgeStatementContext differentiates from other interfaces.
	IsJudgeStatementContext()
}

type JudgeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJudgeStatementContext() *JudgeStatementContext {
	var p = new(JudgeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_judgeStatement
	return p
}

func (*JudgeStatementContext) IsJudgeStatementContext() {}

func NewJudgeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JudgeStatementContext {
	var p = new(JudgeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_judgeStatement

	return p
}

func (s *JudgeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JudgeStatementContext) JudgeIfStatement() IJudgeIfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJudgeIfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJudgeIfStatementContext)
}

func (s *JudgeStatementContext) JudgeElseStatement() IJudgeElseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJudgeElseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJudgeElseStatementContext)
}

func (s *JudgeStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *JudgeStatementContext) AllJudgeElseIfStatement() []IJudgeElseIfStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJudgeElseIfStatementContext)(nil)).Elem())
	var tst = make([]IJudgeElseIfStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJudgeElseIfStatementContext)
		}
	}

	return tst
}

func (s *JudgeStatementContext) JudgeElseIfStatement(i int) IJudgeElseIfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJudgeElseIfStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJudgeElseIfStatementContext)
}

func (s *JudgeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JudgeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JudgeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitJudgeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) JudgeStatement() (localctx IJudgeStatementContext) {
	localctx = NewJudgeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, LiteParserRULE_judgeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(950)
			p.JudgeIfStatement()
		}
		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(951)
					p.JudgeElseIfStatement()
				}

			}
			p.SetState(956)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())
		}
		{
			p.SetState(957)
			p.JudgeElseStatement()
		}
		{
			p.SetState(958)
			p.End()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(960)
			p.JudgeIfStatement()
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
			{
				p.SetState(961)
				p.JudgeElseIfStatement()
			}

			p.SetState(966)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(967)
			p.End()
		}

	}

	return localctx
}

// IJudgeElseStatementContext is an interface to support dynamic dispatch.
type IJudgeElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJudgeElseStatementContext differentiates from other interfaces.
	IsJudgeElseStatementContext()
}

type JudgeElseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJudgeElseStatementContext() *JudgeElseStatementContext {
	var p = new(JudgeElseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_judgeElseStatement
	return p
}

func (*JudgeElseStatementContext) IsJudgeElseStatementContext() {}

func NewJudgeElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JudgeElseStatementContext {
	var p = new(JudgeElseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_judgeElseStatement

	return p
}

func (s *JudgeElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JudgeElseStatementContext) Discard() antlr.TerminalNode {
	return s.GetToken(LiteParserDiscard, 0)
}

func (s *JudgeElseStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *JudgeElseStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *JudgeElseStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *JudgeElseStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *JudgeElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JudgeElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JudgeElseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitJudgeElseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) JudgeElseStatement() (localctx IJudgeElseStatementContext) {
	localctx = NewJudgeElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, LiteParserRULE_judgeElseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(971)
		p.Match(LiteParserDiscard)
	}
	{
		p.SetState(972)
		p.Left_brace()
	}
	p.SetState(976)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(973)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(978)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())
	}
	{
		p.SetState(979)
		p.Right_brace()
	}

	return localctx
}

// IJudgeIfStatementContext is an interface to support dynamic dispatch.
type IJudgeIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJudgeIfStatementContext differentiates from other interfaces.
	IsJudgeIfStatementContext()
}

type JudgeIfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJudgeIfStatementContext() *JudgeIfStatementContext {
	var p = new(JudgeIfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_judgeIfStatement
	return p
}

func (*JudgeIfStatementContext) IsJudgeIfStatementContext() {}

func NewJudgeIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JudgeIfStatementContext {
	var p = new(JudgeIfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_judgeIfStatement

	return p
}

func (s *JudgeIfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JudgeIfStatementContext) Question() antlr.TerminalNode {
	return s.GetToken(LiteParserQuestion, 0)
}

func (s *JudgeIfStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JudgeIfStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *JudgeIfStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *JudgeIfStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *JudgeIfStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *JudgeIfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JudgeIfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JudgeIfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitJudgeIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) JudgeIfStatement() (localctx IJudgeIfStatementContext) {
	localctx = NewJudgeIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, LiteParserRULE_judgeIfStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(981)
		p.Match(LiteParserQuestion)
	}
	{
		p.SetState(982)
		p.expression(0)
	}
	{
		p.SetState(983)
		p.Left_brace()
	}
	p.SetState(987)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(984)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(989)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
	}
	{
		p.SetState(990)
		p.Right_brace()
	}

	return localctx
}

// IJudgeElseIfStatementContext is an interface to support dynamic dispatch.
type IJudgeElseIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJudgeElseIfStatementContext differentiates from other interfaces.
	IsJudgeElseIfStatementContext()
}

type JudgeElseIfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJudgeElseIfStatementContext() *JudgeElseIfStatementContext {
	var p = new(JudgeElseIfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_judgeElseIfStatement
	return p
}

func (*JudgeElseIfStatementContext) IsJudgeElseIfStatementContext() {}

func NewJudgeElseIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JudgeElseIfStatementContext {
	var p = new(JudgeElseIfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_judgeElseIfStatement

	return p
}

func (s *JudgeElseIfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JudgeElseIfStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JudgeElseIfStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *JudgeElseIfStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *JudgeElseIfStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *JudgeElseIfStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *JudgeElseIfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JudgeElseIfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JudgeElseIfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitJudgeElseIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) JudgeElseIfStatement() (localctx IJudgeElseIfStatementContext) {
	localctx = NewJudgeElseIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, LiteParserRULE_judgeElseIfStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(992)
		p.expression(0)
	}
	{
		p.SetState(993)
		p.Left_brace()
	}
	p.SetState(997)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(994)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(999)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())
	}
	{
		p.SetState(1000)
		p.Right_brace()
	}

	return localctx
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_loopStatement
	return p
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) IteratorStatement() IIteratorStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteratorStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteratorStatementContext)
}

func (s *LoopStatementContext) At() antlr.TerminalNode {
	return s.GetToken(LiteParserAt, 0)
}

func (s *LoopStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *LoopStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *LoopStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *LoopStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *LoopStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *LoopStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLoopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, LiteParserRULE_loopStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.IteratorStatement()
	}
	{
		p.SetState(1003)
		p.Match(LiteParserAt)
	}
	{
		p.SetState(1004)
		p.Id()
	}
	{
		p.SetState(1005)
		p.Left_brace()
	}
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1006)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(1011)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())
	}
	{
		p.SetState(1012)
		p.Right_brace()
	}
	{
		p.SetState(1013)
		p.End()
	}

	return localctx
}

// ILoopEachStatementContext is an interface to support dynamic dispatch.
type ILoopEachStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoopEachStatementContext differentiates from other interfaces.
	IsLoopEachStatementContext()
}

type LoopEachStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopEachStatementContext() *LoopEachStatementContext {
	var p = new(LoopEachStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_loopEachStatement
	return p
}

func (*LoopEachStatementContext) IsLoopEachStatementContext() {}

func NewLoopEachStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopEachStatementContext {
	var p = new(LoopEachStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_loopEachStatement

	return p
}

func (s *LoopEachStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopEachStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LoopEachStatementContext) At() antlr.TerminalNode {
	return s.GetToken(LiteParserAt, 0)
}

func (s *LoopEachStatementContext) AllId() []IIdContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdContext)(nil)).Elem())
	var tst = make([]IIdContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdContext)
		}
	}

	return tst
}

func (s *LoopEachStatementContext) Id(i int) IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *LoopEachStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *LoopEachStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *LoopEachStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *LoopEachStatementContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *LoopEachStatementContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *LoopEachStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *LoopEachStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *LoopEachStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopEachStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopEachStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLoopEachStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LoopEachStatement() (localctx ILoopEachStatementContext) {
	localctx = NewLoopEachStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, LiteParserRULE_loopEachStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.expression(0)
	}
	{
		p.SetState(1016)
		p.Match(LiteParserAt)
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Brack {
		{
			p.SetState(1017)
			p.Match(LiteParserLeft_Brack)
		}
		{
			p.SetState(1018)
			p.Id()
		}
		{
			p.SetState(1019)
			p.Match(LiteParserRight_Brack)
		}

	}
	{
		p.SetState(1023)
		p.Id()
	}
	{
		p.SetState(1024)
		p.Left_brace()
	}
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1025)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())
	}
	{
		p.SetState(1031)
		p.Right_brace()
	}
	{
		p.SetState(1032)
		p.End()
	}

	return localctx
}

// ILoopCaseStatementContext is an interface to support dynamic dispatch.
type ILoopCaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoopCaseStatementContext differentiates from other interfaces.
	IsLoopCaseStatementContext()
}

type LoopCaseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopCaseStatementContext() *LoopCaseStatementContext {
	var p = new(LoopCaseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_loopCaseStatement
	return p
}

func (*LoopCaseStatementContext) IsLoopCaseStatementContext() {}

func NewLoopCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopCaseStatementContext {
	var p = new(LoopCaseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_loopCaseStatement

	return p
}

func (s *LoopCaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopCaseStatementContext) At() antlr.TerminalNode {
	return s.GetToken(LiteParserAt, 0)
}

func (s *LoopCaseStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LoopCaseStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *LoopCaseStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *LoopCaseStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *LoopCaseStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *LoopCaseStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *LoopCaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopCaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopCaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLoopCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LoopCaseStatement() (localctx ILoopCaseStatementContext) {
	localctx = NewLoopCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, LiteParserRULE_loopCaseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1034)
		p.Match(LiteParserAt)
	}
	{
		p.SetState(1035)
		p.expression(0)
	}
	{
		p.SetState(1036)
		p.Left_brace()
	}
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1037)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
	}
	{
		p.SetState(1043)
		p.Right_brace()
	}
	{
		p.SetState(1044)
		p.End()
	}

	return localctx
}

// ILoopInfiniteStatementContext is an interface to support dynamic dispatch.
type ILoopInfiniteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoopInfiniteStatementContext differentiates from other interfaces.
	IsLoopInfiniteStatementContext()
}

type LoopInfiniteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopInfiniteStatementContext() *LoopInfiniteStatementContext {
	var p = new(LoopInfiniteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_loopInfiniteStatement
	return p
}

func (*LoopInfiniteStatementContext) IsLoopInfiniteStatementContext() {}

func NewLoopInfiniteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopInfiniteStatementContext {
	var p = new(LoopInfiniteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_loopInfiniteStatement

	return p
}

func (s *LoopInfiniteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopInfiniteStatementContext) At() antlr.TerminalNode {
	return s.GetToken(LiteParserAt, 0)
}

func (s *LoopInfiniteStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *LoopInfiniteStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *LoopInfiniteStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *LoopInfiniteStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *LoopInfiniteStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *LoopInfiniteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopInfiniteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopInfiniteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLoopInfiniteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LoopInfiniteStatement() (localctx ILoopInfiniteStatementContext) {
	localctx = NewLoopInfiniteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, LiteParserRULE_loopInfiniteStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1046)
		p.Match(LiteParserAt)
	}
	{
		p.SetState(1047)
		p.Left_brace()
	}
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1048)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(1053)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext())
	}
	{
		p.SetState(1054)
		p.Right_brace()
	}
	{
		p.SetState(1055)
		p.End()
	}

	return localctx
}

// ILoopJumpStatementContext is an interface to support dynamic dispatch.
type ILoopJumpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoopJumpStatementContext differentiates from other interfaces.
	IsLoopJumpStatementContext()
}

type LoopJumpStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopJumpStatementContext() *LoopJumpStatementContext {
	var p = new(LoopJumpStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_loopJumpStatement
	return p
}

func (*LoopJumpStatementContext) IsLoopJumpStatementContext() {}

func NewLoopJumpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopJumpStatementContext {
	var p = new(LoopJumpStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_loopJumpStatement

	return p
}

func (s *LoopJumpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopJumpStatementContext) Left_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Arrow, 0)
}

func (s *LoopJumpStatementContext) At() antlr.TerminalNode {
	return s.GetToken(LiteParserAt, 0)
}

func (s *LoopJumpStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *LoopJumpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopJumpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopJumpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLoopJumpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LoopJumpStatement() (localctx ILoopJumpStatementContext) {
	localctx = NewLoopJumpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, LiteParserRULE_loopJumpStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1057)
		p.Match(LiteParserLeft_Arrow)
	}
	{
		p.SetState(1058)
		p.Match(LiteParserAt)
	}
	{
		p.SetState(1059)
		p.End()
	}

	return localctx
}

// ILoopContinueStatementContext is an interface to support dynamic dispatch.
type ILoopContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoopContinueStatementContext differentiates from other interfaces.
	IsLoopContinueStatementContext()
}

type LoopContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopContinueStatementContext() *LoopContinueStatementContext {
	var p = new(LoopContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_loopContinueStatement
	return p
}

func (*LoopContinueStatementContext) IsLoopContinueStatementContext() {}

func NewLoopContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopContinueStatementContext {
	var p = new(LoopContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_loopContinueStatement

	return p
}

func (s *LoopContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopContinueStatementContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *LoopContinueStatementContext) At() antlr.TerminalNode {
	return s.GetToken(LiteParserAt, 0)
}

func (s *LoopContinueStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *LoopContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLoopContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LoopContinueStatement() (localctx ILoopContinueStatementContext) {
	localctx = NewLoopContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, LiteParserRULE_loopContinueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1061)
		p.Match(LiteParserRight_Arrow)
	}
	{
		p.SetState(1062)
		p.Match(LiteParserAt)
	}
	{
		p.SetState(1063)
		p.End()
	}

	return localctx
}

// ICheckStatementContext is an interface to support dynamic dispatch.
type ICheckStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCheckStatementContext differentiates from other interfaces.
	IsCheckStatementContext()
}

type CheckStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckStatementContext() *CheckStatementContext {
	var p = new(CheckStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_checkStatement
	return p
}

func (*CheckStatementContext) IsCheckStatementContext() {}

func NewCheckStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckStatementContext {
	var p = new(CheckStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_checkStatement

	return p
}

func (s *CheckStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckStatementContext) Bang() antlr.TerminalNode {
	return s.GetToken(LiteParserBang, 0)
}

func (s *CheckStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *CheckStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *CheckStatementContext) CheckFinallyStatment() ICheckFinallyStatmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheckFinallyStatmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheckFinallyStatmentContext)
}

func (s *CheckStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *CheckStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *CheckStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *CheckStatementContext) AllCheckErrorStatement() []ICheckErrorStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICheckErrorStatementContext)(nil)).Elem())
	var tst = make([]ICheckErrorStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICheckErrorStatementContext)
		}
	}

	return tst
}

func (s *CheckStatementContext) CheckErrorStatement(i int) ICheckErrorStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheckErrorStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICheckErrorStatementContext)
}

func (s *CheckStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCheckStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CheckStatement() (localctx ICheckStatementContext) {
	localctx = NewCheckStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, LiteParserRULE_checkStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1099)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1065)
			p.Match(LiteParserBang)
		}
		{
			p.SetState(1066)
			p.Left_brace()
		}
		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1067)
					p.FunctionSupportStatement()
				}

			}
			p.SetState(1072)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())
		}
		{
			p.SetState(1073)
			p.Right_brace()
		}
		p.SetState(1077)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
			{
				p.SetState(1074)
				p.CheckErrorStatement()
			}

			p.SetState(1079)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1080)
			p.CheckFinallyStatment()
		}
		{
			p.SetState(1081)
			p.End()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1083)
			p.Match(LiteParserBang)
		}
		{
			p.SetState(1084)
			p.Left_brace()
		}
		p.SetState(1088)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1085)
					p.FunctionSupportStatement()
				}

			}
			p.SetState(1090)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())
		}
		{
			p.SetState(1091)
			p.Right_brace()
		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
			{
				p.SetState(1092)
				p.CheckErrorStatement()
			}

			p.SetState(1095)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1097)
			p.End()
		}

	}

	return localctx
}

// IUsingStatementContext is an interface to support dynamic dispatch.
type IUsingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsingStatementContext differentiates from other interfaces.
	IsUsingStatementContext()
}

type UsingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingStatementContext() *UsingStatementContext {
	var p = new(UsingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_usingStatement
	return p
}

func (*UsingStatementContext) IsUsingStatementContext() {}

func NewUsingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingStatementContext {
	var p = new(UsingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_usingStatement

	return p
}

func (s *UsingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingStatementContext) Bang() antlr.TerminalNode {
	return s.GetToken(LiteParserBang, 0)
}

func (s *UsingStatementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *UsingStatementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UsingStatementContext) Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual, 0)
}

func (s *UsingStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *UsingStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *UsingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitUsingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) UsingStatement() (localctx IUsingStatementContext) {
	localctx = NewUsingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, LiteParserRULE_usingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1101)
		p.Match(LiteParserBang)
	}
	{
		p.SetState(1102)
		p.expression(0)
	}
	p.SetState(1104)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(LiteParserLess-38))|(1<<(LiteParserLeft_Paren-38))|(1<<(LiteParserLeft_Brack-38))|(1<<(LiteParserQuestion-38))|(1<<(LiteParserBang-38))|(1<<(LiteParserTypeI8-38))|(1<<(LiteParserTypeU8-38))|(1<<(LiteParserTypeI16-38))|(1<<(LiteParserTypeU16-38))|(1<<(LiteParserTypeI32-38))|(1<<(LiteParserTypeU32-38))|(1<<(LiteParserTypeI64-38))|(1<<(LiteParserTypeU64-38)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(LiteParserTypeF32-70))|(1<<(LiteParserTypeF64-70))|(1<<(LiteParserTypeChr-70))|(1<<(LiteParserTypeStr-70))|(1<<(LiteParserTypeBool-70))|(1<<(LiteParserTypeInt-70))|(1<<(LiteParserTypeNum-70))|(1<<(LiteParserTypeByte-70))|(1<<(LiteParserTypeAny-70))|(1<<(LiteParserIDPrivate-70))|(1<<(LiteParserIDPublic-70)))) != 0) {
		{
			p.SetState(1103)
			p.TypeType()
		}

	}
	{
		p.SetState(1106)
		p.Match(LiteParserEqual)
	}
	{
		p.SetState(1107)
		p.expression(0)
	}
	{
		p.SetState(1108)
		p.End()
	}

	return localctx
}

// ICheckErrorStatementContext is an interface to support dynamic dispatch.
type ICheckErrorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCheckErrorStatementContext differentiates from other interfaces.
	IsCheckErrorStatementContext()
}

type CheckErrorStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckErrorStatementContext() *CheckErrorStatementContext {
	var p = new(CheckErrorStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_checkErrorStatement
	return p
}

func (*CheckErrorStatementContext) IsCheckErrorStatementContext() {}

func NewCheckErrorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckErrorStatementContext {
	var p = new(CheckErrorStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_checkErrorStatement

	return p
}

func (s *CheckErrorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckErrorStatementContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *CheckErrorStatementContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *CheckErrorStatementContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *CheckErrorStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *CheckErrorStatementContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *CheckErrorStatementContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *CheckErrorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckErrorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckErrorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCheckErrorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CheckErrorStatement() (localctx ICheckErrorStatementContext) {
	localctx = NewCheckErrorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, LiteParserRULE_checkErrorStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1114)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1110)
			p.Id()
		}

	case 2:
		{
			p.SetState(1111)
			p.Id()
		}
		{
			p.SetState(1112)
			p.TypeType()
		}

	}
	{
		p.SetState(1116)
		p.Left_brace()
	}
	p.SetState(1120)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1117)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(1122)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())
	}
	{
		p.SetState(1123)
		p.Right_brace()
	}

	return localctx
}

// ICheckFinallyStatmentContext is an interface to support dynamic dispatch.
type ICheckFinallyStatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCheckFinallyStatmentContext differentiates from other interfaces.
	IsCheckFinallyStatmentContext()
}

type CheckFinallyStatmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckFinallyStatmentContext() *CheckFinallyStatmentContext {
	var p = new(CheckFinallyStatmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_checkFinallyStatment
	return p
}

func (*CheckFinallyStatmentContext) IsCheckFinallyStatmentContext() {}

func NewCheckFinallyStatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckFinallyStatmentContext {
	var p = new(CheckFinallyStatmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_checkFinallyStatment

	return p
}

func (s *CheckFinallyStatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckFinallyStatmentContext) Discard() antlr.TerminalNode {
	return s.GetToken(LiteParserDiscard, 0)
}

func (s *CheckFinallyStatmentContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *CheckFinallyStatmentContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *CheckFinallyStatmentContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *CheckFinallyStatmentContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *CheckFinallyStatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckFinallyStatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckFinallyStatmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCheckFinallyStatment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CheckFinallyStatment() (localctx ICheckFinallyStatmentContext) {
	localctx = NewCheckFinallyStatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, LiteParserRULE_checkFinallyStatment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1125)
		p.Match(LiteParserDiscard)
	}
	{
		p.SetState(1126)
		p.Left_brace()
	}
	p.SetState(1130)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1127)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(1132)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())
	}
	{
		p.SetState(1133)
		p.Right_brace()
	}

	return localctx
}

// IReportStatementContext is an interface to support dynamic dispatch.
type IReportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportStatementContext differentiates from other interfaces.
	IsReportStatementContext()
}

type ReportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportStatementContext() *ReportStatementContext {
	var p = new(ReportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_reportStatement
	return p
}

func (*ReportStatementContext) IsReportStatementContext() {}

func NewReportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportStatementContext {
	var p = new(ReportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_reportStatement

	return p
}

func (s *ReportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportStatementContext) Bang() antlr.TerminalNode {
	return s.GetToken(LiteParserBang, 0)
}

func (s *ReportStatementContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *ReportStatementContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *ReportStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ReportStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitReportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ReportStatement() (localctx IReportStatementContext) {
	localctx = NewReportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, LiteParserRULE_reportStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		p.Match(LiteParserBang)
	}
	{
		p.SetState(1136)
		p.Left_paren()
	}
	p.SetState(1138)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
		{
			p.SetState(1137)
			p.expression(0)
		}

	}
	{
		p.SetState(1140)
		p.Right_paren()
	}
	{
		p.SetState(1141)
		p.End()
	}

	return localctx
}

// IIteratorStatementContext is an interface to support dynamic dispatch.
type IIteratorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsIteratorStatementContext differentiates from other interfaces.
	IsIteratorStatementContext()
}

type IteratorStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyIteratorStatementContext() *IteratorStatementContext {
	var p = new(IteratorStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_iteratorStatement
	return p
}

func (*IteratorStatementContext) IsIteratorStatementContext() {}

func NewIteratorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IteratorStatementContext {
	var p = new(IteratorStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_iteratorStatement

	return p
}

func (s *IteratorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IteratorStatementContext) GetOp() antlr.Token { return s.op }

func (s *IteratorStatementContext) SetOp(v antlr.Token) { s.op = v }

func (s *IteratorStatementContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *IteratorStatementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *IteratorStatementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IteratorStatementContext) More() IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *IteratorStatementContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *IteratorStatementContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *IteratorStatementContext) Less_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserLess_Equal, 0)
}

func (s *IteratorStatementContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *IteratorStatementContext) Greater_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater_Equal, 0)
}

func (s *IteratorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IteratorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitIteratorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) IteratorStatement() (localctx IIteratorStatementContext) {
	localctx = NewIteratorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, LiteParserRULE_iteratorStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1143)
			p.Match(LiteParserLeft_Brack)
		}
		{
			p.SetState(1144)
			p.expression(0)
		}
		{
			p.SetState(1145)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IteratorStatementContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(LiteParserLess_Equal-25))|(1<<(LiteParserGreater_Equal-25))|(1<<(LiteParserLess-25))|(1<<(LiteParserGreater-25)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IteratorStatementContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1146)
			p.expression(0)
		}
		{
			p.SetState(1147)
			p.More()
		}
		{
			p.SetState(1148)
			p.expression(0)
		}
		{
			p.SetState(1149)
			p.Match(LiteParserRight_Brack)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1151)
			p.Match(LiteParserLeft_Brack)
		}
		{
			p.SetState(1152)
			p.expression(0)
		}
		{
			p.SetState(1153)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IteratorStatementContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(LiteParserLess_Equal-25))|(1<<(LiteParserGreater_Equal-25))|(1<<(LiteParserLess-25))|(1<<(LiteParserGreater-25)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IteratorStatementContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1154)
			p.expression(0)
		}
		{
			p.SetState(1155)
			p.Match(LiteParserRight_Brack)
		}

	}

	return localctx
}

// IVariableStatementContext is an interface to support dynamic dispatch.
type IVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableStatementContext differentiates from other interfaces.
	IsVariableStatementContext()
}

type VariableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableStatementContext() *VariableStatementContext {
	var p = new(VariableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_variableStatement
	return p
}

func (*VariableStatementContext) IsVariableStatementContext() {}

func NewVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableStatementContext {
	var p = new(VariableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_variableStatement

	return p
}

func (s *VariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableStatementContext) IdExpression() IIdExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdExpressionContext)
}

func (s *VariableStatementContext) Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual, 0)
}

func (s *VariableStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *VariableStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *VariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitVariableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) VariableStatement() (localctx IVariableStatementContext) {
	localctx = NewVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, LiteParserRULE_variableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1159)
		p.IdExpression()
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(LiteParserLess-38))|(1<<(LiteParserLeft_Paren-38))|(1<<(LiteParserLeft_Brack-38))|(1<<(LiteParserQuestion-38))|(1<<(LiteParserBang-38))|(1<<(LiteParserTypeI8-38))|(1<<(LiteParserTypeU8-38))|(1<<(LiteParserTypeI16-38))|(1<<(LiteParserTypeU16-38))|(1<<(LiteParserTypeI32-38))|(1<<(LiteParserTypeU32-38))|(1<<(LiteParserTypeI64-38))|(1<<(LiteParserTypeU64-38)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(LiteParserTypeF32-70))|(1<<(LiteParserTypeF64-70))|(1<<(LiteParserTypeChr-70))|(1<<(LiteParserTypeStr-70))|(1<<(LiteParserTypeBool-70))|(1<<(LiteParserTypeInt-70))|(1<<(LiteParserTypeNum-70))|(1<<(LiteParserTypeByte-70))|(1<<(LiteParserTypeAny-70))|(1<<(LiteParserIDPrivate-70))|(1<<(LiteParserIDPublic-70)))) != 0) {
		{
			p.SetState(1160)
			p.TypeType()
		}

	}
	{
		p.SetState(1163)
		p.Match(LiteParserEqual)
	}
	{
		p.SetState(1164)
		p.expression(0)
	}
	{
		p.SetState(1165)
		p.End()
	}

	return localctx
}

// IVariableDeclaredStatementContext is an interface to support dynamic dispatch.
type IVariableDeclaredStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaredStatementContext differentiates from other interfaces.
	IsVariableDeclaredStatementContext()
}

type VariableDeclaredStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaredStatementContext() *VariableDeclaredStatementContext {
	var p = new(VariableDeclaredStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_variableDeclaredStatement
	return p
}

func (*VariableDeclaredStatementContext) IsVariableDeclaredStatementContext() {}

func NewVariableDeclaredStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaredStatementContext {
	var p = new(VariableDeclaredStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_variableDeclaredStatement

	return p
}

func (s *VariableDeclaredStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaredStatementContext) IdExpression() IIdExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdExpressionContext)
}

func (s *VariableDeclaredStatementContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *VariableDeclaredStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *VariableDeclaredStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaredStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaredStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitVariableDeclaredStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) VariableDeclaredStatement() (localctx IVariableDeclaredStatementContext) {
	localctx = NewVariableDeclaredStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, LiteParserRULE_variableDeclaredStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.IdExpression()
	}
	{
		p.SetState(1168)
		p.TypeType()
	}
	{
		p.SetState(1169)
		p.End()
	}

	return localctx
}

// IChannelAssignStatementContext is an interface to support dynamic dispatch.
type IChannelAssignStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChannelAssignStatementContext differentiates from other interfaces.
	IsChannelAssignStatementContext()
}

type ChannelAssignStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelAssignStatementContext() *ChannelAssignStatementContext {
	var p = new(ChannelAssignStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_channelAssignStatement
	return p
}

func (*ChannelAssignStatementContext) IsChannelAssignStatementContext() {}

func NewChannelAssignStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelAssignStatementContext {
	var p = new(ChannelAssignStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_channelAssignStatement

	return p
}

func (s *ChannelAssignStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelAssignStatementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ChannelAssignStatementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ChannelAssignStatementContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *ChannelAssignStatementContext) Left_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Arrow, 0)
}

func (s *ChannelAssignStatementContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *ChannelAssignStatementContext) Assign() IAssignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignContext)
}

func (s *ChannelAssignStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ChannelAssignStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelAssignStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelAssignStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitChannelAssignStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ChannelAssignStatement() (localctx IChannelAssignStatementContext) {
	localctx = NewChannelAssignStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, LiteParserRULE_channelAssignStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1171)
		p.expression(0)
	}
	{
		p.SetState(1172)
		p.Match(LiteParserLeft_Brack)
	}
	{
		p.SetState(1173)
		p.Match(LiteParserLeft_Arrow)
	}
	{
		p.SetState(1174)
		p.Match(LiteParserRight_Brack)
	}
	{
		p.SetState(1175)
		p.Assign()
	}
	{
		p.SetState(1176)
		p.expression(0)
	}
	{
		p.SetState(1177)
		p.End()
	}

	return localctx
}

// IAssignStatementContext is an interface to support dynamic dispatch.
type IAssignStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignStatementContext differentiates from other interfaces.
	IsAssignStatementContext()
}

type AssignStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignStatementContext() *AssignStatementContext {
	var p = new(AssignStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_assignStatement
	return p
}

func (*AssignStatementContext) IsAssignStatementContext() {}

func NewAssignStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignStatementContext {
	var p = new(AssignStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_assignStatement

	return p
}

func (s *AssignStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignStatementContext) AllTupleExpression() []ITupleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITupleExpressionContext)(nil)).Elem())
	var tst = make([]ITupleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITupleExpressionContext)
		}
	}

	return tst
}

func (s *AssignStatementContext) TupleExpression(i int) ITupleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITupleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITupleExpressionContext)
}

func (s *AssignStatementContext) Assign() IAssignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignContext)
}

func (s *AssignStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *AssignStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitAssignStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) AssignStatement() (localctx IAssignStatementContext) {
	localctx = NewAssignStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, LiteParserRULE_assignStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1179)
		p.TupleExpression()
	}
	{
		p.SetState(1180)
		p.Assign()
	}
	{
		p.SetState(1181)
		p.TupleExpression()
	}
	{
		p.SetState(1182)
		p.End()
	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) End() IEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, LiteParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1184)
		p.expression(0)
	}
	{
		p.SetState(1185)
		p.End()
	}

	return localctx
}

// IIdExpressionContext is an interface to support dynamic dispatch.
type IIdExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdExpressionContext differentiates from other interfaces.
	IsIdExpressionContext()
}

type IdExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdExpressionContext() *IdExpressionContext {
	var p = new(IdExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_idExpression
	return p
}

func (*IdExpressionContext) IsIdExpressionContext() {}

func NewIdExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdExpressionContext {
	var p = new(IdExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_idExpression

	return p
}

func (s *IdExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdExpressionContext) AllIdExprItem() []IIdExprItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdExprItemContext)(nil)).Elem())
	var tst = make([]IIdExprItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdExprItemContext)
		}
	}

	return tst
}

func (s *IdExpressionContext) IdExprItem(i int) IIdExprItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdExprItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdExprItemContext)
}

func (s *IdExpressionContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *IdExpressionContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *IdExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitIdExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) IdExpression() (localctx IIdExpressionContext) {
	localctx = NewIdExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, LiteParserRULE_idExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1187)
		p.IdExprItem()
	}
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1188)
			p.More()
		}
		{
			p.SetState(1189)
			p.IdExprItem()
		}

		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdExprItemContext is an interface to support dynamic dispatch.
type IIdExprItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdExprItemContext differentiates from other interfaces.
	IsIdExprItemContext()
}

type IdExprItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdExprItemContext() *IdExprItemContext {
	var p = new(IdExprItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_idExprItem
	return p
}

func (*IdExprItemContext) IsIdExprItemContext() {}

func NewIdExprItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdExprItemContext {
	var p = new(IdExprItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_idExprItem

	return p
}

func (s *IdExprItemContext) GetParser() antlr.Parser { return s.parser }

func (s *IdExprItemContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *IdExprItemContext) Discard() antlr.TerminalNode {
	return s.GetToken(LiteParserDiscard, 0)
}

func (s *IdExprItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdExprItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdExprItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitIdExprItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) IdExprItem() (localctx IIdExprItemContext) {
	localctx = NewIdExprItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, LiteParserRULE_idExprItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1198)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserLinqFrom, LiteParserLinqBy, LiteParserLinqSelect, LiteParserLinqWhere, LiteParserLinqGroup, LiteParserLinqInto, LiteParserLinqOrderby, LiteParserLinqJoin, LiteParserLinqLet, LiteParserLinqIn, LiteParserLinqOn, LiteParserLinqEquals, LiteParserLinqAscending, LiteParserLinqDescending, LiteParserTypeI8, LiteParserTypeU8, LiteParserTypeI16, LiteParserTypeU16, LiteParserTypeI32, LiteParserTypeU32, LiteParserTypeI64, LiteParserTypeU64, LiteParserTypeF32, LiteParserTypeF64, LiteParserTypeChr, LiteParserTypeStr, LiteParserTypeBool, LiteParserTypeInt, LiteParserTypeNum, LiteParserTypeByte, LiteParserTypeAny, LiteParserIDPrivate, LiteParserIDPublic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1196)
			p.Id()
		}

	case LiteParserDiscard:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1197)
			p.Match(LiteParserDiscard)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITupleExpressionContext is an interface to support dynamic dispatch.
type ITupleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTupleExpressionContext differentiates from other interfaces.
	IsTupleExpressionContext()
}

type TupleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleExpressionContext() *TupleExpressionContext {
	var p = new(TupleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_tupleExpression
	return p
}

func (*TupleExpressionContext) IsTupleExpressionContext() {}

func NewTupleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleExpressionContext {
	var p = new(TupleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_tupleExpression

	return p
}

func (s *TupleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *TupleExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleExpressionContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *TupleExpressionContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *TupleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTupleExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TupleExpression() (localctx ITupleExpressionContext) {
	localctx = NewTupleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, LiteParserRULE_tupleExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1200)
		p.expression(0)
	}
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1201)
			p.More()
		}
		{
			p.SetState(1202)
			p.expression(0)
		}

		p.SetState(1208)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) GetT() antlr.Token { return s.t }

func (s *PrimaryExpressionContext) SetT(v antlr.Token) { s.t = v }

func (s *PrimaryExpressionContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *PrimaryExpressionContext) TemplateCall() ITemplateCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateCallContext)
}

func (s *PrimaryExpressionContext) Discard() antlr.TerminalNode {
	return s.GetToken(LiteParserDiscard, 0)
}

func (s *PrimaryExpressionContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *PrimaryExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryExpressionContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *PrimaryExpressionContext) DataStatement() IDataStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataStatementContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, LiteParserRULE_primaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1219)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserLinqFrom, LiteParserLinqBy, LiteParserLinqSelect, LiteParserLinqWhere, LiteParserLinqGroup, LiteParserLinqInto, LiteParserLinqOrderby, LiteParserLinqJoin, LiteParserLinqLet, LiteParserLinqIn, LiteParserLinqOn, LiteParserLinqEquals, LiteParserLinqAscending, LiteParserLinqDescending, LiteParserTypeI8, LiteParserTypeU8, LiteParserTypeI16, LiteParserTypeU16, LiteParserTypeI32, LiteParserTypeU32, LiteParserTypeI64, LiteParserTypeU64, LiteParserTypeF32, LiteParserTypeF64, LiteParserTypeChr, LiteParserTypeStr, LiteParserTypeBool, LiteParserTypeInt, LiteParserTypeNum, LiteParserTypeByte, LiteParserTypeAny, LiteParserIDPrivate, LiteParserIDPublic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1209)
			p.Id()
		}
		p.SetState(1211)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1210)
				p.TemplateCall()
			}

		}

	case LiteParserDiscard:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1213)

			var _m = p.Match(LiteParserDiscard)

			localctx.(*PrimaryExpressionContext).t = _m
		}

	case LiteParserLeft_Paren:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1214)
			p.Left_paren()
		}
		{
			p.SetState(1215)
			p.expression(0)
		}
		{
			p.SetState(1216)
			p.Right_paren()
		}

	case LiteParserNilLiteral, LiteParserTrueLiteral, LiteParserFalseLiteral, LiteParserUndefinedLiteral, LiteParserNumberLiteral, LiteParserTextLiteral, LiteParserCharLiteral:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1218)
			p.DataStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExpressionContext) Linq() ILinqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinqContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinqContext)
}

func (s *ExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ExpressionContext) CallNew() ICallNewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallNewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallNewContext)
}

func (s *ExpressionContext) CallPkg() ICallPkgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallPkgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallPkgContext)
}

func (s *ExpressionContext) GetType() IGetTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetTypeContext)
}

func (s *ExpressionContext) CallAwait() ICallAwaitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallAwaitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallAwaitContext)
}

func (s *ExpressionContext) List() IListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListContext)
}

func (s *ExpressionContext) Set() ISetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetContext)
}

func (s *ExpressionContext) Dictionary() IDictionaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryContext)
}

func (s *ExpressionContext) Lambda() ILambdaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaContext)
}

func (s *ExpressionContext) FunctionExpression() IFunctionExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionExpressionContext)
}

func (s *ExpressionContext) PkgAnonymous() IPkgAnonymousContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPkgAnonymousContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPkgAnonymousContext)
}

func (s *ExpressionContext) PlusMinus() IPlusMinusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPlusMinusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPlusMinusContext)
}

func (s *ExpressionContext) BitwiseNotExpression() IBitwiseNotExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseNotExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitwiseNotExpressionContext)
}

func (s *ExpressionContext) Negate() INegateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INegateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INegateContext)
}

func (s *ExpressionContext) StringExpression() IStringExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringExpressionContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) Bitwise() IBitwiseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitwiseContext)
}

func (s *ExpressionContext) Judge() IJudgeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJudgeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJudgeContext)
}

func (s *ExpressionContext) Add() IAddContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddContext)
}

func (s *ExpressionContext) Mul() IMulContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMulContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMulContext)
}

func (s *ExpressionContext) Pow() IPowContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowContext)
}

func (s *ExpressionContext) Bang() antlr.TerminalNode {
	return s.GetToken(LiteParserBang, 0)
}

func (s *ExpressionContext) Question() antlr.TerminalNode {
	return s.GetToken(LiteParserQuestion, 0)
}

func (s *ExpressionContext) Left_Flow() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Flow, 0)
}

func (s *ExpressionContext) TypeConversion() ITypeConversionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeConversionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeConversionContext)
}

func (s *ExpressionContext) CallFunc() ICallFuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallFuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallFuncContext)
}

func (s *ExpressionContext) CallChannel() ICallChannelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallChannelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallChannelContext)
}

func (s *ExpressionContext) CallElement() ICallElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallElementContext)
}

func (s *ExpressionContext) CallExpression() ICallExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallExpressionContext)
}

func (s *ExpressionContext) JudgeType() IJudgeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJudgeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJudgeTypeContext)
}

func (s *ExpressionContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *ExpressionContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ExpressionContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *LiteParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 136
	p.EnterRecursionRule(localctx, 136, LiteParserRULE_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1238)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1222)
			p.Linq()
		}

	case 2:
		{
			p.SetState(1223)
			p.PrimaryExpression()
		}

	case 3:
		{
			p.SetState(1224)
			p.CallNew()
		}

	case 4:
		{
			p.SetState(1225)
			p.CallPkg()
		}

	case 5:
		{
			p.SetState(1226)
			p.GetType()
		}

	case 6:
		{
			p.SetState(1227)
			p.CallAwait()
		}

	case 7:
		{
			p.SetState(1228)
			p.List()
		}

	case 8:
		{
			p.SetState(1229)
			p.Set()
		}

	case 9:
		{
			p.SetState(1230)
			p.Dictionary()
		}

	case 10:
		{
			p.SetState(1231)
			p.Lambda()
		}

	case 11:
		{
			p.SetState(1232)
			p.FunctionExpression()
		}

	case 12:
		{
			p.SetState(1233)
			p.PkgAnonymous()
		}

	case 13:
		{
			p.SetState(1234)
			p.PlusMinus()
		}

	case 14:
		{
			p.SetState(1235)
			p.BitwiseNotExpression()
		}

	case 15:
		{
			p.SetState(1236)
			p.Negate()
		}

	case 16:
		{
			p.SetState(1237)
			p.StringExpression()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1284)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1282)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1240)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(1241)
					p.Bitwise()
				}
				{
					p.SetState(1242)
					p.expression(7)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1244)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1245)
					p.Judge()
				}
				{
					p.SetState(1246)
					p.expression(6)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1248)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(1249)
					p.Add()
				}
				{
					p.SetState(1250)
					p.expression(5)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1252)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1253)
					p.Mul()
				}
				{
					p.SetState(1254)
					p.expression(4)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1256)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1257)
					p.Pow()
				}
				{
					p.SetState(1258)
					p.expression(3)
				}

			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1260)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(1261)

					var _m = p.Match(LiteParserBang)

					localctx.(*ExpressionContext).op = _m
				}

			case 7:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1262)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(1263)

					var _m = p.Match(LiteParserQuestion)

					localctx.(*ExpressionContext).op = _m
				}

			case 8:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1264)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(1265)

					var _m = p.Match(LiteParserLeft_Flow)

					localctx.(*ExpressionContext).op = _m
				}

			case 9:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1266)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1267)
					p.TypeConversion()
				}

			case 10:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1268)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(1269)
					p.CallFunc()
				}

			case 11:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1270)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1271)
					p.CallChannel()
				}

			case 12:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1272)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1273)
					p.CallElement()
				}

			case 13:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1274)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1275)
					p.CallExpression()
				}

			case 14:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, LiteParserRULE_expression)
				p.SetState(1276)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1277)
					p.JudgeType()
				}
				{
					p.SetState(1278)
					p.Match(LiteParserLess)
				}
				{
					p.SetState(1279)
					p.TypeType()
				}
				{
					p.SetState(1280)
					p.Match(LiteParserGreater)
				}

			}

		}
		p.SetState(1286)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())
	}

	return localctx
}

// ICallExpressionContext is an interface to support dynamic dispatch.
type ICallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallExpressionContext differentiates from other interfaces.
	IsCallExpressionContext()
}

type CallExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallExpressionContext() *CallExpressionContext {
	var p = new(CallExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_callExpression
	return p
}

func (*CallExpressionContext) IsCallExpressionContext() {}

func NewCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallExpressionContext {
	var p = new(CallExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_callExpression

	return p
}

func (s *CallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CallExpressionContext) Call() ICallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallContext)
}

func (s *CallExpressionContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *CallExpressionContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *CallExpressionContext) TemplateCall() ITemplateCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateCallContext)
}

func (s *CallExpressionContext) CallFunc() ICallFuncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallFuncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallFuncContext)
}

func (s *CallExpressionContext) CallChannel() ICallChannelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallChannelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallChannelContext)
}

func (s *CallExpressionContext) CallElement() ICallElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallElementContext)
}

func (s *CallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CallExpression() (localctx ICallExpressionContext) {
	localctx = NewCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, LiteParserRULE_callExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1287)
		p.Call()
	}
	p.SetState(1289)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1288)
			p.Match(LiteParserNew_Line)
		}

	}
	{
		p.SetState(1291)
		p.Id()
	}
	p.SetState(1293)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1292)
			p.TemplateCall()
		}

	}
	p.SetState(1298)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1295)
			p.CallFunc()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1296)
			p.CallChannel()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(1297)
			p.CallElement()
		}

	}

	return localctx
}

// ITupleContext is an interface to support dynamic dispatch.
type ITupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTupleContext differentiates from other interfaces.
	IsTupleContext()
}

type TupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleContext() *TupleContext {
	var p = new(TupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_tuple
	return p
}

func (*TupleContext) IsTupleContext() {}

func NewTupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleContext {
	var p = new(TupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_tuple

	return p
}

func (s *TupleContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *TupleContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *TupleContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *TupleContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *TupleContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *TupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTuple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Tuple() (localctx ITupleContext) {
	localctx = NewTupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, LiteParserRULE_tuple)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1300)
		p.Left_paren()
	}
	p.SetState(1310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
		{
			p.SetState(1301)
			p.expression(0)
		}
		p.SetState(1307)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == LiteParserComma {
			{
				p.SetState(1302)
				p.More()
			}
			{
				p.SetState(1303)
				p.expression(0)
			}

			p.SetState(1309)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1312)
		p.Right_paren()
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *ExpressionListContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, LiteParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1314)
		p.expression(0)
	}
	p.SetState(1320)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1315)
			p.More()
		}
		{
			p.SetState(1316)
			p.expression(0)
		}

		p.SetState(1322)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAnnotationSupportContext is an interface to support dynamic dispatch.
type IAnnotationSupportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationSupportContext differentiates from other interfaces.
	IsAnnotationSupportContext()
}

type AnnotationSupportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationSupportContext() *AnnotationSupportContext {
	var p = new(AnnotationSupportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_annotationSupport
	return p
}

func (*AnnotationSupportContext) IsAnnotationSupportContext() {}

func NewAnnotationSupportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationSupportContext {
	var p = new(AnnotationSupportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_annotationSupport

	return p
}

func (s *AnnotationSupportContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationSupportContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationSupportContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *AnnotationSupportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationSupportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationSupportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitAnnotationSupport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) AnnotationSupport() (localctx IAnnotationSupportContext) {
	localctx = NewAnnotationSupportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, LiteParserRULE_annotationSupport)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1323)
		p.Annotation()
	}
	p.SetState(1325)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1324)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *AnnotationContext) AnnotationList() IAnnotationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationListContext)
}

func (s *AnnotationContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *AnnotationContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *AnnotationContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, LiteParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1327)
		p.Match(LiteParserLeft_Brack)
	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1328)
			p.Id()
		}
		{
			p.SetState(1329)
			p.Match(LiteParserRight_Arrow)
		}

	}
	{
		p.SetState(1333)
		p.AnnotationList()
	}
	{
		p.SetState(1334)
		p.Match(LiteParserRight_Brack)
	}

	return localctx
}

// IAnnotationListContext is an interface to support dynamic dispatch.
type IAnnotationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationListContext differentiates from other interfaces.
	IsAnnotationListContext()
}

type AnnotationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationListContext() *AnnotationListContext {
	var p = new(AnnotationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_annotationList
	return p
}

func (*AnnotationListContext) IsAnnotationListContext() {}

func NewAnnotationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationListContext {
	var p = new(AnnotationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_annotationList

	return p
}

func (s *AnnotationListContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationListContext) AllAnnotationItem() []IAnnotationItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationItemContext)(nil)).Elem())
	var tst = make([]IAnnotationItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationItemContext)
		}
	}

	return tst
}

func (s *AnnotationListContext) AnnotationItem(i int) IAnnotationItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationItemContext)
}

func (s *AnnotationListContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *AnnotationListContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *AnnotationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitAnnotationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) AnnotationList() (localctx IAnnotationListContext) {
	localctx = NewAnnotationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, LiteParserRULE_annotationList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1336)
		p.AnnotationItem()
	}
	p.SetState(1342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1337)
			p.More()
		}
		{
			p.SetState(1338)
			p.AnnotationItem()
		}

		p.SetState(1344)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAnnotationItemContext is an interface to support dynamic dispatch.
type IAnnotationItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationItemContext differentiates from other interfaces.
	IsAnnotationItemContext()
}

type AnnotationItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationItemContext() *AnnotationItemContext {
	var p = new(AnnotationItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_annotationItem
	return p
}

func (*AnnotationItemContext) IsAnnotationItemContext() {}

func NewAnnotationItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationItemContext {
	var p = new(AnnotationItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_annotationItem

	return p
}

func (s *AnnotationItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationItemContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *AnnotationItemContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *AnnotationItemContext) AllAnnotationAssign() []IAnnotationAssignContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationAssignContext)(nil)).Elem())
	var tst = make([]IAnnotationAssignContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationAssignContext)
		}
	}

	return tst
}

func (s *AnnotationItemContext) AnnotationAssign(i int) IAnnotationAssignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationAssignContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationAssignContext)
}

func (s *AnnotationItemContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *AnnotationItemContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *AnnotationItemContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *AnnotationItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitAnnotationItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) AnnotationItem() (localctx IAnnotationItemContext) {
	localctx = NewAnnotationItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, LiteParserRULE_annotationItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1345)
		p.Id()
	}
	p.SetState(1358)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserLeft_Paren {
		{
			p.SetState(1346)
			p.Left_paren()
		}
		{
			p.SetState(1347)
			p.AnnotationAssign()
		}
		p.SetState(1353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == LiteParserComma {
			{
				p.SetState(1348)
				p.More()
			}
			{
				p.SetState(1349)
				p.AnnotationAssign()
			}

			p.SetState(1355)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1356)
			p.Right_paren()
		}

	}

	return localctx
}

// IAnnotationAssignContext is an interface to support dynamic dispatch.
type IAnnotationAssignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationAssignContext differentiates from other interfaces.
	IsAnnotationAssignContext()
}

type AnnotationAssignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationAssignContext() *AnnotationAssignContext {
	var p = new(AnnotationAssignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_annotationAssign
	return p
}

func (*AnnotationAssignContext) IsAnnotationAssignContext() {}

func NewAnnotationAssignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationAssignContext {
	var p = new(AnnotationAssignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_annotationAssign

	return p
}

func (s *AnnotationAssignContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationAssignContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AnnotationAssignContext) Id() IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *AnnotationAssignContext) Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual, 0)
}

func (s *AnnotationAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationAssignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitAnnotationAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) AnnotationAssign() (localctx IAnnotationAssignContext) {
	localctx = NewAnnotationAssignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, LiteParserRULE_annotationAssign)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1363)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1360)
			p.Id()
		}
		{
			p.SetState(1361)
			p.Match(LiteParserEqual)
		}

	}
	{
		p.SetState(1365)
		p.expression(0)
	}

	return localctx
}

// ICallFuncContext is an interface to support dynamic dispatch.
type ICallFuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallFuncContext differentiates from other interfaces.
	IsCallFuncContext()
}

type CallFuncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallFuncContext() *CallFuncContext {
	var p = new(CallFuncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_callFunc
	return p
}

func (*CallFuncContext) IsCallFuncContext() {}

func NewCallFuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallFuncContext {
	var p = new(CallFuncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_callFunc

	return p
}

func (s *CallFuncContext) GetParser() antlr.Parser { return s.parser }

func (s *CallFuncContext) Tuple() ITupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITupleContext)
}

func (s *CallFuncContext) Lambda() ILambdaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaContext)
}

func (s *CallFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallFuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCallFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CallFunc() (localctx ICallFuncContext) {
	localctx = NewCallFuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, LiteParserRULE_callFunc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserLeft_Paren:
		{
			p.SetState(1367)
			p.Tuple()
		}

	case LiteParserLeft_Brace:
		{
			p.SetState(1368)
			p.Lambda()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallChannelContext is an interface to support dynamic dispatch.
type ICallChannelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallChannelContext differentiates from other interfaces.
	IsCallChannelContext()
}

type CallChannelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallChannelContext() *CallChannelContext {
	var p = new(CallChannelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_callChannel
	return p
}

func (*CallChannelContext) IsCallChannelContext() {}

func NewCallChannelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallChannelContext {
	var p = new(CallChannelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_callChannel

	return p
}

func (s *CallChannelContext) GetParser() antlr.Parser { return s.parser }

func (s *CallChannelContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *CallChannelContext) Left_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Arrow, 0)
}

func (s *CallChannelContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *CallChannelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallChannelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallChannelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCallChannel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CallChannel() (localctx ICallChannelContext) {
	localctx = NewCallChannelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, LiteParserRULE_callChannel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1371)
		p.Match(LiteParserLeft_Brack)
	}
	{
		p.SetState(1372)
		p.Match(LiteParserLeft_Arrow)
	}
	{
		p.SetState(1373)
		p.Match(LiteParserRight_Brack)
	}

	return localctx
}

// ICallElementContext is an interface to support dynamic dispatch.
type ICallElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallElementContext differentiates from other interfaces.
	IsCallElementContext()
}

type CallElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallElementContext() *CallElementContext {
	var p = new(CallElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_callElement
	return p
}

func (*CallElementContext) IsCallElementContext() {}

func NewCallElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallElementContext {
	var p = new(CallElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_callElement

	return p
}

func (s *CallElementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallElementContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *CallElementContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *CallElementContext) Slice() ISliceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISliceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISliceContext)
}

func (s *CallElementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CallElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCallElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CallElement() (localctx ICallElementContext) {
	localctx = NewCallElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, LiteParserRULE_callElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1375)
		p.Match(LiteParserLeft_Brack)
	}
	p.SetState(1378)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1376)
			p.Slice()
		}

	case 2:
		{
			p.SetState(1377)
			p.expression(0)
		}

	}
	{
		p.SetState(1380)
		p.Match(LiteParserRight_Brack)
	}

	return localctx
}

// ICallPkgContext is an interface to support dynamic dispatch.
type ICallPkgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallPkgContext differentiates from other interfaces.
	IsCallPkgContext()
}

type CallPkgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallPkgContext() *CallPkgContext {
	var p = new(CallPkgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_callPkg
	return p
}

func (*CallPkgContext) IsCallPkgContext() {}

func NewCallPkgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallPkgContext {
	var p = new(CallPkgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_callPkg

	return p
}

func (s *CallPkgContext) GetParser() antlr.Parser { return s.parser }

func (s *CallPkgContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *CallPkgContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *CallPkgContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *CallPkgContext) PkgAssign() IPkgAssignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPkgAssignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPkgAssignContext)
}

func (s *CallPkgContext) ListAssign() IListAssignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListAssignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListAssignContext)
}

func (s *CallPkgContext) SetAssign() ISetAssignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetAssignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetAssignContext)
}

func (s *CallPkgContext) DictionaryAssign() IDictionaryAssignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryAssignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryAssignContext)
}

func (s *CallPkgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallPkgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallPkgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCallPkg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CallPkg() (localctx ICallPkgContext) {
	localctx = NewCallPkgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, LiteParserRULE_callPkg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1382)
		p.TypeType()
	}
	{
		p.SetState(1383)
		p.Left_brace()
	}
	p.SetState(1388)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1384)
			p.PkgAssign()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1385)
			p.ListAssign()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(1386)
			p.SetAssign()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(1387)
			p.DictionaryAssign()
		}

	}
	{
		p.SetState(1390)
		p.Right_brace()
	}

	return localctx
}

// ICallNewContext is an interface to support dynamic dispatch.
type ICallNewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallNewContext differentiates from other interfaces.
	IsCallNewContext()
}

type CallNewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallNewContext() *CallNewContext {
	var p = new(CallNewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_callNew
	return p
}

func (*CallNewContext) IsCallNewContext() {}

func NewCallNewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallNewContext {
	var p = new(CallNewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_callNew

	return p
}

func (s *CallNewContext) GetParser() antlr.Parser { return s.parser }

func (s *CallNewContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *CallNewContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *CallNewContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *CallNewContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *CallNewContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *CallNewContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *CallNewContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *CallNewContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *CallNewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallNewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallNewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCallNew(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CallNew() (localctx ICallNewContext) {
	localctx = NewCallNewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, LiteParserRULE_callNew)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1392)
		p.Match(LiteParserLess)
	}
	{
		p.SetState(1393)
		p.TypeType()
	}
	{
		p.SetState(1394)
		p.Match(LiteParserGreater)
	}
	{
		p.SetState(1395)
		p.Left_paren()
	}
	p.SetState(1397)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1396)
			p.Match(LiteParserNew_Line)
		}

	}
	p.SetState(1400)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
		{
			p.SetState(1399)
			p.ExpressionList()
		}

	}
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1402)
			p.Match(LiteParserNew_Line)
		}

	}
	{
		p.SetState(1405)
		p.Right_paren()
	}

	return localctx
}

// IGetTypeContext is an interface to support dynamic dispatch.
type IGetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetTypeContext differentiates from other interfaces.
	IsGetTypeContext()
}

type GetTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetTypeContext() *GetTypeContext {
	var p = new(GetTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_getType
	return p
}

func (*GetTypeContext) IsGetTypeContext() {}

func NewGetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetTypeContext {
	var p = new(GetTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_getType

	return p
}

func (s *GetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *GetTypeContext) Question() antlr.TerminalNode {
	return s.GetToken(LiteParserQuestion, 0)
}

func (s *GetTypeContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *GetTypeContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *GetTypeContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *GetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitGetType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) GetType() (localctx IGetTypeContext) {
	localctx = NewGetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, LiteParserRULE_getType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1407)
		p.Match(LiteParserQuestion)
	}
	{
		p.SetState(1408)
		p.Left_paren()
	}
	{
		p.SetState(1409)
		p.TypeType()
	}
	{
		p.SetState(1410)
		p.Right_paren()
	}

	return localctx
}

// ITypeConversionContext is an interface to support dynamic dispatch.
type ITypeConversionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeConversionContext differentiates from other interfaces.
	IsTypeConversionContext()
}

type TypeConversionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConversionContext() *TypeConversionContext {
	var p = new(TypeConversionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeConversion
	return p
}

func (*TypeConversionContext) IsTypeConversionContext() {}

func NewTypeConversionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConversionContext {
	var p = new(TypeConversionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeConversion

	return p
}

func (s *TypeConversionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConversionContext) Dot() antlr.TerminalNode {
	return s.GetToken(LiteParserDot, 0)
}

func (s *TypeConversionContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *TypeConversionContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeConversionContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *TypeConversionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConversionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConversionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeConversion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeConversion() (localctx ITypeConversionContext) {
	localctx = NewTypeConversionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, LiteParserRULE_typeConversion)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1412)
		p.Match(LiteParserDot)
	}
	{
		p.SetState(1413)
		p.Left_paren()
	}
	{
		p.SetState(1414)
		p.TypeType()
	}
	{
		p.SetState(1415)
		p.Right_paren()
	}

	return localctx
}

// IPkgAssignContext is an interface to support dynamic dispatch.
type IPkgAssignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPkgAssignContext differentiates from other interfaces.
	IsPkgAssignContext()
}

type PkgAssignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPkgAssignContext() *PkgAssignContext {
	var p = new(PkgAssignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_pkgAssign
	return p
}

func (*PkgAssignContext) IsPkgAssignContext() {}

func NewPkgAssignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PkgAssignContext {
	var p = new(PkgAssignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_pkgAssign

	return p
}

func (s *PkgAssignContext) GetParser() antlr.Parser { return s.parser }

func (s *PkgAssignContext) AllPkgAssignElement() []IPkgAssignElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPkgAssignElementContext)(nil)).Elem())
	var tst = make([]IPkgAssignElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPkgAssignElementContext)
		}
	}

	return tst
}

func (s *PkgAssignContext) PkgAssignElement(i int) IPkgAssignElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPkgAssignElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPkgAssignElementContext)
}

func (s *PkgAssignContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *PkgAssignContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *PkgAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PkgAssignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PkgAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPkgAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PkgAssign() (localctx IPkgAssignContext) {
	localctx = NewPkgAssignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, LiteParserRULE_pkgAssign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		p.PkgAssignElement()
	}
	p.SetState(1423)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1418)
			p.More()
		}
		{
			p.SetState(1419)
			p.PkgAssignElement()
		}

		p.SetState(1425)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPkgAssignElementContext is an interface to support dynamic dispatch.
type IPkgAssignElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPkgAssignElementContext differentiates from other interfaces.
	IsPkgAssignElementContext()
}

type PkgAssignElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPkgAssignElementContext() *PkgAssignElementContext {
	var p = new(PkgAssignElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_pkgAssignElement
	return p
}

func (*PkgAssignElementContext) IsPkgAssignElementContext() {}

func NewPkgAssignElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PkgAssignElementContext {
	var p = new(PkgAssignElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_pkgAssignElement

	return p
}

func (s *PkgAssignElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PkgAssignElementContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PkgAssignElementContext) Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual, 0)
}

func (s *PkgAssignElementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PkgAssignElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PkgAssignElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PkgAssignElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPkgAssignElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PkgAssignElement() (localctx IPkgAssignElementContext) {
	localctx = NewPkgAssignElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, LiteParserRULE_pkgAssignElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1426)
		p.Name()
	}
	{
		p.SetState(1427)
		p.Match(LiteParserEqual)
	}
	{
		p.SetState(1428)
		p.expression(0)
	}

	return localctx
}

// IListAssignContext is an interface to support dynamic dispatch.
type IListAssignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListAssignContext differentiates from other interfaces.
	IsListAssignContext()
}

type ListAssignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListAssignContext() *ListAssignContext {
	var p = new(ListAssignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_listAssign
	return p
}

func (*ListAssignContext) IsListAssignContext() {}

func NewListAssignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListAssignContext {
	var p = new(ListAssignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_listAssign

	return p
}

func (s *ListAssignContext) GetParser() antlr.Parser { return s.parser }

func (s *ListAssignContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ListAssignContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListAssignContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *ListAssignContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *ListAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListAssignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitListAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) ListAssign() (localctx IListAssignContext) {
	localctx = NewListAssignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, LiteParserRULE_listAssign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1430)
		p.expression(0)
	}
	p.SetState(1436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1431)
			p.More()
		}
		{
			p.SetState(1432)
			p.expression(0)
		}

		p.SetState(1438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISetAssignContext is an interface to support dynamic dispatch.
type ISetAssignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetAssignContext differentiates from other interfaces.
	IsSetAssignContext()
}

type SetAssignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetAssignContext() *SetAssignContext {
	var p = new(SetAssignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_setAssign
	return p
}

func (*SetAssignContext) IsSetAssignContext() {}

func NewSetAssignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAssignContext {
	var p = new(SetAssignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_setAssign

	return p
}

func (s *SetAssignContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAssignContext) AllLeft_Brack() []antlr.TerminalNode {
	return s.GetTokens(LiteParserLeft_Brack)
}

func (s *SetAssignContext) Left_Brack(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, i)
}

func (s *SetAssignContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *SetAssignContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetAssignContext) AllRight_Brack() []antlr.TerminalNode {
	return s.GetTokens(LiteParserRight_Brack)
}

func (s *SetAssignContext) Right_Brack(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, i)
}

func (s *SetAssignContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *SetAssignContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *SetAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAssignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitSetAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) SetAssign() (localctx ISetAssignContext) {
	localctx = NewSetAssignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, LiteParserRULE_setAssign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1439)
		p.Match(LiteParserLeft_Brack)
	}
	{
		p.SetState(1440)
		p.expression(0)
	}
	{
		p.SetState(1441)
		p.Match(LiteParserRight_Brack)
	}
	p.SetState(1449)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1442)
			p.More()
		}
		{
			p.SetState(1443)
			p.Match(LiteParserLeft_Brack)
		}
		{
			p.SetState(1444)
			p.expression(0)
		}
		{
			p.SetState(1445)
			p.Match(LiteParserRight_Brack)
		}

		p.SetState(1451)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDictionaryAssignContext is an interface to support dynamic dispatch.
type IDictionaryAssignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryAssignContext differentiates from other interfaces.
	IsDictionaryAssignContext()
}

type DictionaryAssignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryAssignContext() *DictionaryAssignContext {
	var p = new(DictionaryAssignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_dictionaryAssign
	return p
}

func (*DictionaryAssignContext) IsDictionaryAssignContext() {}

func NewDictionaryAssignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryAssignContext {
	var p = new(DictionaryAssignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_dictionaryAssign

	return p
}

func (s *DictionaryAssignContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryAssignContext) AllDictionaryElement() []IDictionaryElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDictionaryElementContext)(nil)).Elem())
	var tst = make([]IDictionaryElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDictionaryElementContext)
		}
	}

	return tst
}

func (s *DictionaryAssignContext) DictionaryElement(i int) IDictionaryElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDictionaryElementContext)
}

func (s *DictionaryAssignContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *DictionaryAssignContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *DictionaryAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryAssignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitDictionaryAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) DictionaryAssign() (localctx IDictionaryAssignContext) {
	localctx = NewDictionaryAssignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, LiteParserRULE_dictionaryAssign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1452)
		p.DictionaryElement()
	}
	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1453)
			p.More()
		}
		{
			p.SetState(1454)
			p.DictionaryElement()
		}

		p.SetState(1460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICallAwaitContext is an interface to support dynamic dispatch.
type ICallAwaitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallAwaitContext differentiates from other interfaces.
	IsCallAwaitContext()
}

type CallAwaitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallAwaitContext() *CallAwaitContext {
	var p = new(CallAwaitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_callAwait
	return p
}

func (*CallAwaitContext) IsCallAwaitContext() {}

func NewCallAwaitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallAwaitContext {
	var p = new(CallAwaitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_callAwait

	return p
}

func (s *CallAwaitContext) GetParser() antlr.Parser { return s.parser }

func (s *CallAwaitContext) Left_Flow() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Flow, 0)
}

func (s *CallAwaitContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CallAwaitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallAwaitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallAwaitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCallAwait(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) CallAwait() (localctx ICallAwaitContext) {
	localctx = NewCallAwaitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, LiteParserRULE_callAwait)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1461)
		p.Match(LiteParserLeft_Flow)
	}
	{
		p.SetState(1462)
		p.expression(0)
	}

	return localctx
}

// IListContext is an interface to support dynamic dispatch.
type IListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListContext differentiates from other interfaces.
	IsListContext()
}

type ListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListContext() *ListContext {
	var p = new(ListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_list
	return p
}

func (*ListContext) IsListContext() {}

func NewListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListContext {
	var p = new(ListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_list

	return p
}

func (s *ListContext) GetParser() antlr.Parser { return s.parser }

func (s *ListContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *ListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *ListContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *ListContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *ListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) List() (localctx IListContext) {
	localctx = NewListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, LiteParserRULE_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1464)
		p.Left_brace()
	}
	{
		p.SetState(1465)
		p.expression(0)
	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1466)
			p.More()
		}
		{
			p.SetState(1467)
			p.expression(0)
		}

		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1474)
		p.Right_brace()
	}

	return localctx
}

// ISetContext is an interface to support dynamic dispatch.
type ISetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetContext differentiates from other interfaces.
	IsSetContext()
}

type SetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetContext() *SetContext {
	var p = new(SetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_set
	return p
}

func (*SetContext) IsSetContext() {}

func NewSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetContext {
	var p = new(SetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_set

	return p
}

func (s *SetContext) GetParser() antlr.Parser { return s.parser }

func (s *SetContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *SetContext) AllLeft_Brack() []antlr.TerminalNode {
	return s.GetTokens(LiteParserLeft_Brack)
}

func (s *SetContext) Left_Brack(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, i)
}

func (s *SetContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *SetContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetContext) AllRight_Brack() []antlr.TerminalNode {
	return s.GetTokens(LiteParserRight_Brack)
}

func (s *SetContext) Right_Brack(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, i)
}

func (s *SetContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *SetContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *SetContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *SetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Set() (localctx ISetContext) {
	localctx = NewSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, LiteParserRULE_set)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1476)
		p.Left_brace()
	}
	{
		p.SetState(1477)
		p.Match(LiteParserLeft_Brack)
	}
	{
		p.SetState(1478)
		p.expression(0)
	}
	{
		p.SetState(1479)
		p.Match(LiteParserRight_Brack)
	}
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1480)
			p.More()
		}
		{
			p.SetState(1481)
			p.Match(LiteParserLeft_Brack)
		}
		{
			p.SetState(1482)
			p.expression(0)
		}
		{
			p.SetState(1483)
			p.Match(LiteParserRight_Brack)
		}

		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1490)
		p.Right_brace()
	}

	return localctx
}

// IDictionaryContext is an interface to support dynamic dispatch.
type IDictionaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryContext differentiates from other interfaces.
	IsDictionaryContext()
}

type DictionaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryContext() *DictionaryContext {
	var p = new(DictionaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_dictionary
	return p
}

func (*DictionaryContext) IsDictionaryContext() {}

func NewDictionaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryContext {
	var p = new(DictionaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_dictionary

	return p
}

func (s *DictionaryContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *DictionaryContext) AllDictionaryElement() []IDictionaryElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDictionaryElementContext)(nil)).Elem())
	var tst = make([]IDictionaryElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDictionaryElementContext)
		}
	}

	return tst
}

func (s *DictionaryContext) DictionaryElement(i int) IDictionaryElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDictionaryElementContext)
}

func (s *DictionaryContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *DictionaryContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *DictionaryContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *DictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitDictionary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Dictionary() (localctx IDictionaryContext) {
	localctx = NewDictionaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, LiteParserRULE_dictionary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1492)
		p.Left_brace()
	}
	{
		p.SetState(1493)
		p.DictionaryElement()
	}
	p.SetState(1499)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1494)
			p.More()
		}
		{
			p.SetState(1495)
			p.DictionaryElement()
		}

		p.SetState(1501)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1502)
		p.Right_brace()
	}

	return localctx
}

// IDictionaryElementContext is an interface to support dynamic dispatch.
type IDictionaryElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryElementContext differentiates from other interfaces.
	IsDictionaryElementContext()
}

type DictionaryElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryElementContext() *DictionaryElementContext {
	var p = new(DictionaryElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_dictionaryElement
	return p
}

func (*DictionaryElementContext) IsDictionaryElementContext() {}

func NewDictionaryElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryElementContext {
	var p = new(DictionaryElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_dictionaryElement

	return p
}

func (s *DictionaryElementContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryElementContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *DictionaryElementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *DictionaryElementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DictionaryElementContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *DictionaryElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitDictionaryElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) DictionaryElement() (localctx IDictionaryElementContext) {
	localctx = NewDictionaryElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, LiteParserRULE_dictionaryElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1504)
		p.Match(LiteParserLeft_Brack)
	}
	{
		p.SetState(1505)
		p.expression(0)
	}
	{
		p.SetState(1506)
		p.Match(LiteParserRight_Brack)
	}
	{
		p.SetState(1507)
		p.expression(0)
	}

	return localctx
}

// ISliceContext is an interface to support dynamic dispatch.
type ISliceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSliceContext differentiates from other interfaces.
	IsSliceContext()
}

type SliceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceContext() *SliceContext {
	var p = new(SliceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_slice
	return p
}

func (*SliceContext) IsSliceContext() {}

func NewSliceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceContext {
	var p = new(SliceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_slice

	return p
}

func (s *SliceContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceContext) SliceFull() ISliceFullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISliceFullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISliceFullContext)
}

func (s *SliceContext) SliceStart() ISliceStartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISliceStartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISliceStartContext)
}

func (s *SliceContext) SliceEnd() ISliceEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISliceEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISliceEndContext)
}

func (s *SliceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitSlice(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Slice() (localctx ISliceContext) {
	localctx = NewSliceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, LiteParserRULE_slice)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1512)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1509)
			p.SliceFull()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1510)
			p.SliceStart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1511)
			p.SliceEnd()
		}

	}

	return localctx
}

// ISliceFullContext is an interface to support dynamic dispatch.
type ISliceFullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsSliceFullContext differentiates from other interfaces.
	IsSliceFullContext()
}

type SliceFullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptySliceFullContext() *SliceFullContext {
	var p = new(SliceFullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_sliceFull
	return p
}

func (*SliceFullContext) IsSliceFullContext() {}

func NewSliceFullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceFullContext {
	var p = new(SliceFullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_sliceFull

	return p
}

func (s *SliceFullContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceFullContext) GetOp() antlr.Token { return s.op }

func (s *SliceFullContext) SetOp(v antlr.Token) { s.op = v }

func (s *SliceFullContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *SliceFullContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SliceFullContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *SliceFullContext) Less_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserLess_Equal, 0)
}

func (s *SliceFullContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *SliceFullContext) Greater_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater_Equal, 0)
}

func (s *SliceFullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceFullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceFullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitSliceFull(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) SliceFull() (localctx ISliceFullContext) {
	localctx = NewSliceFullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, LiteParserRULE_sliceFull)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1514)
		p.expression(0)
	}
	{
		p.SetState(1515)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SliceFullContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(LiteParserLess_Equal-25))|(1<<(LiteParserGreater_Equal-25))|(1<<(LiteParserLess-25))|(1<<(LiteParserGreater-25)))) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SliceFullContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1516)
		p.expression(0)
	}

	return localctx
}

// ISliceStartContext is an interface to support dynamic dispatch.
type ISliceStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsSliceStartContext differentiates from other interfaces.
	IsSliceStartContext()
}

type SliceStartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptySliceStartContext() *SliceStartContext {
	var p = new(SliceStartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_sliceStart
	return p
}

func (*SliceStartContext) IsSliceStartContext() {}

func NewSliceStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceStartContext {
	var p = new(SliceStartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_sliceStart

	return p
}

func (s *SliceStartContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceStartContext) GetOp() antlr.Token { return s.op }

func (s *SliceStartContext) SetOp(v antlr.Token) { s.op = v }

func (s *SliceStartContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SliceStartContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *SliceStartContext) Less_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserLess_Equal, 0)
}

func (s *SliceStartContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *SliceStartContext) Greater_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater_Equal, 0)
}

func (s *SliceStartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceStartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceStartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitSliceStart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) SliceStart() (localctx ISliceStartContext) {
	localctx = NewSliceStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, LiteParserRULE_sliceStart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1518)
		p.expression(0)
	}
	{
		p.SetState(1519)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SliceStartContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(LiteParserLess_Equal-25))|(1<<(LiteParserGreater_Equal-25))|(1<<(LiteParserLess-25))|(1<<(LiteParserGreater-25)))) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SliceStartContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISliceEndContext is an interface to support dynamic dispatch.
type ISliceEndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsSliceEndContext differentiates from other interfaces.
	IsSliceEndContext()
}

type SliceEndContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptySliceEndContext() *SliceEndContext {
	var p = new(SliceEndContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_sliceEnd
	return p
}

func (*SliceEndContext) IsSliceEndContext() {}

func NewSliceEndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceEndContext {
	var p = new(SliceEndContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_sliceEnd

	return p
}

func (s *SliceEndContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceEndContext) GetOp() antlr.Token { return s.op }

func (s *SliceEndContext) SetOp(v antlr.Token) { s.op = v }

func (s *SliceEndContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SliceEndContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *SliceEndContext) Less_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserLess_Equal, 0)
}

func (s *SliceEndContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *SliceEndContext) Greater_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater_Equal, 0)
}

func (s *SliceEndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceEndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceEndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitSliceEnd(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) SliceEnd() (localctx ISliceEndContext) {
	localctx = NewSliceEndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, LiteParserRULE_sliceEnd)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SliceEndContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((_la-25)&-(0x1f+1)) == 0 && ((1<<uint((_la-25)))&((1<<(LiteParserLess_Equal-25))|(1<<(LiteParserGreater_Equal-25))|(1<<(LiteParserLess-25))|(1<<(LiteParserGreater-25)))) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SliceEndContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1522)
		p.expression(0)
	}

	return localctx
}

// INameSpaceItemContext is an interface to support dynamic dispatch.
type INameSpaceItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameSpaceItemContext differentiates from other interfaces.
	IsNameSpaceItemContext()
}

type NameSpaceItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameSpaceItemContext() *NameSpaceItemContext {
	var p = new(NameSpaceItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_nameSpaceItem
	return p
}

func (*NameSpaceItemContext) IsNameSpaceItemContext() {}

func NewNameSpaceItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameSpaceItemContext {
	var p = new(NameSpaceItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_nameSpaceItem

	return p
}

func (s *NameSpaceItemContext) GetParser() antlr.Parser { return s.parser }

func (s *NameSpaceItemContext) AllId() []IIdContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdContext)(nil)).Elem())
	var tst = make([]IIdContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdContext)
		}
	}

	return tst
}

func (s *NameSpaceItemContext) Id(i int) IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *NameSpaceItemContext) AllCall() []ICallContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallContext)(nil)).Elem())
	var tst = make([]ICallContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallContext)
		}
	}

	return tst
}

func (s *NameSpaceItemContext) Call(i int) ICallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallContext)
}

func (s *NameSpaceItemContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *NameSpaceItemContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *NameSpaceItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameSpaceItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameSpaceItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitNameSpaceItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) NameSpaceItem() (localctx INameSpaceItemContext) {
	localctx = NewNameSpaceItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, LiteParserRULE_nameSpaceItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1531)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1524)
				p.Id()
			}
			{
				p.SetState(1525)
				p.Call()
			}
			p.SetState(1527)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == LiteParserNew_Line {
				{
					p.SetState(1526)
					p.Match(LiteParserNew_Line)
				}

			}

		}
		p.SetState(1533)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())
	}
	{
		p.SetState(1534)
		p.Id()
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) AllId() []IIdContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdContext)(nil)).Elem())
	var tst = make([]IIdContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdContext)
		}
	}

	return tst
}

func (s *NameContext) Id(i int) IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *NameContext) AllCall() []ICallContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallContext)(nil)).Elem())
	var tst = make([]ICallContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallContext)
		}
	}

	return tst
}

func (s *NameContext) Call(i int) ICallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallContext)
}

func (s *NameContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *NameContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, LiteParserRULE_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1536)
		p.Id()
	}
	p.SetState(1545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserDot {
		{
			p.SetState(1537)
			p.Call()
		}
		p.SetState(1539)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == LiteParserNew_Line {
			{
				p.SetState(1538)
				p.Match(LiteParserNew_Line)
			}

		}
		{
			p.SetState(1541)
			p.Id()
		}

		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITemplateDefineContext is an interface to support dynamic dispatch.
type ITemplateDefineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplateDefineContext differentiates from other interfaces.
	IsTemplateDefineContext()
}

type TemplateDefineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateDefineContext() *TemplateDefineContext {
	var p = new(TemplateDefineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_templateDefine
	return p
}

func (*TemplateDefineContext) IsTemplateDefineContext() {}

func NewTemplateDefineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateDefineContext {
	var p = new(TemplateDefineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_templateDefine

	return p
}

func (s *TemplateDefineContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateDefineContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *TemplateDefineContext) AllTemplateDefineItem() []ITemplateDefineItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITemplateDefineItemContext)(nil)).Elem())
	var tst = make([]ITemplateDefineItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITemplateDefineItemContext)
		}
	}

	return tst
}

func (s *TemplateDefineContext) TemplateDefineItem(i int) ITemplateDefineItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateDefineItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITemplateDefineItemContext)
}

func (s *TemplateDefineContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *TemplateDefineContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *TemplateDefineContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *TemplateDefineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateDefineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateDefineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTemplateDefine(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TemplateDefine() (localctx ITemplateDefineContext) {
	localctx = NewTemplateDefineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, LiteParserRULE_templateDefine)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1548)
		p.Match(LiteParserLess)
	}
	{
		p.SetState(1549)
		p.TemplateDefineItem()
	}
	p.SetState(1555)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1550)
			p.More()
		}
		{
			p.SetState(1551)
			p.TemplateDefineItem()
		}

		p.SetState(1557)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1558)
		p.Match(LiteParserGreater)
	}

	return localctx
}

// ITemplateDefineItemContext is an interface to support dynamic dispatch.
type ITemplateDefineItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplateDefineItemContext differentiates from other interfaces.
	IsTemplateDefineItemContext()
}

type TemplateDefineItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateDefineItemContext() *TemplateDefineItemContext {
	var p = new(TemplateDefineItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_templateDefineItem
	return p
}

func (*TemplateDefineItemContext) IsTemplateDefineItemContext() {}

func NewTemplateDefineItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateDefineItemContext {
	var p = new(TemplateDefineItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_templateDefineItem

	return p
}

func (s *TemplateDefineItemContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateDefineItemContext) AllId() []IIdContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdContext)(nil)).Elem())
	var tst = make([]IIdContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdContext)
		}
	}

	return tst
}

func (s *TemplateDefineItemContext) Id(i int) IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *TemplateDefineItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateDefineItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateDefineItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTemplateDefineItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TemplateDefineItem() (localctx ITemplateDefineItemContext) {
	localctx = NewTemplateDefineItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, LiteParserRULE_templateDefineItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1560)
		p.Id()
	}
	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
		{
			p.SetState(1561)
			p.Id()
		}

	}

	return localctx
}

// ITemplateCallContext is an interface to support dynamic dispatch.
type ITemplateCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplateCallContext differentiates from other interfaces.
	IsTemplateCallContext()
}

type TemplateCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateCallContext() *TemplateCallContext {
	var p = new(TemplateCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_templateCall
	return p
}

func (*TemplateCallContext) IsTemplateCallContext() {}

func NewTemplateCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateCallContext {
	var p = new(TemplateCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_templateCall

	return p
}

func (s *TemplateCallContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateCallContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *TemplateCallContext) AllTypeType() []ITypeTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem())
	var tst = make([]ITypeTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeTypeContext)
		}
	}

	return tst
}

func (s *TemplateCallContext) TypeType(i int) ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TemplateCallContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *TemplateCallContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *TemplateCallContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *TemplateCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTemplateCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TemplateCall() (localctx ITemplateCallContext) {
	localctx = NewTemplateCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, LiteParserRULE_templateCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1564)
		p.Match(LiteParserLess)
	}
	{
		p.SetState(1565)
		p.TypeType()
	}
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1566)
			p.More()
		}
		{
			p.SetState(1567)
			p.TypeType()
		}

		p.SetState(1573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1574)
		p.Match(LiteParserGreater)
	}

	return localctx
}

// ILambdaContext is an interface to support dynamic dispatch.
type ILambdaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsLambdaContext differentiates from other interfaces.
	IsLambdaContext()
}

type LambdaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyLambdaContext() *LambdaContext {
	var p = new(LambdaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_lambda
	return p
}

func (*LambdaContext) IsLambdaContext() {}

func NewLambdaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaContext {
	var p = new(LambdaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_lambda

	return p
}

func (s *LambdaContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaContext) GetT() antlr.Token { return s.t }

func (s *LambdaContext) SetT(v antlr.Token) { s.t = v }

func (s *LambdaContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *LambdaContext) TupleExpression() ITupleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITupleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITupleExpressionContext)
}

func (s *LambdaContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *LambdaContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *LambdaContext) Right_Flow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Flow, 0)
}

func (s *LambdaContext) LambdaIn() ILambdaInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaInContext)
}

func (s *LambdaContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *LambdaContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *LambdaContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *LambdaContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLambda(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Lambda() (localctx ILambdaContext) {
	localctx = NewLambdaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, LiteParserRULE_lambda)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1609)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1576)
			p.Left_brace()
		}
		p.SetState(1578)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
			{
				p.SetState(1577)
				p.LambdaIn()
			}

		}
		{
			p.SetState(1580)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LambdaContext).t = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == LiteParserRight_Arrow || _la == LiteParserRight_Flow) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LambdaContext).t = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1584)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == LiteParserNew_Line {
			{
				p.SetState(1581)
				p.Match(LiteParserNew_Line)
			}

			p.SetState(1586)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1587)
			p.TupleExpression()
		}
		{
			p.SetState(1588)
			p.Right_brace()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1590)
			p.Left_brace()
		}
		p.SetState(1592)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(LiteParserTypeI8-62))|(1<<(LiteParserTypeU8-62))|(1<<(LiteParserTypeI16-62))|(1<<(LiteParserTypeU16-62))|(1<<(LiteParserTypeI32-62))|(1<<(LiteParserTypeU32-62))|(1<<(LiteParserTypeI64-62))|(1<<(LiteParserTypeU64-62))|(1<<(LiteParserTypeF32-62))|(1<<(LiteParserTypeF64-62))|(1<<(LiteParserTypeChr-62))|(1<<(LiteParserTypeStr-62))|(1<<(LiteParserTypeBool-62))|(1<<(LiteParserTypeInt-62))|(1<<(LiteParserTypeNum-62))|(1<<(LiteParserTypeByte-62))|(1<<(LiteParserTypeAny-62))|(1<<(LiteParserIDPrivate-62))|(1<<(LiteParserIDPublic-62)))) != 0) {
			{
				p.SetState(1591)
				p.LambdaIn()
			}

		}
		{
			p.SetState(1594)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LambdaContext).t = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == LiteParserRight_Arrow || _la == LiteParserRight_Flow) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LambdaContext).t = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1598)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1595)
					p.Match(LiteParserNew_Line)
				}

			}
			p.SetState(1600)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())
		}
		p.SetState(1604)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1601)
					p.FunctionSupportStatement()
				}

			}
			p.SetState(1606)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext())
		}
		{
			p.SetState(1607)
			p.Right_brace()
		}

	}

	return localctx
}

// ILambdaInContext is an interface to support dynamic dispatch.
type ILambdaInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaInContext differentiates from other interfaces.
	IsLambdaInContext()
}

type LambdaInContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaInContext() *LambdaInContext {
	var p = new(LambdaInContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_lambdaIn
	return p
}

func (*LambdaInContext) IsLambdaInContext() {}

func NewLambdaInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaInContext {
	var p = new(LambdaInContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_lambdaIn

	return p
}

func (s *LambdaInContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaInContext) AllId() []IIdContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdContext)(nil)).Elem())
	var tst = make([]IIdContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdContext)
		}
	}

	return tst
}

func (s *LambdaInContext) Id(i int) IIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdContext)
}

func (s *LambdaInContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *LambdaInContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *LambdaInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLambdaIn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LambdaIn() (localctx ILambdaInContext) {
	localctx = NewLambdaInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, LiteParserRULE_lambdaIn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1611)
		p.Id()
	}
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1612)
			p.More()
		}
		{
			p.SetState(1613)
			p.Id()
		}

		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPkgAnonymousContext is an interface to support dynamic dispatch.
type IPkgAnonymousContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPkgAnonymousContext differentiates from other interfaces.
	IsPkgAnonymousContext()
}

type PkgAnonymousContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPkgAnonymousContext() *PkgAnonymousContext {
	var p = new(PkgAnonymousContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_pkgAnonymous
	return p
}

func (*PkgAnonymousContext) IsPkgAnonymousContext() {}

func NewPkgAnonymousContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PkgAnonymousContext {
	var p = new(PkgAnonymousContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_pkgAnonymous

	return p
}

func (s *PkgAnonymousContext) GetParser() antlr.Parser { return s.parser }

func (s *PkgAnonymousContext) PkgAnonymousAssign() IPkgAnonymousAssignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPkgAnonymousAssignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPkgAnonymousAssignContext)
}

func (s *PkgAnonymousContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PkgAnonymousContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PkgAnonymousContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPkgAnonymous(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PkgAnonymous() (localctx IPkgAnonymousContext) {
	localctx = NewPkgAnonymousContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, LiteParserRULE_pkgAnonymous)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1620)
		p.PkgAnonymousAssign()
	}

	return localctx
}

// IPkgAnonymousAssignContext is an interface to support dynamic dispatch.
type IPkgAnonymousAssignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPkgAnonymousAssignContext differentiates from other interfaces.
	IsPkgAnonymousAssignContext()
}

type PkgAnonymousAssignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPkgAnonymousAssignContext() *PkgAnonymousAssignContext {
	var p = new(PkgAnonymousAssignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_pkgAnonymousAssign
	return p
}

func (*PkgAnonymousAssignContext) IsPkgAnonymousAssignContext() {}

func NewPkgAnonymousAssignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PkgAnonymousAssignContext {
	var p = new(PkgAnonymousAssignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_pkgAnonymousAssign

	return p
}

func (s *PkgAnonymousAssignContext) GetParser() antlr.Parser { return s.parser }

func (s *PkgAnonymousAssignContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *PkgAnonymousAssignContext) AllPkgAnonymousAssignElement() []IPkgAnonymousAssignElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPkgAnonymousAssignElementContext)(nil)).Elem())
	var tst = make([]IPkgAnonymousAssignElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPkgAnonymousAssignElementContext)
		}
	}

	return tst
}

func (s *PkgAnonymousAssignContext) PkgAnonymousAssignElement(i int) IPkgAnonymousAssignElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPkgAnonymousAssignElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPkgAnonymousAssignElementContext)
}

func (s *PkgAnonymousAssignContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *PkgAnonymousAssignContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *PkgAnonymousAssignContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *PkgAnonymousAssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PkgAnonymousAssignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PkgAnonymousAssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPkgAnonymousAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PkgAnonymousAssign() (localctx IPkgAnonymousAssignContext) {
	localctx = NewPkgAnonymousAssignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, LiteParserRULE_pkgAnonymousAssign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1622)
		p.Left_brace()
	}
	{
		p.SetState(1623)
		p.PkgAnonymousAssignElement()
	}
	p.SetState(1629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1624)
			p.More()
		}
		{
			p.SetState(1625)
			p.PkgAnonymousAssignElement()
		}

		p.SetState(1631)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1632)
		p.Right_brace()
	}

	return localctx
}

// IPkgAnonymousAssignElementContext is an interface to support dynamic dispatch.
type IPkgAnonymousAssignElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPkgAnonymousAssignElementContext differentiates from other interfaces.
	IsPkgAnonymousAssignElementContext()
}

type PkgAnonymousAssignElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPkgAnonymousAssignElementContext() *PkgAnonymousAssignElementContext {
	var p = new(PkgAnonymousAssignElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_pkgAnonymousAssignElement
	return p
}

func (*PkgAnonymousAssignElementContext) IsPkgAnonymousAssignElementContext() {}

func NewPkgAnonymousAssignElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PkgAnonymousAssignElementContext {
	var p = new(PkgAnonymousAssignElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_pkgAnonymousAssignElement

	return p
}

func (s *PkgAnonymousAssignElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PkgAnonymousAssignElementContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PkgAnonymousAssignElementContext) Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual, 0)
}

func (s *PkgAnonymousAssignElementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PkgAnonymousAssignElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PkgAnonymousAssignElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PkgAnonymousAssignElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPkgAnonymousAssignElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PkgAnonymousAssignElement() (localctx IPkgAnonymousAssignElementContext) {
	localctx = NewPkgAnonymousAssignElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, LiteParserRULE_pkgAnonymousAssignElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1634)
		p.Name()
	}
	{
		p.SetState(1635)
		p.Match(LiteParserEqual)
	}
	{
		p.SetState(1636)
		p.expression(0)
	}

	return localctx
}

// IFunctionExpressionContext is an interface to support dynamic dispatch.
type IFunctionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsFunctionExpressionContext differentiates from other interfaces.
	IsFunctionExpressionContext()
}

type FunctionExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyFunctionExpressionContext() *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_functionExpression
	return p
}

func (*FunctionExpressionContext) IsFunctionExpressionContext() {}

func NewFunctionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_functionExpression

	return p
}

func (s *FunctionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionExpressionContext) GetT() antlr.Token { return s.t }

func (s *FunctionExpressionContext) SetT(v antlr.Token) { s.t = v }

func (s *FunctionExpressionContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *FunctionExpressionContext) ParameterClauseIn() IParameterClauseInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseInContext)
}

func (s *FunctionExpressionContext) ParameterClauseOut() IParameterClauseOutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterClauseOutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterClauseOutContext)
}

func (s *FunctionExpressionContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *FunctionExpressionContext) Left_brace() ILeft_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_braceContext)
}

func (s *FunctionExpressionContext) Right_brace() IRight_braceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_braceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_braceContext)
}

func (s *FunctionExpressionContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *FunctionExpressionContext) Right_Flow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Flow, 0)
}

func (s *FunctionExpressionContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *FunctionExpressionContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *FunctionExpressionContext) AllFunctionSupportStatement() []IFunctionSupportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem())
	var tst = make([]IFunctionSupportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionSupportStatementContext)
		}
	}

	return tst
}

func (s *FunctionExpressionContext) FunctionSupportStatement(i int) IFunctionSupportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSupportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionSupportStatementContext)
}

func (s *FunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) FunctionExpression() (localctx IFunctionExpressionContext) {
	localctx = NewFunctionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, LiteParserRULE_functionExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1638)
		p.Left_paren()
	}
	{
		p.SetState(1639)
		p.ParameterClauseIn()
	}
	{
		p.SetState(1640)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*FunctionExpressionContext).t = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserRight_Arrow || _la == LiteParserRight_Flow) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*FunctionExpressionContext).t = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1644)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(1641)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(1646)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1647)
		p.ParameterClauseOut()
	}
	{
		p.SetState(1648)
		p.Right_paren()
	}
	{
		p.SetState(1649)
		p.Left_brace()
	}
	p.SetState(1653)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1650)
				p.FunctionSupportStatement()
			}

		}
		p.SetState(1655)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())
	}
	{
		p.SetState(1656)
		p.Right_brace()
	}

	return localctx
}

// IPlusMinusContext is an interface to support dynamic dispatch.
type IPlusMinusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPlusMinusContext differentiates from other interfaces.
	IsPlusMinusContext()
}

type PlusMinusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlusMinusContext() *PlusMinusContext {
	var p = new(PlusMinusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_plusMinus
	return p
}

func (*PlusMinusContext) IsPlusMinusContext() {}

func NewPlusMinusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlusMinusContext {
	var p = new(PlusMinusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_plusMinus

	return p
}

func (s *PlusMinusContext) GetParser() antlr.Parser { return s.parser }

func (s *PlusMinusContext) Add() IAddContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddContext)
}

func (s *PlusMinusContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PlusMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlusMinusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlusMinusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPlusMinus(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) PlusMinus() (localctx IPlusMinusContext) {
	localctx = NewPlusMinusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, LiteParserRULE_plusMinus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1658)
		p.Add()
	}
	{
		p.SetState(1659)
		p.expression(0)
	}

	return localctx
}

// INegateContext is an interface to support dynamic dispatch.
type INegateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNegateContext differentiates from other interfaces.
	IsNegateContext()
}

type NegateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNegateContext() *NegateContext {
	var p = new(NegateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_negate
	return p
}

func (*NegateContext) IsNegateContext() {}

func NewNegateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NegateContext {
	var p = new(NegateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_negate

	return p
}

func (s *NegateContext) GetParser() antlr.Parser { return s.parser }

func (s *NegateContext) Wave() IWaveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWaveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWaveContext)
}

func (s *NegateContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NegateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NegateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NegateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitNegate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Negate() (localctx INegateContext) {
	localctx = NewNegateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, LiteParserRULE_negate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1661)
		p.Wave()
	}
	{
		p.SetState(1662)
		p.expression(0)
	}

	return localctx
}

// IBitwiseNotExpressionContext is an interface to support dynamic dispatch.
type IBitwiseNotExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseNotExpressionContext differentiates from other interfaces.
	IsBitwiseNotExpressionContext()
}

type BitwiseNotExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseNotExpressionContext() *BitwiseNotExpressionContext {
	var p = new(BitwiseNotExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_bitwiseNotExpression
	return p
}

func (*BitwiseNotExpressionContext) IsBitwiseNotExpressionContext() {}

func NewBitwiseNotExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseNotExpressionContext {
	var p = new(BitwiseNotExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_bitwiseNotExpression

	return p
}

func (s *BitwiseNotExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseNotExpressionContext) BitwiseNot() IBitwiseNotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseNotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitwiseNotContext)
}

func (s *BitwiseNotExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseNotExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseNotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitBitwiseNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) BitwiseNotExpression() (localctx IBitwiseNotExpressionContext) {
	localctx = NewBitwiseNotExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, LiteParserRULE_bitwiseNotExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1664)
		p.BitwiseNot()
	}
	{
		p.SetState(1665)
		p.expression(0)
	}

	return localctx
}

// ILinqContext is an interface to support dynamic dispatch.
type ILinqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k token.
	GetK() antlr.Token

	// SetK sets the k token.
	SetK(antlr.Token)

	// IsLinqContext differentiates from other interfaces.
	IsLinqContext()
}

type LinqContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	k      antlr.Token
}

func NewEmptyLinqContext() *LinqContext {
	var p = new(LinqContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_linq
	return p
}

func (*LinqContext) IsLinqContext() {}

func NewLinqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinqContext {
	var p = new(LinqContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_linq

	return p
}

func (s *LinqContext) GetParser() antlr.Parser { return s.parser }

func (s *LinqContext) GetK() antlr.Token { return s.k }

func (s *LinqContext) SetK(v antlr.Token) { s.k = v }

func (s *LinqContext) LinqHeadKeyword() ILinqHeadKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinqHeadKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinqHeadKeywordContext)
}

func (s *LinqContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *LinqContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LinqContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *LinqContext) LinqSelect() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqSelect, 0)
}

func (s *LinqContext) LinqBy() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqBy, 0)
}

func (s *LinqContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *LinqContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *LinqContext) AllLinqItem() []ILinqItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILinqItemContext)(nil)).Elem())
	var tst = make([]ILinqItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILinqItemContext)
		}
	}

	return tst
}

func (s *LinqContext) LinqItem(i int) ILinqItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinqItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILinqItemContext)
}

func (s *LinqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLinq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Linq() (localctx ILinqContext) {
	localctx = NewLinqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, LiteParserRULE_linq)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1667)
		p.LinqHeadKeyword()
	}
	p.SetState(1669)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1668)
			p.Match(LiteParserNew_Line)
		}

	}
	{
		p.SetState(1671)
		p.expression(0)
	}
	{
		p.SetState(1672)
		p.Match(LiteParserRight_Arrow)
	}
	p.SetState(1674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1673)
			p.Match(LiteParserNew_Line)
		}

	}
	p.SetState(1677)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1676)
				p.LinqItem()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1679)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())
	}
	{
		p.SetState(1681)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*LinqContext).k = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserLinqBy || _la == LiteParserLinqSelect) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*LinqContext).k = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1682)
			p.Match(LiteParserNew_Line)
		}

	}
	{
		p.SetState(1685)
		p.expression(0)
	}

	return localctx
}

// ILinqItemContext is an interface to support dynamic dispatch.
type ILinqItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinqItemContext differentiates from other interfaces.
	IsLinqItemContext()
}

type LinqItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinqItemContext() *LinqItemContext {
	var p = new(LinqItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_linqItem
	return p
}

func (*LinqItemContext) IsLinqItemContext() {}

func NewLinqItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinqItemContext {
	var p = new(LinqItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_linqItem

	return p
}

func (s *LinqItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LinqItemContext) LinqKeyword() ILinqKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinqKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinqKeywordContext)
}

func (s *LinqItemContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *LinqItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LinqItemContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *LinqItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinqItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinqItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLinqItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LinqItem() (localctx ILinqItemContext) {
	localctx = NewLinqItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, LiteParserRULE_linqItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1687)
		p.LinqKeyword()
	}
	p.SetState(1689)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(LiteParserLeft_Flow-36))|(1<<(LiteParserLess-36))|(1<<(LiteParserLeft_Paren-36))|(1<<(LiteParserLeft_Brace-36))|(1<<(LiteParserLeft_Brack-36))|(1<<(LiteParserQuestion-36))|(1<<(LiteParserBang-36))|(1<<(LiteParserWave-36))|(1<<(LiteParserAdd-36))|(1<<(LiteParserSub-36))|(1<<(LiteParserTypeI8-36))|(1<<(LiteParserTypeU8-36))|(1<<(LiteParserTypeI16-36))|(1<<(LiteParserTypeU16-36))|(1<<(LiteParserTypeI32-36))|(1<<(LiteParserTypeU32-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(LiteParserTypeI64-68))|(1<<(LiteParserTypeU64-68))|(1<<(LiteParserTypeF32-68))|(1<<(LiteParserTypeF64-68))|(1<<(LiteParserTypeChr-68))|(1<<(LiteParserTypeStr-68))|(1<<(LiteParserTypeBool-68))|(1<<(LiteParserTypeInt-68))|(1<<(LiteParserTypeNum-68))|(1<<(LiteParserTypeByte-68))|(1<<(LiteParserTypeAny-68))|(1<<(LiteParserNilLiteral-68))|(1<<(LiteParserTrueLiteral-68))|(1<<(LiteParserFalseLiteral-68))|(1<<(LiteParserUndefinedLiteral-68))|(1<<(LiteParserNumberLiteral-68))|(1<<(LiteParserTextLiteral-68))|(1<<(LiteParserCharLiteral-68))|(1<<(LiteParserIDPrivate-68))|(1<<(LiteParserIDPublic-68))|(1<<(LiteParserDiscard-68)))) != 0) {
		{
			p.SetState(1688)
			p.expression(0)
		}

	}
	{
		p.SetState(1691)
		p.Match(LiteParserRight_Arrow)
	}
	p.SetState(1693)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1692)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// ILinqKeywordContext is an interface to support dynamic dispatch.
type ILinqKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinqKeywordContext differentiates from other interfaces.
	IsLinqKeywordContext()
}

type LinqKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinqKeywordContext() *LinqKeywordContext {
	var p = new(LinqKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_linqKeyword
	return p
}

func (*LinqKeywordContext) IsLinqKeywordContext() {}

func NewLinqKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinqKeywordContext {
	var p = new(LinqKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_linqKeyword

	return p
}

func (s *LinqKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *LinqKeywordContext) LinqHeadKeyword() ILinqHeadKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinqHeadKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinqHeadKeywordContext)
}

func (s *LinqKeywordContext) LinqBodyKeyword() ILinqBodyKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinqBodyKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinqBodyKeywordContext)
}

func (s *LinqKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinqKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinqKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLinqKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LinqKeyword() (localctx ILinqKeywordContext) {
	localctx = NewLinqKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, LiteParserRULE_linqKeyword)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1697)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserLinqFrom:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1695)
			p.LinqHeadKeyword()
		}

	case LiteParserLinqBy, LiteParserLinqSelect, LiteParserLinqWhere, LiteParserLinqGroup, LiteParserLinqInto, LiteParserLinqOrderby, LiteParserLinqJoin, LiteParserLinqLet, LiteParserLinqIn, LiteParserLinqOn, LiteParserLinqEquals, LiteParserLinqAscending, LiteParserLinqDescending:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1696)
			p.LinqBodyKeyword()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILinqHeadKeywordContext is an interface to support dynamic dispatch.
type ILinqHeadKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k token.
	GetK() antlr.Token

	// SetK sets the k token.
	SetK(antlr.Token)

	// IsLinqHeadKeywordContext differentiates from other interfaces.
	IsLinqHeadKeywordContext()
}

type LinqHeadKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	k      antlr.Token
}

func NewEmptyLinqHeadKeywordContext() *LinqHeadKeywordContext {
	var p = new(LinqHeadKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_linqHeadKeyword
	return p
}

func (*LinqHeadKeywordContext) IsLinqHeadKeywordContext() {}

func NewLinqHeadKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinqHeadKeywordContext {
	var p = new(LinqHeadKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_linqHeadKeyword

	return p
}

func (s *LinqHeadKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *LinqHeadKeywordContext) GetK() antlr.Token { return s.k }

func (s *LinqHeadKeywordContext) SetK(v antlr.Token) { s.k = v }

func (s *LinqHeadKeywordContext) LinqFrom() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqFrom, 0)
}

func (s *LinqHeadKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinqHeadKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinqHeadKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLinqHeadKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LinqHeadKeyword() (localctx ILinqHeadKeywordContext) {
	localctx = NewLinqHeadKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, LiteParserRULE_linqHeadKeyword)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1699)

		var _m = p.Match(LiteParserLinqFrom)

		localctx.(*LinqHeadKeywordContext).k = _m
	}

	return localctx
}

// ILinqBodyKeywordContext is an interface to support dynamic dispatch.
type ILinqBodyKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k token.
	GetK() antlr.Token

	// SetK sets the k token.
	SetK(antlr.Token)

	// IsLinqBodyKeywordContext differentiates from other interfaces.
	IsLinqBodyKeywordContext()
}

type LinqBodyKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	k      antlr.Token
}

func NewEmptyLinqBodyKeywordContext() *LinqBodyKeywordContext {
	var p = new(LinqBodyKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_linqBodyKeyword
	return p
}

func (*LinqBodyKeywordContext) IsLinqBodyKeywordContext() {}

func NewLinqBodyKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinqBodyKeywordContext {
	var p = new(LinqBodyKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_linqBodyKeyword

	return p
}

func (s *LinqBodyKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *LinqBodyKeywordContext) GetK() antlr.Token { return s.k }

func (s *LinqBodyKeywordContext) SetK(v antlr.Token) { s.k = v }

func (s *LinqBodyKeywordContext) LinqSelect() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqSelect, 0)
}

func (s *LinqBodyKeywordContext) LinqBy() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqBy, 0)
}

func (s *LinqBodyKeywordContext) LinqWhere() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqWhere, 0)
}

func (s *LinqBodyKeywordContext) LinqGroup() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqGroup, 0)
}

func (s *LinqBodyKeywordContext) LinqInto() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqInto, 0)
}

func (s *LinqBodyKeywordContext) LinqOrderby() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqOrderby, 0)
}

func (s *LinqBodyKeywordContext) LinqJoin() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqJoin, 0)
}

func (s *LinqBodyKeywordContext) LinqLet() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqLet, 0)
}

func (s *LinqBodyKeywordContext) LinqIn() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqIn, 0)
}

func (s *LinqBodyKeywordContext) LinqOn() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqOn, 0)
}

func (s *LinqBodyKeywordContext) LinqEquals() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqEquals, 0)
}

func (s *LinqBodyKeywordContext) LinqAscending() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqAscending, 0)
}

func (s *LinqBodyKeywordContext) LinqDescending() antlr.TerminalNode {
	return s.GetToken(LiteParserLinqDescending, 0)
}

func (s *LinqBodyKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinqBodyKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinqBodyKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLinqBodyKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) LinqBodyKeyword() (localctx ILinqBodyKeywordContext) {
	localctx = NewLinqBodyKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, LiteParserRULE_linqBodyKeyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1701)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*LinqBodyKeywordContext).k = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*LinqBodyKeywordContext).k = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStringExpressionContext is an interface to support dynamic dispatch.
type IStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringExpressionContext differentiates from other interfaces.
	IsStringExpressionContext()
}

type StringExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringExpressionContext() *StringExpressionContext {
	var p = new(StringExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_stringExpression
	return p
}

func (*StringExpressionContext) IsStringExpressionContext() {}

func NewStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringExpressionContext {
	var p = new(StringExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_stringExpression

	return p
}

func (s *StringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringExpressionContext) TextLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserTextLiteral, 0)
}

func (s *StringExpressionContext) AllStringExpressionElement() []IStringExpressionElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStringExpressionElementContext)(nil)).Elem())
	var tst = make([]IStringExpressionElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStringExpressionElementContext)
		}
	}

	return tst
}

func (s *StringExpressionContext) StringExpressionElement(i int) IStringExpressionElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringExpressionElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStringExpressionElementContext)
}

func (s *StringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) StringExpression() (localctx IStringExpressionContext) {
	localctx = NewStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, LiteParserRULE_stringExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1703)
		p.Match(LiteParserTextLiteral)
	}
	p.SetState(1705)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1704)
				p.StringExpressionElement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1707)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext())
	}

	return localctx
}

// IStringExpressionElementContext is an interface to support dynamic dispatch.
type IStringExpressionElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringExpressionElementContext differentiates from other interfaces.
	IsStringExpressionElementContext()
}

type StringExpressionElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringExpressionElementContext() *StringExpressionElementContext {
	var p = new(StringExpressionElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_stringExpressionElement
	return p
}

func (*StringExpressionElementContext) IsStringExpressionElementContext() {}

func NewStringExpressionElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringExpressionElementContext {
	var p = new(StringExpressionElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_stringExpressionElement

	return p
}

func (s *StringExpressionElementContext) GetParser() antlr.Parser { return s.parser }

func (s *StringExpressionElementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StringExpressionElementContext) TextLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserTextLiteral, 0)
}

func (s *StringExpressionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringExpressionElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringExpressionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitStringExpressionElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) StringExpressionElement() (localctx IStringExpressionElementContext) {
	localctx = NewStringExpressionElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, LiteParserRULE_stringExpressionElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1709)
		p.expression(0)
	}
	{
		p.SetState(1710)
		p.Match(LiteParserTextLiteral)
	}

	return localctx
}

// IDataStatementContext is an interface to support dynamic dispatch.
type IDataStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsDataStatementContext differentiates from other interfaces.
	IsDataStatementContext()
}

type DataStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyDataStatementContext() *DataStatementContext {
	var p = new(DataStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_dataStatement
	return p
}

func (*DataStatementContext) IsDataStatementContext() {}

func NewDataStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataStatementContext {
	var p = new(DataStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_dataStatement

	return p
}

func (s *DataStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DataStatementContext) GetT() antlr.Token { return s.t }

func (s *DataStatementContext) SetT(v antlr.Token) { s.t = v }

func (s *DataStatementContext) FloatExpr() IFloatExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloatExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloatExprContext)
}

func (s *DataStatementContext) IntegerExpr() IIntegerExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerExprContext)
}

func (s *DataStatementContext) TextLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserTextLiteral, 0)
}

func (s *DataStatementContext) CharLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserCharLiteral, 0)
}

func (s *DataStatementContext) TrueLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserTrueLiteral, 0)
}

func (s *DataStatementContext) FalseLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserFalseLiteral, 0)
}

func (s *DataStatementContext) NilExpr() INilExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INilExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INilExprContext)
}

func (s *DataStatementContext) UndefinedLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserUndefinedLiteral, 0)
}

func (s *DataStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitDataStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) DataStatement() (localctx IDataStatementContext) {
	localctx = NewDataStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, LiteParserRULE_dataStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1720)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1712)
			p.FloatExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1713)
			p.IntegerExpr()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1714)

			var _m = p.Match(LiteParserTextLiteral)

			localctx.(*DataStatementContext).t = _m
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1715)

			var _m = p.Match(LiteParserCharLiteral)

			localctx.(*DataStatementContext).t = _m
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1716)

			var _m = p.Match(LiteParserTrueLiteral)

			localctx.(*DataStatementContext).t = _m
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1717)

			var _m = p.Match(LiteParserFalseLiteral)

			localctx.(*DataStatementContext).t = _m
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1718)
			p.NilExpr()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1719)

			var _m = p.Match(LiteParserUndefinedLiteral)

			localctx.(*DataStatementContext).t = _m
		}

	}

	return localctx
}

// IFloatExprContext is an interface to support dynamic dispatch.
type IFloatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloatExprContext differentiates from other interfaces.
	IsFloatExprContext()
}

type FloatExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatExprContext() *FloatExprContext {
	var p = new(FloatExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_floatExpr
	return p
}

func (*FloatExprContext) IsFloatExprContext() {}

func NewFloatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatExprContext {
	var p = new(FloatExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_floatExpr

	return p
}

func (s *FloatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatExprContext) AllIntegerExpr() []IIntegerExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntegerExprContext)(nil)).Elem())
	var tst = make([]IIntegerExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntegerExprContext)
		}
	}

	return tst
}

func (s *FloatExprContext) IntegerExpr(i int) IIntegerExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntegerExprContext)
}

func (s *FloatExprContext) Call() ICallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallContext)
}

func (s *FloatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitFloatExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) FloatExpr() (localctx IFloatExprContext) {
	localctx = NewFloatExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, LiteParserRULE_floatExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1722)
		p.IntegerExpr()
	}
	{
		p.SetState(1723)
		p.Call()
	}
	{
		p.SetState(1724)
		p.IntegerExpr()
	}

	return localctx
}

// IIntegerExprContext is an interface to support dynamic dispatch.
type IIntegerExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerExprContext differentiates from other interfaces.
	IsIntegerExprContext()
}

type IntegerExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerExprContext() *IntegerExprContext {
	var p = new(IntegerExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_integerExpr
	return p
}

func (*IntegerExprContext) IsIntegerExprContext() {}

func NewIntegerExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerExprContext {
	var p = new(IntegerExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_integerExpr

	return p
}

func (s *IntegerExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerExprContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserNumberLiteral, 0)
}

func (s *IntegerExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitIntegerExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) IntegerExpr() (localctx IIntegerExprContext) {
	localctx = NewIntegerExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, LiteParserRULE_integerExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1726)
		p.Match(LiteParserNumberLiteral)
	}

	return localctx
}

// ITypeNotNullContext is an interface to support dynamic dispatch.
type ITypeNotNullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNotNullContext differentiates from other interfaces.
	IsTypeNotNullContext()
}

type TypeNotNullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNotNullContext() *TypeNotNullContext {
	var p = new(TypeNotNullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeNotNull
	return p
}

func (*TypeNotNullContext) IsTypeNotNullContext() {}

func NewTypeNotNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNotNullContext {
	var p = new(TypeNotNullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeNotNull

	return p
}

func (s *TypeNotNullContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNotNullContext) TypeAny() ITypeAnyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAnyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAnyContext)
}

func (s *TypeNotNullContext) TypeTuple() ITypeTupleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTupleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTupleContext)
}

func (s *TypeNotNullContext) TypeArray() ITypeArrayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArrayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArrayContext)
}

func (s *TypeNotNullContext) TypeList() ITypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeNotNullContext) TypeSet() ITypeSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSetContext)
}

func (s *TypeNotNullContext) TypeDictionary() ITypeDictionaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDictionaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeDictionaryContext)
}

func (s *TypeNotNullContext) TypeChannel() ITypeChannelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeChannelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeChannelContext)
}

func (s *TypeNotNullContext) TypeBasic() ITypeBasicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeBasicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeBasicContext)
}

func (s *TypeNotNullContext) TypePackage() ITypePackageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypePackageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypePackageContext)
}

func (s *TypeNotNullContext) TypeFunction() ITypeFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeFunctionContext)
}

func (s *TypeNotNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNotNullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNotNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeNotNull(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeNotNull() (localctx ITypeNotNullContext) {
	localctx = NewTypeNotNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, LiteParserRULE_typeNotNull)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1738)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1728)
			p.TypeAny()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1729)
			p.TypeTuple()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1730)
			p.TypeArray()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1731)
			p.TypeList()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1732)
			p.TypeSet()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1733)
			p.TypeDictionary()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1734)
			p.TypeChannel()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1735)
			p.TypeBasic()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1736)
			p.TypePackage()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1737)
			p.TypeFunction()
		}

	}

	return localctx
}

// ITypeTypeContext is an interface to support dynamic dispatch.
type ITypeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeTypeContext differentiates from other interfaces.
	IsTypeTypeContext()
}

type TypeTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTypeContext() *TypeTypeContext {
	var p = new(TypeTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeType
	return p
}

func (*TypeTypeContext) IsTypeTypeContext() {}

func NewTypeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTypeContext {
	var p = new(TypeTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeType

	return p
}

func (s *TypeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTypeContext) TypeNotNull() ITypeNotNullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNotNullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNotNullContext)
}

func (s *TypeTypeContext) TypeNullable() ITypeNullableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNullableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNullableContext)
}

func (s *TypeTypeContext) TypeReference() ITypeReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *TypeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeType() (localctx ITypeTypeContext) {
	localctx = NewTypeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, LiteParserRULE_typeType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1743)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserLinqFrom, LiteParserLinqBy, LiteParserLinqSelect, LiteParserLinqWhere, LiteParserLinqGroup, LiteParserLinqInto, LiteParserLinqOrderby, LiteParserLinqJoin, LiteParserLinqLet, LiteParserLinqIn, LiteParserLinqOn, LiteParserLinqEquals, LiteParserLinqAscending, LiteParserLinqDescending, LiteParserLess, LiteParserLeft_Paren, LiteParserLeft_Brack, LiteParserTypeI8, LiteParserTypeU8, LiteParserTypeI16, LiteParserTypeU16, LiteParserTypeI32, LiteParserTypeU32, LiteParserTypeI64, LiteParserTypeU64, LiteParserTypeF32, LiteParserTypeF64, LiteParserTypeChr, LiteParserTypeStr, LiteParserTypeBool, LiteParserTypeInt, LiteParserTypeNum, LiteParserTypeByte, LiteParserTypeAny, LiteParserIDPrivate, LiteParserIDPublic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1740)
			p.TypeNotNull()
		}

	case LiteParserQuestion:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1741)
			p.TypeNullable()
		}

	case LiteParserBang:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1742)
			p.TypeReference()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeReferenceContext is an interface to support dynamic dispatch.
type ITypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeReferenceContext differentiates from other interfaces.
	IsTypeReferenceContext()
}

type TypeReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeReferenceContext() *TypeReferenceContext {
	var p = new(TypeReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeReference
	return p
}

func (*TypeReferenceContext) IsTypeReferenceContext() {}

func NewTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeReferenceContext {
	var p = new(TypeReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeReference

	return p
}

func (s *TypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeReferenceContext) Bang() antlr.TerminalNode {
	return s.GetToken(LiteParserBang, 0)
}

func (s *TypeReferenceContext) TypeNotNull() ITypeNotNullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNotNullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNotNullContext)
}

func (s *TypeReferenceContext) TypeNullable() ITypeNullableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNullableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNullableContext)
}

func (s *TypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeReference() (localctx ITypeReferenceContext) {
	localctx = NewTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, LiteParserRULE_typeReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1745)
		p.Match(LiteParserBang)
	}
	p.SetState(1748)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserLinqFrom, LiteParserLinqBy, LiteParserLinqSelect, LiteParserLinqWhere, LiteParserLinqGroup, LiteParserLinqInto, LiteParserLinqOrderby, LiteParserLinqJoin, LiteParserLinqLet, LiteParserLinqIn, LiteParserLinqOn, LiteParserLinqEquals, LiteParserLinqAscending, LiteParserLinqDescending, LiteParserLess, LiteParserLeft_Paren, LiteParserLeft_Brack, LiteParserTypeI8, LiteParserTypeU8, LiteParserTypeI16, LiteParserTypeU16, LiteParserTypeI32, LiteParserTypeU32, LiteParserTypeI64, LiteParserTypeU64, LiteParserTypeF32, LiteParserTypeF64, LiteParserTypeChr, LiteParserTypeStr, LiteParserTypeBool, LiteParserTypeInt, LiteParserTypeNum, LiteParserTypeByte, LiteParserTypeAny, LiteParserIDPrivate, LiteParserIDPublic:
		{
			p.SetState(1746)
			p.TypeNotNull()
		}

	case LiteParserQuestion:
		{
			p.SetState(1747)
			p.TypeNullable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeNullableContext is an interface to support dynamic dispatch.
type ITypeNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNullableContext differentiates from other interfaces.
	IsTypeNullableContext()
}

type TypeNullableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNullableContext() *TypeNullableContext {
	var p = new(TypeNullableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeNullable
	return p
}

func (*TypeNullableContext) IsTypeNullableContext() {}

func NewTypeNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNullableContext {
	var p = new(TypeNullableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeNullable

	return p
}

func (s *TypeNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNullableContext) Question() antlr.TerminalNode {
	return s.GetToken(LiteParserQuestion, 0)
}

func (s *TypeNullableContext) TypeNotNull() ITypeNotNullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNotNullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNotNullContext)
}

func (s *TypeNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNullableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeNullable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeNullable() (localctx ITypeNullableContext) {
	localctx = NewTypeNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, LiteParserRULE_typeNullable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1750)
		p.Match(LiteParserQuestion)
	}
	{
		p.SetState(1751)
		p.TypeNotNull()
	}

	return localctx
}

// ITypeTupleContext is an interface to support dynamic dispatch.
type ITypeTupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeTupleContext differentiates from other interfaces.
	IsTypeTupleContext()
}

type TypeTupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTupleContext() *TypeTupleContext {
	var p = new(TypeTupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeTuple
	return p
}

func (*TypeTupleContext) IsTypeTupleContext() {}

func NewTypeTupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTupleContext {
	var p = new(TypeTupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeTuple

	return p
}

func (s *TypeTupleContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTupleContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *TypeTupleContext) AllTypeType() []ITypeTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem())
	var tst = make([]ITypeTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeTypeContext)
		}
	}

	return tst
}

func (s *TypeTupleContext) TypeType(i int) ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeTupleContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *TypeTupleContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *TypeTupleContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *TypeTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeTuple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeTuple() (localctx ITypeTupleContext) {
	localctx = NewTypeTupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, LiteParserRULE_typeTuple)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1753)
		p.Match(LiteParserLess)
	}
	{
		p.SetState(1754)
		p.TypeType()
	}
	p.SetState(1758)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == LiteParserComma {
		{
			p.SetState(1755)
			p.More()
		}
		{
			p.SetState(1756)
			p.TypeType()
		}

		p.SetState(1760)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1762)
		p.Match(LiteParserGreater)
	}

	return localctx
}

// ITypeArrayContext is an interface to support dynamic dispatch.
type ITypeArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArrayContext differentiates from other interfaces.
	IsTypeArrayContext()
}

type TypeArrayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArrayContext() *TypeArrayContext {
	var p = new(TypeArrayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeArray
	return p
}

func (*TypeArrayContext) IsTypeArrayContext() {}

func NewTypeArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArrayContext {
	var p = new(TypeArrayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeArray

	return p
}

func (s *TypeArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArrayContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *TypeArrayContext) Colon() antlr.TerminalNode {
	return s.GetToken(LiteParserColon, 0)
}

func (s *TypeArrayContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *TypeArrayContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeArray(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeArray() (localctx ITypeArrayContext) {
	localctx = NewTypeArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, LiteParserRULE_typeArray)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1764)
		p.Match(LiteParserLeft_Brack)
	}
	{
		p.SetState(1765)
		p.Match(LiteParserColon)
	}
	{
		p.SetState(1766)
		p.Match(LiteParserRight_Brack)
	}
	{
		p.SetState(1767)
		p.TypeType()
	}

	return localctx
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeList
	return p
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *TypeListContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *TypeListContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, LiteParserRULE_typeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1769)
		p.Match(LiteParserLeft_Brack)
	}
	{
		p.SetState(1770)
		p.Match(LiteParserRight_Brack)
	}
	{
		p.SetState(1771)
		p.TypeType()
	}

	return localctx
}

// ITypeSetContext is an interface to support dynamic dispatch.
type ITypeSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeSetContext differentiates from other interfaces.
	IsTypeSetContext()
}

type TypeSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSetContext() *TypeSetContext {
	var p = new(TypeSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeSet
	return p
}

func (*TypeSetContext) IsTypeSetContext() {}

func NewTypeSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSetContext {
	var p = new(TypeSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeSet

	return p
}

func (s *TypeSetContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSetContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *TypeSetContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeSetContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *TypeSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeSet() (localctx ITypeSetContext) {
	localctx = NewTypeSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, LiteParserRULE_typeSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1773)
		p.Match(LiteParserLeft_Brack)
	}
	{
		p.SetState(1774)
		p.TypeType()
	}
	{
		p.SetState(1775)
		p.Match(LiteParserRight_Brack)
	}

	return localctx
}

// ITypeDictionaryContext is an interface to support dynamic dispatch.
type ITypeDictionaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDictionaryContext differentiates from other interfaces.
	IsTypeDictionaryContext()
}

type TypeDictionaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDictionaryContext() *TypeDictionaryContext {
	var p = new(TypeDictionaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeDictionary
	return p
}

func (*TypeDictionaryContext) IsTypeDictionaryContext() {}

func NewTypeDictionaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDictionaryContext {
	var p = new(TypeDictionaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeDictionary

	return p
}

func (s *TypeDictionaryContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDictionaryContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *TypeDictionaryContext) AllTypeType() []ITypeTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem())
	var tst = make([]ITypeTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeTypeContext)
		}
	}

	return tst
}

func (s *TypeDictionaryContext) TypeType(i int) ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeDictionaryContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *TypeDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDictionaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDictionaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeDictionary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeDictionary() (localctx ITypeDictionaryContext) {
	localctx = NewTypeDictionaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, LiteParserRULE_typeDictionary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1777)
		p.Match(LiteParserLeft_Brack)
	}
	{
		p.SetState(1778)
		p.TypeType()
	}
	{
		p.SetState(1779)
		p.Match(LiteParserRight_Brack)
	}
	{
		p.SetState(1780)
		p.TypeType()
	}

	return localctx
}

// ITypeChannelContext is an interface to support dynamic dispatch.
type ITypeChannelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeChannelContext differentiates from other interfaces.
	IsTypeChannelContext()
}

type TypeChannelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeChannelContext() *TypeChannelContext {
	var p = new(TypeChannelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeChannel
	return p
}

func (*TypeChannelContext) IsTypeChannelContext() {}

func NewTypeChannelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeChannelContext {
	var p = new(TypeChannelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeChannel

	return p
}

func (s *TypeChannelContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeChannelContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *TypeChannelContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *TypeChannelContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *TypeChannelContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeChannelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeChannelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeChannelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeChannel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeChannel() (localctx ITypeChannelContext) {
	localctx = NewTypeChannelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, LiteParserRULE_typeChannel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1782)
		p.Match(LiteParserLeft_Brack)
	}
	{
		p.SetState(1783)
		p.Match(LiteParserRight_Arrow)
	}
	{
		p.SetState(1784)
		p.Match(LiteParserRight_Brack)
	}
	{
		p.SetState(1785)
		p.TypeType()
	}

	return localctx
}

// ITypePackageContext is an interface to support dynamic dispatch.
type ITypePackageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypePackageContext differentiates from other interfaces.
	IsTypePackageContext()
}

type TypePackageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypePackageContext() *TypePackageContext {
	var p = new(TypePackageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typePackage
	return p
}

func (*TypePackageContext) IsTypePackageContext() {}

func NewTypePackageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypePackageContext {
	var p = new(TypePackageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typePackage

	return p
}

func (s *TypePackageContext) GetParser() antlr.Parser { return s.parser }

func (s *TypePackageContext) NameSpaceItem() INameSpaceItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameSpaceItemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameSpaceItemContext)
}

func (s *TypePackageContext) TemplateCall() ITemplateCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateCallContext)
}

func (s *TypePackageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypePackageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypePackageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypePackage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypePackage() (localctx ITypePackageContext) {
	localctx = NewTypePackageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, LiteParserRULE_typePackage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1787)
		p.NameSpaceItem()
	}
	p.SetState(1789)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1788)
			p.TemplateCall()
		}

	}

	return localctx
}

// ITypeFunctionContext is an interface to support dynamic dispatch.
type ITypeFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsTypeFunctionContext differentiates from other interfaces.
	IsTypeFunctionContext()
}

type TypeFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyTypeFunctionContext() *TypeFunctionContext {
	var p = new(TypeFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeFunction
	return p
}

func (*TypeFunctionContext) IsTypeFunctionContext() {}

func NewTypeFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeFunctionContext {
	var p = new(TypeFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeFunction

	return p
}

func (s *TypeFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeFunctionContext) GetT() antlr.Token { return s.t }

func (s *TypeFunctionContext) SetT(v antlr.Token) { s.t = v }

func (s *TypeFunctionContext) Left_paren() ILeft_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeft_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeft_parenContext)
}

func (s *TypeFunctionContext) AllTypeFunctionParameterClause() []ITypeFunctionParameterClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeFunctionParameterClauseContext)(nil)).Elem())
	var tst = make([]ITypeFunctionParameterClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeFunctionParameterClauseContext)
		}
	}

	return tst
}

func (s *TypeFunctionContext) TypeFunctionParameterClause(i int) ITypeFunctionParameterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeFunctionParameterClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeFunctionParameterClauseContext)
}

func (s *TypeFunctionContext) Right_paren() IRight_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRight_parenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRight_parenContext)
}

func (s *TypeFunctionContext) Right_Arrow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Arrow, 0)
}

func (s *TypeFunctionContext) Right_Flow() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Flow, 0)
}

func (s *TypeFunctionContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *TypeFunctionContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *TypeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeFunction() (localctx ITypeFunctionContext) {
	localctx = NewTypeFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, LiteParserRULE_typeFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1791)
		p.Left_paren()
	}
	{
		p.SetState(1792)
		p.TypeFunctionParameterClause()
	}
	{
		p.SetState(1793)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*TypeFunctionContext).t = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserRight_Arrow || _la == LiteParserRight_Flow) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*TypeFunctionContext).t = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1797)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(1794)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(1799)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1800)
		p.TypeFunctionParameterClause()
	}
	{
		p.SetState(1801)
		p.Right_paren()
	}

	return localctx
}

// ITypeAnyContext is an interface to support dynamic dispatch.
type ITypeAnyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAnyContext differentiates from other interfaces.
	IsTypeAnyContext()
}

type TypeAnyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAnyContext() *TypeAnyContext {
	var p = new(TypeAnyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeAny
	return p
}

func (*TypeAnyContext) IsTypeAnyContext() {}

func NewTypeAnyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAnyContext {
	var p = new(TypeAnyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeAny

	return p
}

func (s *TypeAnyContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAnyContext) TypeAny() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeAny, 0)
}

func (s *TypeAnyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAnyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeAny(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeAny() (localctx ITypeAnyContext) {
	localctx = NewTypeAnyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, LiteParserRULE_typeAny)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1803)
		p.Match(LiteParserTypeAny)
	}

	return localctx
}

// ITypeFunctionParameterClauseContext is an interface to support dynamic dispatch.
type ITypeFunctionParameterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeFunctionParameterClauseContext differentiates from other interfaces.
	IsTypeFunctionParameterClauseContext()
}

type TypeFunctionParameterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeFunctionParameterClauseContext() *TypeFunctionParameterClauseContext {
	var p = new(TypeFunctionParameterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeFunctionParameterClause
	return p
}

func (*TypeFunctionParameterClauseContext) IsTypeFunctionParameterClauseContext() {}

func NewTypeFunctionParameterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeFunctionParameterClauseContext {
	var p = new(TypeFunctionParameterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeFunctionParameterClause

	return p
}

func (s *TypeFunctionParameterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeFunctionParameterClauseContext) AllTypeType() []ITypeTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem())
	var tst = make([]ITypeTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeTypeContext)
		}
	}

	return tst
}

func (s *TypeFunctionParameterClauseContext) TypeType(i int) ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeFunctionParameterClauseContext) AllMore() []IMoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMoreContext)(nil)).Elem())
	var tst = make([]IMoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMoreContext)
		}
	}

	return tst
}

func (s *TypeFunctionParameterClauseContext) More(i int) IMoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMoreContext)
}

func (s *TypeFunctionParameterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeFunctionParameterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeFunctionParameterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeFunctionParameterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeFunctionParameterClause() (localctx ITypeFunctionParameterClauseContext) {
	localctx = NewTypeFunctionParameterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, LiteParserRULE_typeFunctionParameterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1806)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserLinqFrom)|(1<<LiteParserLinqBy)|(1<<LiteParserLinqSelect)|(1<<LiteParserLinqWhere)|(1<<LiteParserLinqGroup)|(1<<LiteParserLinqInto)|(1<<LiteParserLinqOrderby)|(1<<LiteParserLinqJoin)|(1<<LiteParserLinqLet)|(1<<LiteParserLinqIn)|(1<<LiteParserLinqOn)|(1<<LiteParserLinqEquals)|(1<<LiteParserLinqAscending)|(1<<LiteParserLinqDescending))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(LiteParserLess-38))|(1<<(LiteParserLeft_Paren-38))|(1<<(LiteParserLeft_Brack-38))|(1<<(LiteParserQuestion-38))|(1<<(LiteParserBang-38))|(1<<(LiteParserTypeI8-38))|(1<<(LiteParserTypeU8-38))|(1<<(LiteParserTypeI16-38))|(1<<(LiteParserTypeU16-38))|(1<<(LiteParserTypeI32-38))|(1<<(LiteParserTypeU32-38))|(1<<(LiteParserTypeI64-38))|(1<<(LiteParserTypeU64-38)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(LiteParserTypeF32-70))|(1<<(LiteParserTypeF64-70))|(1<<(LiteParserTypeChr-70))|(1<<(LiteParserTypeStr-70))|(1<<(LiteParserTypeBool-70))|(1<<(LiteParserTypeInt-70))|(1<<(LiteParserTypeNum-70))|(1<<(LiteParserTypeByte-70))|(1<<(LiteParserTypeAny-70))|(1<<(LiteParserIDPrivate-70))|(1<<(LiteParserIDPublic-70)))) != 0) {
		{
			p.SetState(1805)
			p.TypeType()
		}

	}
	p.SetState(1813)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserComma {
		{
			p.SetState(1808)
			p.More()
		}
		{
			p.SetState(1809)
			p.TypeType()
		}

		p.SetState(1815)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeBasicContext is an interface to support dynamic dispatch.
type ITypeBasicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsTypeBasicContext differentiates from other interfaces.
	IsTypeBasicContext()
}

type TypeBasicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyTypeBasicContext() *TypeBasicContext {
	var p = new(TypeBasicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_typeBasic
	return p
}

func (*TypeBasicContext) IsTypeBasicContext() {}

func NewTypeBasicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeBasicContext {
	var p = new(TypeBasicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_typeBasic

	return p
}

func (s *TypeBasicContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeBasicContext) GetT() antlr.Token { return s.t }

func (s *TypeBasicContext) SetT(v antlr.Token) { s.t = v }

func (s *TypeBasicContext) TypeI8() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeI8, 0)
}

func (s *TypeBasicContext) TypeU8() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeU8, 0)
}

func (s *TypeBasicContext) TypeI16() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeI16, 0)
}

func (s *TypeBasicContext) TypeU16() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeU16, 0)
}

func (s *TypeBasicContext) TypeI32() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeI32, 0)
}

func (s *TypeBasicContext) TypeU32() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeU32, 0)
}

func (s *TypeBasicContext) TypeI64() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeI64, 0)
}

func (s *TypeBasicContext) TypeU64() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeU64, 0)
}

func (s *TypeBasicContext) TypeF32() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeF32, 0)
}

func (s *TypeBasicContext) TypeF64() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeF64, 0)
}

func (s *TypeBasicContext) TypeChr() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeChr, 0)
}

func (s *TypeBasicContext) TypeStr() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeStr, 0)
}

func (s *TypeBasicContext) TypeBool() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeBool, 0)
}

func (s *TypeBasicContext) TypeInt() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeInt, 0)
}

func (s *TypeBasicContext) TypeNum() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeNum, 0)
}

func (s *TypeBasicContext) TypeByte() antlr.TerminalNode {
	return s.GetToken(LiteParserTypeByte, 0)
}

func (s *TypeBasicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeBasicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeBasicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitTypeBasic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) TypeBasic() (localctx ITypeBasicContext) {
	localctx = NewTypeBasicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, LiteParserRULE_typeBasic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1832)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserTypeI8:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1816)

			var _m = p.Match(LiteParserTypeI8)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeU8:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1817)

			var _m = p.Match(LiteParserTypeU8)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeI16:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1818)

			var _m = p.Match(LiteParserTypeI16)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeU16:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1819)

			var _m = p.Match(LiteParserTypeU16)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeI32:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1820)

			var _m = p.Match(LiteParserTypeI32)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeU32:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1821)

			var _m = p.Match(LiteParserTypeU32)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeI64:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1822)

			var _m = p.Match(LiteParserTypeI64)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeU64:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1823)

			var _m = p.Match(LiteParserTypeU64)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeF32:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1824)

			var _m = p.Match(LiteParserTypeF32)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeF64:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1825)

			var _m = p.Match(LiteParserTypeF64)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeChr:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1826)

			var _m = p.Match(LiteParserTypeChr)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeStr:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1827)

			var _m = p.Match(LiteParserTypeStr)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeBool:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1828)

			var _m = p.Match(LiteParserTypeBool)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeInt:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1829)

			var _m = p.Match(LiteParserTypeInt)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeNum:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1830)

			var _m = p.Match(LiteParserTypeNum)

			localctx.(*TypeBasicContext).t = _m
		}

	case LiteParserTypeByte:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1831)

			var _m = p.Match(LiteParserTypeByte)

			localctx.(*TypeBasicContext).t = _m
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INilExprContext is an interface to support dynamic dispatch.
type INilExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNilExprContext differentiates from other interfaces.
	IsNilExprContext()
}

type NilExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNilExprContext() *NilExprContext {
	var p = new(NilExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_nilExpr
	return p
}

func (*NilExprContext) IsNilExprContext() {}

func NewNilExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NilExprContext {
	var p = new(NilExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_nilExpr

	return p
}

func (s *NilExprContext) GetParser() antlr.Parser { return s.parser }

func (s *NilExprContext) NilLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserNilLiteral, 0)
}

func (s *NilExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NilExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NilExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitNilExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) NilExpr() (localctx INilExprContext) {
	localctx = NewNilExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, LiteParserRULE_nilExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1834)
		p.Match(LiteParserNilLiteral)
	}

	return localctx
}

// IBoolExprContext is an interface to support dynamic dispatch.
type IBoolExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// IsBoolExprContext differentiates from other interfaces.
	IsBoolExprContext()
}

type BoolExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      antlr.Token
}

func NewEmptyBoolExprContext() *BoolExprContext {
	var p = new(BoolExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_boolExpr
	return p
}

func (*BoolExprContext) IsBoolExprContext() {}

func NewBoolExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolExprContext {
	var p = new(BoolExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_boolExpr

	return p
}

func (s *BoolExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolExprContext) GetT() antlr.Token { return s.t }

func (s *BoolExprContext) SetT(v antlr.Token) { s.t = v }

func (s *BoolExprContext) TrueLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserTrueLiteral, 0)
}

func (s *BoolExprContext) FalseLiteral() antlr.TerminalNode {
	return s.GetToken(LiteParserFalseLiteral, 0)
}

func (s *BoolExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoolExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitBoolExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) BoolExpr() (localctx IBoolExprContext) {
	localctx = NewBoolExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, LiteParserRULE_boolExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1838)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserTrueLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1836)

			var _m = p.Match(LiteParserTrueLiteral)

			localctx.(*BoolExprContext).t = _m
		}

	case LiteParserFalseLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1837)

			var _m = p.Match(LiteParserFalseLiteral)

			localctx.(*BoolExprContext).t = _m
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJudgeTypeContext is an interface to support dynamic dispatch.
type IJudgeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsJudgeTypeContext differentiates from other interfaces.
	IsJudgeTypeContext()
}

type JudgeTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyJudgeTypeContext() *JudgeTypeContext {
	var p = new(JudgeTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_judgeType
	return p
}

func (*JudgeTypeContext) IsJudgeTypeContext() {}

func NewJudgeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JudgeTypeContext {
	var p = new(JudgeTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_judgeType

	return p
}

func (s *JudgeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JudgeTypeContext) GetOp() antlr.Token { return s.op }

func (s *JudgeTypeContext) SetOp(v antlr.Token) { s.op = v }

func (s *JudgeTypeContext) Equal_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual_Equal, 0)
}

func (s *JudgeTypeContext) Not_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserNot_Equal, 0)
}

func (s *JudgeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JudgeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JudgeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitJudgeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) JudgeType() (localctx IJudgeTypeContext) {
	localctx = NewJudgeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, LiteParserRULE_judgeType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1840)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*JudgeTypeContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserEqual_Equal || _la == LiteParserNot_Equal) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*JudgeTypeContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBitwiseContext is an interface to support dynamic dispatch.
type IBitwiseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseContext differentiates from other interfaces.
	IsBitwiseContext()
}

type BitwiseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseContext() *BitwiseContext {
	var p = new(BitwiseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_bitwise
	return p
}

func (*BitwiseContext) IsBitwiseContext() {}

func NewBitwiseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseContext {
	var p = new(BitwiseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_bitwise

	return p
}

func (s *BitwiseContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseContext) BitwiseAnd() IBitwiseAndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseAndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndContext)
}

func (s *BitwiseContext) BitwiseOr() IBitwiseOrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseOrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitwiseOrContext)
}

func (s *BitwiseContext) BitwiseXor() IBitwiseXorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseXorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorContext)
}

func (s *BitwiseContext) BitwiseLeftShift() IBitwiseLeftShiftContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseLeftShiftContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitwiseLeftShiftContext)
}

func (s *BitwiseContext) BitwiseRightShift() IBitwiseRightShiftContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitwiseRightShiftContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitwiseRightShiftContext)
}

func (s *BitwiseContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *BitwiseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitBitwise(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Bitwise() (localctx IBitwiseContext) {
	localctx = NewBitwiseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, LiteParserRULE_bitwise)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1847)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserAnd:
		{
			p.SetState(1842)
			p.BitwiseAnd()
		}

	case LiteParserOr:
		{
			p.SetState(1843)
			p.BitwiseOr()
		}

	case LiteParserXor:
		{
			p.SetState(1844)
			p.BitwiseXor()
		}

	case LiteParserLess:
		{
			p.SetState(1845)
			p.BitwiseLeftShift()
		}

	case LiteParserGreater:
		{
			p.SetState(1846)
			p.BitwiseRightShift()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1850)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1849)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IBitwiseAndContext is an interface to support dynamic dispatch.
type IBitwiseAndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseAndContext differentiates from other interfaces.
	IsBitwiseAndContext()
}

type BitwiseAndContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseAndContext() *BitwiseAndContext {
	var p = new(BitwiseAndContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_bitwiseAnd
	return p
}

func (*BitwiseAndContext) IsBitwiseAndContext() {}

func NewBitwiseAndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseAndContext {
	var p = new(BitwiseAndContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_bitwiseAnd

	return p
}

func (s *BitwiseAndContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseAndContext) AllAnd() []antlr.TerminalNode {
	return s.GetTokens(LiteParserAnd)
}

func (s *BitwiseAndContext) And(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserAnd, i)
}

func (s *BitwiseAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseAndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseAndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitBitwiseAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) BitwiseAnd() (localctx IBitwiseAndContext) {
	localctx = NewBitwiseAndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, LiteParserRULE_bitwiseAnd)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1852)
		p.Match(LiteParserAnd)
	}
	{
		p.SetState(1853)
		p.Match(LiteParserAnd)
	}

	return localctx
}

// IBitwiseOrContext is an interface to support dynamic dispatch.
type IBitwiseOrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseOrContext differentiates from other interfaces.
	IsBitwiseOrContext()
}

type BitwiseOrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseOrContext() *BitwiseOrContext {
	var p = new(BitwiseOrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_bitwiseOr
	return p
}

func (*BitwiseOrContext) IsBitwiseOrContext() {}

func NewBitwiseOrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseOrContext {
	var p = new(BitwiseOrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_bitwiseOr

	return p
}

func (s *BitwiseOrContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseOrContext) AllOr() []antlr.TerminalNode {
	return s.GetTokens(LiteParserOr)
}

func (s *BitwiseOrContext) Or(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserOr, i)
}

func (s *BitwiseOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseOrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseOrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitBitwiseOr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) BitwiseOr() (localctx IBitwiseOrContext) {
	localctx = NewBitwiseOrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, LiteParserRULE_bitwiseOr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1855)
		p.Match(LiteParserOr)
	}
	{
		p.SetState(1856)
		p.Match(LiteParserOr)
	}

	return localctx
}

// IBitwiseNotContext is an interface to support dynamic dispatch.
type IBitwiseNotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseNotContext differentiates from other interfaces.
	IsBitwiseNotContext()
}

type BitwiseNotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseNotContext() *BitwiseNotContext {
	var p = new(BitwiseNotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_bitwiseNot
	return p
}

func (*BitwiseNotContext) IsBitwiseNotContext() {}

func NewBitwiseNotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseNotContext {
	var p = new(BitwiseNotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_bitwiseNot

	return p
}

func (s *BitwiseNotContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseNotContext) AllWave() []antlr.TerminalNode {
	return s.GetTokens(LiteParserWave)
}

func (s *BitwiseNotContext) Wave(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserWave, i)
}

func (s *BitwiseNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseNotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitBitwiseNot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) BitwiseNot() (localctx IBitwiseNotContext) {
	localctx = NewBitwiseNotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, LiteParserRULE_bitwiseNot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1858)
		p.Match(LiteParserWave)
	}
	{
		p.SetState(1859)
		p.Match(LiteParserWave)
	}

	return localctx
}

// IBitwiseXorContext is an interface to support dynamic dispatch.
type IBitwiseXorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseXorContext differentiates from other interfaces.
	IsBitwiseXorContext()
}

type BitwiseXorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseXorContext() *BitwiseXorContext {
	var p = new(BitwiseXorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_bitwiseXor
	return p
}

func (*BitwiseXorContext) IsBitwiseXorContext() {}

func NewBitwiseXorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseXorContext {
	var p = new(BitwiseXorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_bitwiseXor

	return p
}

func (s *BitwiseXorContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseXorContext) AllXor() []antlr.TerminalNode {
	return s.GetTokens(LiteParserXor)
}

func (s *BitwiseXorContext) Xor(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserXor, i)
}

func (s *BitwiseXorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseXorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseXorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitBitwiseXor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) BitwiseXor() (localctx IBitwiseXorContext) {
	localctx = NewBitwiseXorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, LiteParserRULE_bitwiseXor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1861)
		p.Match(LiteParserXor)
	}
	{
		p.SetState(1862)
		p.Match(LiteParserXor)
	}

	return localctx
}

// IBitwiseLeftShiftContext is an interface to support dynamic dispatch.
type IBitwiseLeftShiftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseLeftShiftContext differentiates from other interfaces.
	IsBitwiseLeftShiftContext()
}

type BitwiseLeftShiftContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseLeftShiftContext() *BitwiseLeftShiftContext {
	var p = new(BitwiseLeftShiftContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_bitwiseLeftShift
	return p
}

func (*BitwiseLeftShiftContext) IsBitwiseLeftShiftContext() {}

func NewBitwiseLeftShiftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseLeftShiftContext {
	var p = new(BitwiseLeftShiftContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_bitwiseLeftShift

	return p
}

func (s *BitwiseLeftShiftContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseLeftShiftContext) AllLess() []antlr.TerminalNode {
	return s.GetTokens(LiteParserLess)
}

func (s *BitwiseLeftShiftContext) Less(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserLess, i)
}

func (s *BitwiseLeftShiftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseLeftShiftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseLeftShiftContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitBitwiseLeftShift(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) BitwiseLeftShift() (localctx IBitwiseLeftShiftContext) {
	localctx = NewBitwiseLeftShiftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, LiteParserRULE_bitwiseLeftShift)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1864)
		p.Match(LiteParserLess)
	}
	{
		p.SetState(1865)
		p.Match(LiteParserLess)
	}

	return localctx
}

// IBitwiseRightShiftContext is an interface to support dynamic dispatch.
type IBitwiseRightShiftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitwiseRightShiftContext differentiates from other interfaces.
	IsBitwiseRightShiftContext()
}

type BitwiseRightShiftContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwiseRightShiftContext() *BitwiseRightShiftContext {
	var p = new(BitwiseRightShiftContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_bitwiseRightShift
	return p
}

func (*BitwiseRightShiftContext) IsBitwiseRightShiftContext() {}

func NewBitwiseRightShiftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseRightShiftContext {
	var p = new(BitwiseRightShiftContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_bitwiseRightShift

	return p
}

func (s *BitwiseRightShiftContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseRightShiftContext) AllGreater() []antlr.TerminalNode {
	return s.GetTokens(LiteParserGreater)
}

func (s *BitwiseRightShiftContext) Greater(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, i)
}

func (s *BitwiseRightShiftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseRightShiftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseRightShiftContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitBitwiseRightShift(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) BitwiseRightShift() (localctx IBitwiseRightShiftContext) {
	localctx = NewBitwiseRightShiftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, LiteParserRULE_bitwiseRightShift)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1867)
		p.Match(LiteParserGreater)
	}
	{
		p.SetState(1868)
		p.Match(LiteParserGreater)
	}

	return localctx
}

// IJudgeContext is an interface to support dynamic dispatch.
type IJudgeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsJudgeContext differentiates from other interfaces.
	IsJudgeContext()
}

type JudgeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyJudgeContext() *JudgeContext {
	var p = new(JudgeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_judge
	return p
}

func (*JudgeContext) IsJudgeContext() {}

func NewJudgeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JudgeContext {
	var p = new(JudgeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_judge

	return p
}

func (s *JudgeContext) GetParser() antlr.Parser { return s.parser }

func (s *JudgeContext) GetOp() antlr.Token { return s.op }

func (s *JudgeContext) SetOp(v antlr.Token) { s.op = v }

func (s *JudgeContext) Or() antlr.TerminalNode {
	return s.GetToken(LiteParserOr, 0)
}

func (s *JudgeContext) And() antlr.TerminalNode {
	return s.GetToken(LiteParserAnd, 0)
}

func (s *JudgeContext) Equal_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual_Equal, 0)
}

func (s *JudgeContext) Not_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserNot_Equal, 0)
}

func (s *JudgeContext) Less_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserLess_Equal, 0)
}

func (s *JudgeContext) Greater_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater_Equal, 0)
}

func (s *JudgeContext) Less() antlr.TerminalNode {
	return s.GetToken(LiteParserLess, 0)
}

func (s *JudgeContext) Greater() antlr.TerminalNode {
	return s.GetToken(LiteParserGreater, 0)
}

func (s *JudgeContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *JudgeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JudgeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JudgeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitJudge(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Judge() (localctx IJudgeContext) {
	localctx = NewJudgeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, LiteParserRULE_judge)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1870)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*JudgeContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserEqual_Equal)|(1<<LiteParserLess_Equal)|(1<<LiteParserGreater_Equal)|(1<<LiteParserNot_Equal))) != 0) || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(LiteParserLess-38))|(1<<(LiteParserGreater-38))|(1<<(LiteParserAnd-38))|(1<<(LiteParserOr-38)))) != 0)) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*JudgeContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1872)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1871)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IAssignContext is an interface to support dynamic dispatch.
type IAssignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsAssignContext differentiates from other interfaces.
	IsAssignContext()
}

type AssignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyAssignContext() *AssignContext {
	var p = new(AssignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_assign
	return p
}

func (*AssignContext) IsAssignContext() {}

func NewAssignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignContext {
	var p = new(AssignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_assign

	return p
}

func (s *AssignContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignContext) GetOp() antlr.Token { return s.op }

func (s *AssignContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignContext) Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserEqual, 0)
}

func (s *AssignContext) Add_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserAdd_Equal, 0)
}

func (s *AssignContext) Sub_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserSub_Equal, 0)
}

func (s *AssignContext) Mul_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserMul_Equal, 0)
}

func (s *AssignContext) Div_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserDiv_Equal, 0)
}

func (s *AssignContext) Mod_Equal() antlr.TerminalNode {
	return s.GetToken(LiteParserMod_Equal, 0)
}

func (s *AssignContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *AssignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitAssign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Assign() (localctx IAssignContext) {
	localctx = NewAssignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, LiteParserRULE_assign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1874)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AssignContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((_la-18)&-(0x1f+1)) == 0 && ((1<<uint((_la-18)))&((1<<(LiteParserAdd_Equal-18))|(1<<(LiteParserSub_Equal-18))|(1<<(LiteParserMul_Equal-18))|(1<<(LiteParserDiv_Equal-18))|(1<<(LiteParserMod_Equal-18))|(1<<(LiteParserEqual-18)))) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AssignContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1876)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1875)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IAddContext is an interface to support dynamic dispatch.
type IAddContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsAddContext differentiates from other interfaces.
	IsAddContext()
}

type AddContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyAddContext() *AddContext {
	var p = new(AddContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_add
	return p
}

func (*AddContext) IsAddContext() {}

func NewAddContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddContext {
	var p = new(AddContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_add

	return p
}

func (s *AddContext) GetParser() antlr.Parser { return s.parser }

func (s *AddContext) GetOp() antlr.Token { return s.op }

func (s *AddContext) SetOp(v antlr.Token) { s.op = v }

func (s *AddContext) Add() antlr.TerminalNode {
	return s.GetToken(LiteParserAdd, 0)
}

func (s *AddContext) Sub() antlr.TerminalNode {
	return s.GetToken(LiteParserSub, 0)
}

func (s *AddContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *AddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitAdd(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Add() (localctx IAddContext) {
	localctx = NewAddContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, LiteParserRULE_add)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1878)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AddContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserAdd || _la == LiteParserSub) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AddContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1880)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1879)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IMulContext is an interface to support dynamic dispatch.
type IMulContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsMulContext differentiates from other interfaces.
	IsMulContext()
}

type MulContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyMulContext() *MulContext {
	var p = new(MulContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_mul
	return p
}

func (*MulContext) IsMulContext() {}

func NewMulContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MulContext {
	var p = new(MulContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_mul

	return p
}

func (s *MulContext) GetParser() antlr.Parser { return s.parser }

func (s *MulContext) GetOp() antlr.Token { return s.op }

func (s *MulContext) SetOp(v antlr.Token) { s.op = v }

func (s *MulContext) Mul() antlr.TerminalNode {
	return s.GetToken(LiteParserMul, 0)
}

func (s *MulContext) Div() antlr.TerminalNode {
	return s.GetToken(LiteParserDiv, 0)
}

func (s *MulContext) Mod() antlr.TerminalNode {
	return s.GetToken(LiteParserMod, 0)
}

func (s *MulContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *MulContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MulContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MulContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitMul(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Mul() (localctx IMulContext) {
	localctx = NewMulContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, LiteParserRULE_mul)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1882)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*MulContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(LiteParserMul-55))|(1<<(LiteParserDiv-55))|(1<<(LiteParserMod-55)))) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*MulContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1884)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1883)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IPowContext is an interface to support dynamic dispatch.
type IPowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsPowContext differentiates from other interfaces.
	IsPowContext()
}

type PowContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyPowContext() *PowContext {
	var p = new(PowContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_pow
	return p
}

func (*PowContext) IsPowContext() {}

func NewPowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowContext {
	var p = new(PowContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_pow

	return p
}

func (s *PowContext) GetParser() antlr.Parser { return s.parser }

func (s *PowContext) GetOp() antlr.Token { return s.op }

func (s *PowContext) SetOp(v antlr.Token) { s.op = v }

func (s *PowContext) Pow() antlr.TerminalNode {
	return s.GetToken(LiteParserPow, 0)
}

func (s *PowContext) Root() antlr.TerminalNode {
	return s.GetToken(LiteParserRoot, 0)
}

func (s *PowContext) Log() antlr.TerminalNode {
	return s.GetToken(LiteParserLog, 0)
}

func (s *PowContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *PowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitPow(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Pow() (localctx IPowContext) {
	localctx = NewPowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, LiteParserRULE_pow)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1886)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PowContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<LiteParserPow)|(1<<LiteParserRoot)|(1<<LiteParserLog))) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PowContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1888)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == LiteParserNew_Line {
		{
			p.SetState(1887)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// ICallContext is an interface to support dynamic dispatch.
type ICallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsCallContext differentiates from other interfaces.
	IsCallContext()
}

type CallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyCallContext() *CallContext {
	var p = new(CallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_call
	return p
}

func (*CallContext) IsCallContext() {}

func NewCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallContext {
	var p = new(CallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_call

	return p
}

func (s *CallContext) GetParser() antlr.Parser { return s.parser }

func (s *CallContext) GetOp() antlr.Token { return s.op }

func (s *CallContext) SetOp(v antlr.Token) { s.op = v }

func (s *CallContext) Dot() antlr.TerminalNode {
	return s.GetToken(LiteParserDot, 0)
}

func (s *CallContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *CallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Call() (localctx ICallContext) {
	localctx = NewCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, LiteParserRULE_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1890)

		var _m = p.Match(LiteParserDot)

		localctx.(*CallContext).op = _m
	}
	p.SetState(1892)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1891)
			p.Match(LiteParserNew_Line)
		}

	}

	return localctx
}

// IWaveContext is an interface to support dynamic dispatch.
type IWaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsWaveContext differentiates from other interfaces.
	IsWaveContext()
}

type WaveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyWaveContext() *WaveContext {
	var p = new(WaveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_wave
	return p
}

func (*WaveContext) IsWaveContext() {}

func NewWaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaveContext {
	var p = new(WaveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_wave

	return p
}

func (s *WaveContext) GetParser() antlr.Parser { return s.parser }

func (s *WaveContext) GetOp() antlr.Token { return s.op }

func (s *WaveContext) SetOp(v antlr.Token) { s.op = v }

func (s *WaveContext) Wave() antlr.TerminalNode {
	return s.GetToken(LiteParserWave, 0)
}

func (s *WaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitWave(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Wave() (localctx IWaveContext) {
	localctx = NewWaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, LiteParserRULE_wave)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1894)

		var _m = p.Match(LiteParserWave)

		localctx.(*WaveContext).op = _m
	}

	return localctx
}

// IIdContext is an interface to support dynamic dispatch.
type IIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdContext differentiates from other interfaces.
	IsIdContext()
}

type IdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdContext() *IdContext {
	var p = new(IdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_id
	return p
}

func (*IdContext) IsIdContext() {}

func NewIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdContext {
	var p = new(IdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_id

	return p
}

func (s *IdContext) GetParser() antlr.Parser { return s.parser }

func (s *IdContext) IdItem() IIdItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdItemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdItemContext)
}

func (s *IdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Id() (localctx IIdContext) {
	localctx = NewIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, LiteParserRULE_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1896)
		p.IdItem()
	}

	return localctx
}

// IIdItemContext is an interface to support dynamic dispatch.
type IIdItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsIdItemContext differentiates from other interfaces.
	IsIdItemContext()
}

type IdItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyIdItemContext() *IdItemContext {
	var p = new(IdItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_idItem
	return p
}

func (*IdItemContext) IsIdItemContext() {}

func NewIdItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdItemContext {
	var p = new(IdItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_idItem

	return p
}

func (s *IdItemContext) GetParser() antlr.Parser { return s.parser }

func (s *IdItemContext) GetOp() antlr.Token { return s.op }

func (s *IdItemContext) SetOp(v antlr.Token) { s.op = v }

func (s *IdItemContext) IDPublic() antlr.TerminalNode {
	return s.GetToken(LiteParserIDPublic, 0)
}

func (s *IdItemContext) IDPrivate() antlr.TerminalNode {
	return s.GetToken(LiteParserIDPrivate, 0)
}

func (s *IdItemContext) TypeBasic() ITypeBasicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeBasicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeBasicContext)
}

func (s *IdItemContext) TypeAny() ITypeAnyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAnyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAnyContext)
}

func (s *IdItemContext) LinqKeyword() ILinqKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinqKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinqKeywordContext)
}

func (s *IdItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitIdItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) IdItem() (localctx IIdItemContext) {
	localctx = NewIdItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, LiteParserRULE_idItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1902)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case LiteParserIDPrivate, LiteParserIDPublic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1898)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IdItemContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == LiteParserIDPrivate || _la == LiteParserIDPublic) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IdItemContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case LiteParserTypeI8, LiteParserTypeU8, LiteParserTypeI16, LiteParserTypeU16, LiteParserTypeI32, LiteParserTypeU32, LiteParserTypeI64, LiteParserTypeU64, LiteParserTypeF32, LiteParserTypeF64, LiteParserTypeChr, LiteParserTypeStr, LiteParserTypeBool, LiteParserTypeInt, LiteParserTypeNum, LiteParserTypeByte:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1899)
			p.TypeBasic()
		}

	case LiteParserTypeAny:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1900)
			p.TypeAny()
		}

	case LiteParserLinqFrom, LiteParserLinqBy, LiteParserLinqSelect, LiteParserLinqWhere, LiteParserLinqGroup, LiteParserLinqInto, LiteParserLinqOrderby, LiteParserLinqJoin, LiteParserLinqLet, LiteParserLinqIn, LiteParserLinqOn, LiteParserLinqEquals, LiteParserLinqAscending, LiteParserLinqDescending:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1901)
			p.LinqKeyword()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEndContext is an interface to support dynamic dispatch.
type IEndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndContext differentiates from other interfaces.
	IsEndContext()
}

type EndContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndContext() *EndContext {
	var p = new(EndContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_end
	return p
}

func (*EndContext) IsEndContext() {}

func NewEndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndContext {
	var p = new(EndContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_end

	return p
}

func (s *EndContext) GetParser() antlr.Parser { return s.parser }

func (s *EndContext) Semi() antlr.TerminalNode {
	return s.GetToken(LiteParserSemi, 0)
}

func (s *EndContext) New_Line() antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, 0)
}

func (s *EndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitEnd(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) End() (localctx IEndContext) {
	localctx = NewEndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, LiteParserRULE_end)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1904)
		_la = p.GetTokenStream().LA(1)

		if !(_la == LiteParserSemi || _la == LiteParserNew_Line) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMoreContext is an interface to support dynamic dispatch.
type IMoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoreContext differentiates from other interfaces.
	IsMoreContext()
}

type MoreContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoreContext() *MoreContext {
	var p = new(MoreContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_more
	return p
}

func (*MoreContext) IsMoreContext() {}

func NewMoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoreContext {
	var p = new(MoreContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_more

	return p
}

func (s *MoreContext) GetParser() antlr.Parser { return s.parser }

func (s *MoreContext) Comma() antlr.TerminalNode {
	return s.GetToken(LiteParserComma, 0)
}

func (s *MoreContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *MoreContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *MoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitMore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) More() (localctx IMoreContext) {
	localctx = NewMoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, LiteParserRULE_more)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1906)
		p.Match(LiteParserComma)
	}
	p.SetState(1910)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(1907)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(1912)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILeft_braceContext is an interface to support dynamic dispatch.
type ILeft_braceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeft_braceContext differentiates from other interfaces.
	IsLeft_braceContext()
}

type Left_braceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeft_braceContext() *Left_braceContext {
	var p = new(Left_braceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_left_brace
	return p
}

func (*Left_braceContext) IsLeft_braceContext() {}

func NewLeft_braceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Left_braceContext {
	var p = new(Left_braceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_left_brace

	return p
}

func (s *Left_braceContext) GetParser() antlr.Parser { return s.parser }

func (s *Left_braceContext) Left_Brace() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brace, 0)
}

func (s *Left_braceContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *Left_braceContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *Left_braceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Left_braceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Left_braceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLeft_brace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Left_brace() (localctx ILeft_braceContext) {
	localctx = NewLeft_braceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, LiteParserRULE_left_brace)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1913)
		p.Match(LiteParserLeft_Brace)
	}
	p.SetState(1917)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1914)
				p.Match(LiteParserNew_Line)
			}

		}
		p.SetState(1919)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())
	}

	return localctx
}

// IRight_braceContext is an interface to support dynamic dispatch.
type IRight_braceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRight_braceContext differentiates from other interfaces.
	IsRight_braceContext()
}

type Right_braceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRight_braceContext() *Right_braceContext {
	var p = new(Right_braceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_right_brace
	return p
}

func (*Right_braceContext) IsRight_braceContext() {}

func NewRight_braceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Right_braceContext {
	var p = new(Right_braceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_right_brace

	return p
}

func (s *Right_braceContext) GetParser() antlr.Parser { return s.parser }

func (s *Right_braceContext) Right_Brace() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brace, 0)
}

func (s *Right_braceContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *Right_braceContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *Right_braceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Right_braceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Right_braceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitRight_brace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Right_brace() (localctx IRight_braceContext) {
	localctx = NewRight_braceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, LiteParserRULE_right_brace)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1923)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(1920)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(1925)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1926)
		p.Match(LiteParserRight_Brace)
	}

	return localctx
}

// ILeft_parenContext is an interface to support dynamic dispatch.
type ILeft_parenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeft_parenContext differentiates from other interfaces.
	IsLeft_parenContext()
}

type Left_parenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeft_parenContext() *Left_parenContext {
	var p = new(Left_parenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_left_paren
	return p
}

func (*Left_parenContext) IsLeft_parenContext() {}

func NewLeft_parenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Left_parenContext {
	var p = new(Left_parenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_left_paren

	return p
}

func (s *Left_parenContext) GetParser() antlr.Parser { return s.parser }

func (s *Left_parenContext) Left_Paren() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Paren, 0)
}

func (s *Left_parenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Left_parenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Left_parenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLeft_paren(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Left_paren() (localctx ILeft_parenContext) {
	localctx = NewLeft_parenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, LiteParserRULE_left_paren)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1928)
		p.Match(LiteParserLeft_Paren)
	}

	return localctx
}

// IRight_parenContext is an interface to support dynamic dispatch.
type IRight_parenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRight_parenContext differentiates from other interfaces.
	IsRight_parenContext()
}

type Right_parenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRight_parenContext() *Right_parenContext {
	var p = new(Right_parenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_right_paren
	return p
}

func (*Right_parenContext) IsRight_parenContext() {}

func NewRight_parenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Right_parenContext {
	var p = new(Right_parenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_right_paren

	return p
}

func (s *Right_parenContext) GetParser() antlr.Parser { return s.parser }

func (s *Right_parenContext) Right_Paren() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Paren, 0)
}

func (s *Right_parenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Right_parenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Right_parenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitRight_paren(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Right_paren() (localctx IRight_parenContext) {
	localctx = NewRight_parenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, LiteParserRULE_right_paren)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1930)
		p.Match(LiteParserRight_Paren)
	}

	return localctx
}

// ILeft_brackContext is an interface to support dynamic dispatch.
type ILeft_brackContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeft_brackContext differentiates from other interfaces.
	IsLeft_brackContext()
}

type Left_brackContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeft_brackContext() *Left_brackContext {
	var p = new(Left_brackContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_left_brack
	return p
}

func (*Left_brackContext) IsLeft_brackContext() {}

func NewLeft_brackContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Left_brackContext {
	var p = new(Left_brackContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_left_brack

	return p
}

func (s *Left_brackContext) GetParser() antlr.Parser { return s.parser }

func (s *Left_brackContext) Left_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserLeft_Brack, 0)
}

func (s *Left_brackContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *Left_brackContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *Left_brackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Left_brackContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Left_brackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitLeft_brack(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Left_brack() (localctx ILeft_brackContext) {
	localctx = NewLeft_brackContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, LiteParserRULE_left_brack)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1932)
		p.Match(LiteParserLeft_Brack)
	}
	p.SetState(1936)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1933)
				p.Match(LiteParserNew_Line)
			}

		}
		p.SetState(1938)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext())
	}

	return localctx
}

// IRight_brackContext is an interface to support dynamic dispatch.
type IRight_brackContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRight_brackContext differentiates from other interfaces.
	IsRight_brackContext()
}

type Right_brackContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRight_brackContext() *Right_brackContext {
	var p = new(Right_brackContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = LiteParserRULE_right_brack
	return p
}

func (*Right_brackContext) IsRight_brackContext() {}

func NewRight_brackContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Right_brackContext {
	var p = new(Right_brackContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = LiteParserRULE_right_brack

	return p
}

func (s *Right_brackContext) GetParser() antlr.Parser { return s.parser }

func (s *Right_brackContext) Right_Brack() antlr.TerminalNode {
	return s.GetToken(LiteParserRight_Brack, 0)
}

func (s *Right_brackContext) AllNew_Line() []antlr.TerminalNode {
	return s.GetTokens(LiteParserNew_Line)
}

func (s *Right_brackContext) New_Line(i int) antlr.TerminalNode {
	return s.GetToken(LiteParserNew_Line, i)
}

func (s *Right_brackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Right_brackContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Right_brackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case LiteParserVisitor:
		return t.VisitRight_brack(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *LiteParser) Right_brack() (localctx IRight_brackContext) {
	localctx = NewRight_brackContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, LiteParserRULE_right_brack)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == LiteParserNew_Line {
		{
			p.SetState(1939)
			p.Match(LiteParserNew_Line)
		}

		p.SetState(1944)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1945)
		p.Match(LiteParserRight_Brack)
	}

	return localctx
}

func (p *LiteParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 68:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *LiteParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
